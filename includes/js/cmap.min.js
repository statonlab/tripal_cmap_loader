(function () {
'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

{
  const defineMath = (name, assignment) => {
    var configurable = typeof assignment === "function" ? true : false;
    var writable = typeof assignment === "function" ? true : false;
    var enumerable = typeof assignment === "function" ? true : false;

    Object.defineProperty(Math, name, {
      configurable: configurable,
      enumerable: enumerable,
      writable: writable,
      value: assignment
    });
  };

  defineMath("DEG_PER_RAD", Math.PI / 180);
  defineMath("RAD_PER_DEG", 180 / Math.PI);

  const f32A = new Float32Array(1);

  defineMath("scale", function scale(x, inLow, inHigh, outLow, outHigh) {
    if (arguments.length === 0) {
      return NaN;
    }

    if (Number.isNaN(x) ||
        Number.isNaN(inLow) ||
        Number.isNaN(inHigh) ||
        Number.isNaN(outLow) ||
        Number.isNaN(outHigh)) {
      return NaN;
    }

    if (x === Infinity ||
        x === -Infinity) {
      return x;
    }

    return (x - inLow) * (outHigh - outLow) /
      (inHigh - inLow) + outLow;
  });

  defineMath("fscale", function fscale(x, inLow, inHigh, outLow, outHigh) {
    f32A[0] = Math.scale(x, inLow, inHigh, outLow, outHigh);
    return f32A[0];
  });

  defineMath("clamp", function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  });

  defineMath("radians", function radians(degrees) {
    return degrees * Math.DEG_PER_RAD;
  });

  defineMath("degrees", function degrees(radians) {
    return radians * Math.RAD_PER_DEG;
  });
}

/**
 * returns a list of all elements under the cursor
 * from https://gist.github.com/iddan/54d5d9e58311b0495a91bf06de661380
 *
 * It appears Safari and maybe Opera browsers are missing this;
 * https://developer.mozilla.org/en-US/docs/Web/API/Document/elementsFromPoint
 */
if (!document.elementsFromPoint) {
  document.elementsFromPoint = elementsFromPoint;
}

/* istanbul ignore next: depends on browser native elementFromPoint(x,y) */
function elementsFromPoint(x, y) {
  var parents = [];
  var parent = void 0;
  do {
    if (parent !== document.elementFromPoint(x, y)) {
      parent = document.elementFromPoint(x, y);
      parents.push(parent);
      parent.style.pointerEvents = 'none';
    } else {
      parent = false;
    }
  } while (parent);
  parents.forEach(function (parent) {
    return parent.style.pointerEvents = 'all';
  });
  return parents;
}

/**
 * A polyfill is a type of shim that retrofits legacy browsers with modern
 * Javascript, HTML5, or CSS3 features.
 */

// adds Math.scale, fscale, clamp, radians, degrees
// adds elementsFromPoint

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var pubsub = createCommonjsModule(function (module, exports) {
/*
Copyright (c) 2010,2011,2012,2013,2014 Morgan Roderick http://roderick.dk
License: MIT - http://mrgnrdrck.mit-license.org

https://github.com/mroderick/PubSubJS
*/
(function (root, factory){
    'use strict';

    var PubSub = {};
    root.PubSub = PubSub;

    var define = root.define;

    factory(PubSub);

    // AMD support
    if (typeof define === 'function' && define.amd){
        define(function() { return PubSub; });

        // CommonJS and Node.js module support
    } else {
        if (module !== undefined && module.exports) {
            exports = module.exports = PubSub; // Node.js specific `module.exports`
        }
        exports.PubSub = PubSub; // CommonJS module 1.1.1 spec
        module.exports = exports = PubSub; // CommonJS
    }

}(( typeof window === 'object' && window ) || commonjsGlobal, function (PubSub){
    'use strict';

    var messages = {},
        lastUid = -1;

    function hasKeys(obj){
        var key;

        for (key in obj){
            if ( obj.hasOwnProperty(key) ){
                return true;
            }
        }
        return false;
    }

    /**
	 *	Returns a function that throws the passed exception, for use as argument for setTimeout
	 *	@param { Object } ex An Error object
	 */
    function throwException( ex ){
        return function reThrowException(){
            throw ex;
        };
    }

    function callSubscriberWithDelayedExceptions( subscriber, message, data ){
        try {
            subscriber( message, data );
        } catch( ex ){
            setTimeout( throwException( ex ), 0);
        }
    }

    function callSubscriberWithImmediateExceptions( subscriber, message, data ){
        subscriber( message, data );
    }

    function deliverMessage( originalMessage, matchedMessage, data, immediateExceptions ){
        var subscribers = messages[matchedMessage],
            callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions,
            s;

        if ( !messages.hasOwnProperty( matchedMessage ) ) {
            return;
        }

        for (s in subscribers){
            if ( subscribers.hasOwnProperty(s)){
                callSubscriber( subscribers[s], originalMessage, data );
            }
        }
    }

    function createDeliveryFunction( message, data, immediateExceptions ){
        return function deliverNamespaced(){
            var topic = String( message ),
                position = topic.lastIndexOf( '.' );

            // deliver the message as it is now
            deliverMessage(message, message, data, immediateExceptions);

            // trim the hierarchy and deliver message to each level
            while( position !== -1 ){
                topic = topic.substr( 0, position );
                position = topic.lastIndexOf('.');
                deliverMessage( message, topic, data, immediateExceptions );
            }
        };
    }

    function messageHasSubscribers( message ){
        var topic = String( message ),
            found = Boolean(messages.hasOwnProperty( topic ) && hasKeys(messages[topic])),
            position = topic.lastIndexOf( '.' );

        while ( !found && position !== -1 ){
            topic = topic.substr( 0, position );
            position = topic.lastIndexOf( '.' );
            found = Boolean(messages.hasOwnProperty( topic ) && hasKeys(messages[topic]));
        }

        return found;
    }

    function publish( message, data, sync, immediateExceptions ){
        var deliver = createDeliveryFunction( message, data, immediateExceptions ),
            hasSubscribers = messageHasSubscribers( message );

        if ( !hasSubscribers ){
            return false;
        }

        if ( sync === true ){
            deliver();
        } else {
            setTimeout( deliver, 0 );
        }
        return true;
    }

    /**
	 *	PubSub.publish( message[, data] ) -> Boolean
	 *	- message (String): The message to publish
	 *	- data: The data to pass to subscribers
	 *	Publishes the the message, passing the data to it's subscribers
	**/
    PubSub.publish = function( message, data ){
        return publish( message, data, false, PubSub.immediateExceptions );
    };

    /**
	 *	PubSub.publishSync( message[, data] ) -> Boolean
	 *	- message (String): The message to publish
	 *	- data: The data to pass to subscribers
	 *	Publishes the the message synchronously, passing the data to it's subscribers
	**/
    PubSub.publishSync = function( message, data ){
        return publish( message, data, true, PubSub.immediateExceptions );
    };

    /**
	 *	PubSub.subscribe( message, func ) -> String
	 *	- message (String): The message to subscribe to
	 *	- func (Function): The function to call when a new message is published
	 *	Subscribes the passed function to the passed message. Every returned token is unique and should be stored if
	 *	you need to unsubscribe
	**/
    PubSub.subscribe = function( message, func ){
        if ( typeof func !== 'function'){
            return false;
        }

        // message is not registered yet
        if ( !messages.hasOwnProperty( message ) ){
            messages[message] = {};
        }

        // forcing token as String, to allow for future expansions without breaking usage
        // and allow for easy use as key names for the 'messages' object
        var token = 'uid_' + String(++lastUid);
        messages[message][token] = func;

        // return token for unsubscribing
        return token;
    };

    /**
	 *	PubSub.subscribeOnce( message, func ) -> PubSub
	 *	- message (String): The message to subscribe to
	 *	- func (Function): The function to call when a new message is published
	 *	Subscribes the passed function to the passed message once
	**/
    PubSub.subscribeOnce = function( message, func ){
        var token = PubSub.subscribe( message, function(){
            // before func apply, unsubscribe message
            PubSub.unsubscribe( token );
            func.apply( this, arguments );
        });
        return PubSub;
    };

    /* Public: Clears all subscriptions
	 */
    PubSub.clearAllSubscriptions = function clearAllSubscriptions(){
        messages = {};
    };

    /*Public: Clear subscriptions by the topic
	*/
    PubSub.clearSubscriptions = function clearSubscriptions(topic){
        var m;
        for (m in messages){
            if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0){
                delete messages[m];
            }
        }
    };

    /* Public: removes subscriptions.
	 * When passed a token, removes a specific subscription.
	 * When passed a function, removes all subscriptions for that function
	 * When passed a topic, removes all subscriptions for that topic (hierarchy)
	 *
	 * value - A token, function or topic to unsubscribe.
	 *
	 * Examples
	 *
	 *		// Example 1 - unsubscribing with a token
	 *		var token = PubSub.subscribe('mytopic', myFunc);
	 *		PubSub.unsubscribe(token);
	 *
	 *		// Example 2 - unsubscribing with a function
	 *		PubSub.unsubscribe(myFunc);
	 *
	 *		// Example 3 - unsubscribing a topic
	 *		PubSub.unsubscribe('mytopic');
	 */
    PubSub.unsubscribe = function(value){
        var descendantTopicExists = function(topic) {
                var m;
                for ( m in messages ){
                    if ( messages.hasOwnProperty(m) && m.indexOf(topic) === 0 ){
                        // a descendant of the topic exists:
                        return true;
                    }
                }

                return false;
            },
            isTopic    = typeof value === 'string' && ( messages.hasOwnProperty(value) || descendantTopicExists(value) ),
            isToken    = !isTopic && typeof value === 'string',
            isFunction = typeof value === 'function',
            result = false,
            m, message, t;

        if (isTopic){
            PubSub.clearSubscriptions(value);
            return;
        }

        for ( m in messages ){
            if ( messages.hasOwnProperty( m ) ){
                message = messages[m];

                if ( isToken && message[value] ){
                    delete message[value];
                    result = value;
                    // tokens are unique, so we can just stop here
                    break;
                }

                if (isFunction) {
                    for ( t in message ){
                        if (message.hasOwnProperty(t) && message[t] === value){
                            delete message[t];
                            result = true;
                        }
                    }
                }
            }
        }

        return result;
    };
}));
});

/**
 * @file
 * defines constants for all PubSub message topics used by cmap
 */

var selectedMap = 'selectedMap'; // the selected map (canvas) changed
var reset = 'reset'; // reset button click
var layout = 'layout'; // layout selection changed
var dataLoaded = 'loaded'; // data finished loading, or was filtered/updated

// map removal: this means the bioMap objects sent in the message, were removed
// by user
var mapRemoved = 'mapRemoved';
var mapAdded = 'mapAdded';
var mapReorder = 'mapReorder';

var featureUpdate = 'featureUpdate'; // change to qtlConfig from modal

var topics = Object.freeze({
	selectedMap: selectedMap,
	reset: reset,
	layout: layout,
	dataLoaded: dataLoaded,
	mapRemoved: mapRemoved,
	mapAdded: mapAdded,
	mapReorder: mapReorder,
	featureUpdate: featureUpdate
});

/**
 * @file
 * Development tooling: conditionally run code based on the "development" string,
 * which is interpolated by a plugin in the rollup.config.js.
 *
 */
/**
 * @description Logger to check that pub-sub events propagate.
 */

var monitorPubSub = function monitorPubSub() {
  var logger = function logger(topic, data) {
    // eslint-disable-next-line no-console
    console.log('[' + topic + ']', data);
  };
  Object.keys(topics).forEach(function (t) {
    //console.log(`subscribing to: ${t}`);
    pubsub.subscribe(t, logger);
  });
};

{
  pubsub.immediateExceptions = true;
  monitorPubSub();
}

__$styleInject("/*! normalize.css v6.0.0 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}dfn{font-style:italic}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item}canvas{display:inline-block}[hidden],template{display:none}",undefined);

__$styleInject(".container{position:relative;max-width:960px;margin:0 auto;padding:0 20px}.column,.columns,.container{width:100%;box-sizing:border-box}.column,.columns{float:left}@media (min-width:400px){.container{width:85%;padding:0}}@media (min-width:550px){.container{width:80%}.column,.columns{margin-left:4%}.column:first-child,.columns:first-child{margin-left:0}.one.column,.one.columns{width:4.66666666667%}.two.columns{width:13.3333333333%}.three.columns{width:22%}.four.columns{width:30.6666666667%}.five.columns{width:39.3333333333%}.six.columns{width:48%}.seven.columns{width:56.6666666667%}.eight.columns{width:65.3333333333%}.nine.columns{width:74%}.ten.columns{width:82.6666666667%}.eleven.columns{width:91.3333333333%}.twelve.columns{width:100%;margin-left:0}.one-third.column{width:30.6666666667%}.two-thirds.column{width:65.3333333333%}.one-half.column{width:48%}.offset-by-one.column,.offset-by-one.columns{margin-left:8.66666666667%}.offset-by-two.column,.offset-by-two.columns{margin-left:17.3333333333%}.offset-by-three.column,.offset-by-three.columns{margin-left:26%}.offset-by-four.column,.offset-by-four.columns{margin-left:34.6666666667%}.offset-by-five.column,.offset-by-five.columns{margin-left:43.3333333333%}.offset-by-six.column,.offset-by-six.columns{margin-left:52%}.offset-by-seven.column,.offset-by-seven.columns{margin-left:60.6666666667%}.offset-by-eight.column,.offset-by-eight.columns{margin-left:69.3333333333%}.offset-by-nine.column,.offset-by-nine.columns{margin-left:78%}.offset-by-ten.column,.offset-by-ten.columns{margin-left:86.6666666667%}.offset-by-eleven.column,.offset-by-eleven.columns{margin-left:95.3333333333%}.offset-by-one-third.column,.offset-by-one-third.columns{margin-left:34.6666666667%}.offset-by-two-thirds.column,.offset-by-two-thirds.columns{margin-left:69.3333333333%}.offset-by-one-half.column,.offset-by-one-half.columns{margin-left:52%}}html{font-size:62.5%}body{font-size:1.5em;line-height:1.6;font-weight:400;font-family:Raleway,HelveticaNeue,Helvetica Neue,Helvetica,Arial,sans-serif;color:#222}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:20px;margin-bottom:2rem;font-weight:300}h1{font-size:40px;font-size:4rem;line-height:1.2}h1,h2{letter-spacing:-1px;letter-spacing:-.1rem}h2{font-size:36px;font-size:3.6rem;line-height:1.25}h3{font-size:30px;font-size:3rem;line-height:1.3;letter-spacing:-1px;letter-spacing:-.1rem}h4{font-size:24px;font-size:2.4rem;line-height:1.35;letter-spacing:-.8px;letter-spacing:-.08rem}h5{font-size:18px;font-size:1.8rem;line-height:1.5;letter-spacing:-.5px;letter-spacing:-.05rem}h6{font-size:15px;font-size:1.5rem;line-height:1.6;letter-spacing:0}@media (min-width:550px){h1{font-size:5rem}h2{font-size:4.2rem}h3{font-size:3.6rem}h4{font-size:3rem}h5{font-size:2.4rem}h6{font-size:1.5rem}}p{margin-top:0}a{color:#1eaedb}a:hover{color:#0fa0ce}.button,button,input[type=button],input[type=reset],input[type=submit]{display:inline-block;height:38px;padding:0 30px;color:#555;text-align:center;font-size:11px;font-weight:600;line-height:38px;letter-spacing:1px;letter-spacing:.1rem;text-transform:uppercase;text-decoration:none;white-space:nowrap;background-color:transparent;border-radius:4px;border:1px solid #bbb;cursor:pointer;box-sizing:border-box}.button:focus,.button:hover,button:focus,button:hover,input[type=button]:focus,input[type=button]:hover,input[type=reset]:focus,input[type=reset]:hover,input[type=submit]:focus,input[type=submit]:hover{color:#333;border-color:#888;outline:0}.button.button-primary,button.button-primary,input[type=button].button-primary,input[type=reset].button-primary,input[type=submit].button-primary{color:#fff;background-color:#33c3f0;border-color:#33c3f0}.button.button-primary:focus,.button.button-primary:hover,button.button-primary:focus,button.button-primary:hover,input[type=button].button-primary:focus,input[type=button].button-primary:hover,input[type=reset].button-primary:focus,input[type=reset].button-primary:hover,input[type=submit].button-primary:focus,input[type=submit].button-primary:hover{color:#fff;background-color:#1eaedb;border-color:#1eaedb}input[type=email],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=url],select,textarea{height:38px;padding:6px 10px;background-color:#fff;border:1px solid #d1d1d1;border-radius:4px;box-shadow:none;box-sizing:border-box}input[type=email],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=url],textarea{-webkit-appearance:none;-moz-appearance:none;appearance:none}textarea{min-height:65px;padding-top:6px;padding-bottom:6px}input[type=email]:focus,input[type=number]:focus,input[type=password]:focus,input[type=search]:focus,input[type=tel]:focus,input[type=text]:focus,input[type=url]:focus,select:focus,textarea:focus{border:1px solid #33c3f0;outline:0}label,legend{display:block;margin-bottom:5px;margin-bottom:.5rem;font-weight:600}fieldset{padding:0;border-width:0}input[type=checkbox],input[type=radio]{display:inline}label>.label-body{display:inline-block;margin-left:5px;margin-left:.5rem;font-weight:400}ul{list-style:circle inside}ol{list-style:decimal inside}ol,ul{padding-left:0;margin-top:0}ol ol,ol ul,ul ol,ul ul{margin:15px 0 15px 30px;margin:1.5rem 0 1.5rem 3rem;font-size:90%}li{margin-bottom:10px;margin-bottom:1rem}code{padding:2px 5px;padding:.2rem .5rem;margin:0 2px;margin:0 .2rem;font-size:90%;white-space:nowrap;background:#f1f1f1;border:1px solid #e1e1e1;border-radius:4px}pre>code{display:block;padding:10px 15px;padding:1rem 1.5rem;white-space:pre}td,th{padding:12px 15px;text-align:left;border-bottom:1px solid #e1e1e1}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}.button,button{margin-bottom:10px;margin-bottom:1rem}fieldset,input,select,textarea{margin-bottom:15px;margin-bottom:1.5rem}blockquote,dl,figure,form,ol,p,pre,table,ul{margin-bottom:25px;margin-bottom:2.5rem}.u-full-width{width:100%;box-sizing:border-box}.u-max-full-width{max-width:100%;box-sizing:border-box}.u-pull-right{float:right}.u-pull-left{float:left}hr{margin-top:30px;margin-top:3rem;margin-bottom:35px;margin-bottom:3.5rem;border-width:0;border-top:1px solid #e1e1e1}.container:after,.row:after,.u-cf{content:\"\";display:table;clear:both}",undefined);

__$styleInject("body,html{width:100%;height:100%;margin:0;overflow:hidden;font-family:Nunito,HelveticaNeue,Helvetica Neue,Helvetica,Arial,sans-serif}#cmap-ui{width:calc(100% - 2rem);height:calc(100% - 2rem);margin:0 32px 32px;margin:0 2rem 2rem}#cmap-disclaimer{font-size:20px;color:red;border:2px solid #000;border-radius:8px;padding:10px}.cmap-vbox{-ms-flex-direction:column;flex-direction:column;-ms-flex-line-pack:stretch}.cmap-hbox,.cmap-vbox{display:-ms-flexbox;display:flex;align-content:stretch}.cmap-hbox{-ms-flex-direction:row;flex-direction:row;-ms-flex-line-pack:stretch;-ms-flex-pack:start;justify-content:start}.cmap-layout{width:calc(100% - 2rem);height:calc(100% - 2rem)}.cmap-layout-viewport{overflow-y:hidden;overflow-x:hidden;-ms-flex:auto;flex:auto;position:relative}.cmap-layout-container{position:absolute;width:calc(100% - 2rem);height:calc(100% - 2.5rem)}.cmap-canvas{position:absolute}.cmap-layout-circos,.cmap-layout-horizontal{width:calc(100% - 2rem);height:calc(100% - 2rem);position:relative}.cmap-biomap{border:2px dashed grey}.cmap-biomap.selected{border:2px dashed #f0f}.cmap-tools h5,h4.cmap-header{margin-bottom:0}.cmap-map-addition-dialog,.cmap-map-removal-dialog{padding-left:32px;padding-left:2rem;border-left:4px solid grey}.cmap-map-addition-dialog label{display:inline-block;margin:0 8px;margin:0 .5rem}button>i{vertical-align:-30%}div.cmap-tools button{margin-right:8px;margin-right:.5rem;padding-left:16px;padding-left:1rem;padding-right:16px;padding-right:1rem}button[disabled]{background:#ccc;border-color:#ccc;text-shadow:none}span.cmap-map-name-chip{background:#eee;border-radius:4px;padding:3.2px 16px;padding:.2rem 1rem;margin-right:8px;margin-right:.5rem}.biomap-info{width:15em;height:10em;position:absolute;display:inline-block;overflow-y:auto;z-index:1}.biomap-info,.biomap-info-name{border:1px solid #bbb;border-radius:4px;background:#fff}.biomap-info-name{margin:5px;text-align:center}.biomap-info-name:hover{background:#ccc}.biomap-info-data{margin:5px 20px}.swap-div{opacity:.6;z-index:3}.swap-div,.swap-map-order{border:1px solid #bbb;border-radius:4px}.swap-map-order{margin:5px 10px;padding:5px 10px;background:#fff;text-align:center;opacity:.5}.swap-map-order:hover{background:#ccc}.map-title{margin:5px 10px;padding:5px 10px;text-align:center;background:#fff}.feature-title{z-index:2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.feature-menu,.feature-title{background:#fff;border:1px solid #000;border-radius:4px;padding:5px 0;margin:5px 0;text-align:center}.feature-menu{z-index:3}#cmap-menu-viewport{margin:5px;padding:5px 10px;border:1px solid #bbb;border-radius:4px;background:#fff}", undefined);

/**
 * @description concatAll() aka flattenDeep(), based on http://reactivex.io/learnrx/
 * @return {array} concatenated array.
 */

Array.prototype.concatAll = function () {
  var results = [];
  this.forEach(function (subArray) {
    results.push.apply(results, subArray);
  });
  return results;
};

var mithril = createCommonjsModule(function (module) {
(function() {
"use strict";
function Vnode(tag, key, attrs0, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
	return node
};
Vnode.normalizeChildren = function normalizeChildren(children) {
	for (var i = 0; i < children.length; i++) {
		children[i] = Vnode.normalize(children[i]);
	}
	return children
};
var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
var selectorCache = {};
var hasOwn = {}.hasOwnProperty;
function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}
function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {};
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2];
		if (type === "" && value !== "") tag = value;
		else if (type === "#") attrs.id = value;
		else if (type === ".") classes.push(value);
		else if (match[3][0] === "[") {
			var attrValue = match[6];
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
			if (match[4] === "class") classes.push(attrValue);
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true;
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ");
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}
function execSelector(state, attrs, children) {
	var hasAttrs = false, childList, text;
	var className = attrs.className || attrs.class;
	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {};
		for(var key in attrs) {
			if (hasOwn.call(attrs, key)) {
				newAttrs[key] = attrs[key];
			}
		}
		attrs = newAttrs;
	}
	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key)) {
			attrs[key] = state.attrs[key];
		}
	}
	if (className !== undefined) {
		if (attrs.class !== undefined) {
			attrs.class = undefined;
			attrs.className = className;
		}
		if (state.attrs.className != null) {
			attrs.className = state.attrs.className + " " + className;
		}
	}
	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			hasAttrs = true;
			break
		}
	}
	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		text = children[0].children;
	} else {
		childList = children;
	}
	return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
}
function hyperscript(selector) {
	// Because sloppy mode sucks
	var attrs = arguments[1], start = 2, children;
	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}
	if (typeof selector === "string") {
		var cached = selectorCache[selector] || compileSelector(selector);
	}
	if (attrs == null) {
		attrs = {};
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {};
		start = 1;
	}
	if (arguments.length === start + 1) {
		children = arguments[start];
		if (!Array.isArray(children)) children = [children];
	} else {
		children = [];
		while (start < arguments.length) children.push(arguments[start++]);
	}
	var normalized = Vnode.normalizeChildren(children);
	if (typeof selector === "string") {
		return execSelector(cached, attrs, normalized)
	} else {
		return Vnode(selector, attrs.key, attrs, normalized)
	}
}
hyperscript.trust = function(html) {
	if (html == null) html = "";
	return Vnode("<", undefined, undefined, html, undefined, undefined)
};
hyperscript.fragment = function(attrs1, children) {
	return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)
};
var m = hyperscript;
/** @constructor */
var PromisePolyfill = function(executor) {
	if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")
	if (typeof executor !== "function") throw new TypeError("executor must be a function")
	var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false);
	var instance = self._instance = {resolvers: resolvers, rejectors: rejectors};
	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
	function handler(list, shouldAbsorb) {
		return function execute(value) {
			var then;
			try {
				if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
					if (value === self) throw new TypeError("Promise can't be resolved w/ itself")
					executeOnce(then.bind(value));
				}
				else {
					callAsync(function() {
						if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value);
						for (var i = 0; i < list.length; i++) list[i](value);
						resolvers.length = 0, rejectors.length = 0;
						instance.state = shouldAbsorb;
						instance.retry = function() {execute(value);};
					});
				}
			}
			catch (e) {
				rejectCurrent(e);
			}
		}
	}
	function executeOnce(then) {
		var runs = 0;
		function run(fn) {
			return function(value) {
				if (runs++ > 0) return
				fn(value);
			}
		}
		var onerror = run(rejectCurrent);
		try {then(run(resolveCurrent), onerror);} catch (e) {onerror(e);}
	}
	executeOnce(executor);
};
PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
	var self = this, instance = self._instance;
	function handle(callback, list, next, state) {
		list.push(function(value) {
			if (typeof callback !== "function") next(value);
			else try {resolveNext(callback(value));} catch (e) {if (rejectNext) rejectNext(e);}
		});
		if (typeof instance.retry === "function" && state === instance.state) instance.retry();
	}
	var resolveNext, rejectNext;
	var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject;});
	handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
	return promise
};
PromisePolyfill.prototype.catch = function(onRejection) {
	return this.then(null, onRejection)
};
PromisePolyfill.resolve = function(value) {
	if (value instanceof PromisePolyfill) return value
	return new PromisePolyfill(function(resolve) {resolve(value);})
};
PromisePolyfill.reject = function(value) {
	return new PromisePolyfill(function(resolve, reject) {reject(value);})
};
PromisePolyfill.all = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		var total = list.length, count = 0, values = [];
		if (list.length === 0) resolve([]);
		else for (var i = 0; i < list.length; i++) {
			(function(i) {
				function consume(value) {
					count++;
					values[i] = value;
					if (count === total) resolve(values);
				}
				if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
					list[i].then(consume, reject);
				}
				else consume(list[i]);
			})(i);
		}
	})
};
PromisePolyfill.race = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		for (var i = 0; i < list.length; i++) {
			list[i].then(resolve, reject);
		}
	})
};
if (typeof window !== "undefined") {
	if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill;
	var PromisePolyfill = window.Promise;
} else if (typeof commonjsGlobal !== "undefined") {
	if (typeof commonjsGlobal.Promise === "undefined") commonjsGlobal.Promise = PromisePolyfill;
	var PromisePolyfill = commonjsGlobal.Promise;
} else {
}
var buildQueryString = function(object) {
	if (Object.prototype.toString.call(object) !== "[object Object]") return ""
	var args = [];
	for (var key0 in object) {
		destructure(key0, object[key0]);
	}
	return args.join("&")
	function destructure(key0, value) {
		if (Array.isArray(value)) {
			for (var i = 0; i < value.length; i++) {
				destructure(key0 + "[" + i + "]", value[i]);
			}
		}
		else if (Object.prototype.toString.call(value) === "[object Object]") {
			for (var i in value) {
				destructure(key0 + "[" + i + "]", value[i]);
			}
		}
		else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
	}
};
var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i");
var _8 = function($window, Promise) {
	var callbackCount = 0;
	var oncompletion;
	function setCompletionCallback(callback) {oncompletion = callback;}
	function finalizer() {
		var count = 0;
		function complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion();}
		return function finalize(promise0) {
			var then0 = promise0.then;
			promise0.then = function() {
				count++;
				var next = then0.apply(promise0, arguments);
				next.then(complete, function(e) {
					complete();
					if (count === 0) throw e
				});
				return finalize(next)
			};
			return promise0
		}
	}
	function normalize(args, extra) {
		if (typeof args === "string") {
			var url = args;
			args = extra || {};
			if (args.url == null) args.url = url;
		}
		return args
	}
	function request(args, extra) {
		var finalize = finalizer();
		args = normalize(args, extra);
		var promise0 = new Promise(function(resolve, reject) {
			if (args.method == null) args.method = "GET";
			args.method = args.method.toUpperCase();
			var useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true);
			if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify;
			if (typeof args.deserialize !== "function") args.deserialize = deserialize;
			if (typeof args.extract !== "function") args.extract = extract;
			args.url = interpolate(args.url, args.data);
			if (useBody) args.data = args.serialize(args.data);
			else args.url = assemble(args.url, args.data);
			var xhr = new $window.XMLHttpRequest(),
				aborted = false,
				_abort = xhr.abort;
			xhr.abort = function abort() {
				aborted = true;
				_abort.call(xhr);
			};
			xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);
			if (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty("Content-Type"))) {
				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
			}
			if (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty("Accept"))) {
				xhr.setRequestHeader("Accept", "application/json, text/*");
			}
			if (args.withCredentials) xhr.withCredentials = args.withCredentials;
			for (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {
				xhr.setRequestHeader(key, args.headers[key]);
			}
			if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr;
			xhr.onreadystatechange = function() {
				// Don't throw errors on xhr.abort().
				if(aborted) return
				if (xhr.readyState === 4) {
					try {
						var response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args));
						if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
							resolve(cast(args.type, response));
						}
						else {
							var error = new Error(xhr.responseText);
							for (var key in response) error[key] = response[key];
							reject(error);
						}
					}
					catch (e) {
						reject(e);
					}
				}
			};
			if (useBody && (args.data != null)) xhr.send(args.data);
			else xhr.send();
		});
		return args.background === true ? promise0 : finalize(promise0)
	}
	function jsonp(args, extra) {
		var finalize = finalizer();
		args = normalize(args, extra);
		var promise0 = new Promise(function(resolve, reject) {
			var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
			var script = $window.document.createElement("script");
			$window[callbackName] = function(data) {
				script.parentNode.removeChild(script);
				resolve(cast(args.type, data));
				delete $window[callbackName];
			};
			script.onerror = function() {
				script.parentNode.removeChild(script);
				reject(new Error("JSONP request failed"));
				delete $window[callbackName];
			};
			if (args.data == null) args.data = {};
			args.url = interpolate(args.url, args.data);
			args.data[args.callbackKey || "callback"] = callbackName;
			script.src = assemble(args.url, args.data);
			$window.document.documentElement.appendChild(script);
		});
		return args.background === true? promise0 : finalize(promise0)
	}
	function interpolate(url, data) {
		if (data == null) return url
		var tokens = url.match(/:[^\/]+/gi) || [];
		for (var i = 0; i < tokens.length; i++) {
			var key = tokens[i].slice(1);
			if (data[key] != null) {
				url = url.replace(tokens[i], data[key]);
			}
		}
		return url
	}
	function assemble(url, data) {
		var querystring = buildQueryString(data);
		if (querystring !== "") {
			var prefix = url.indexOf("?") < 0 ? "?" : "&";
			url += prefix + querystring;
		}
		return url
	}
	function deserialize(data) {
		try {return data !== "" ? JSON.parse(data) : null}
		catch (e) {throw new Error(data)}
	}
	function extract(xhr) {return xhr.responseText}
	function cast(type0, data) {
		if (typeof type0 === "function") {
			if (Array.isArray(data)) {
				for (var i = 0; i < data.length; i++) {
					data[i] = new type0(data[i]);
				}
			}
			else return new type0(data)
		}
		return data
	}
	return {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}
};
var requestService = _8(window, PromisePolyfill);
var coreRenderer = function($window) {
	var $doc = $window.document;
	var $emptyFragment = $doc.createDocumentFragment();
	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	};
	var onevent;
	function setEventCallback(callback) {return onevent = callback}
	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}
	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i];
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling);
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag;
		if (typeof tag === "string") {
			vnode.state = {};
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
			switch (tag) {
				case "#": return createText(parent, vnode, nextSibling)
				case "<": return createHTML(parent, vnode, nextSibling)
				case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
				default: return createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else return createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children);
		insertNode(parent, vnode.dom, nextSibling);
		return vnode.dom
	}
	function createHTML(parent, vnode, nextSibling) {
		var match1 = vnode.children.match(/^\s*?<(\w+)/im) || [];
		var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div";
		var temp = $doc.createElement(parent1);
		temp.innerHTML = vnode.children;
		vnode.dom = temp.firstChild;
		vnode.domSize = temp.childNodes.length;
		var fragment = $doc.createDocumentFragment();
		var child;
		while (child = temp.firstChild) {
			fragment.appendChild(child);
		}
		insertNode(parent, fragment, nextSibling);
		return fragment
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment();
		if (vnode.children != null) {
			var children = vnode.children;
			createNodes(fragment, children, 0, children.length, hooks, null, ns);
		}
		vnode.dom = fragment.firstChild;
		vnode.domSize = fragment.childNodes.length;
		insertNode(parent, fragment, nextSibling);
		return fragment
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag;
		var attrs2 = vnode.attrs;
		var is = attrs2 && attrs2.is;
		ns = getNameSpace(vnode) || ns;
		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag);
		vnode.dom = element;
		if (attrs2 != null) {
			setAttrs(vnode, attrs2, ns);
		}
		insertNode(parent, element, nextSibling);
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode);
		}
		else {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text;
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
			}
			if (vnode.children != null) {
				var children = vnode.children;
				createNodes(element, children, 0, children.length, hooks, null, ns);
				setLateAttrs(vnode);
			}
		}
		return element
	}
	function initComponent(vnode, hooks) {
		var sentinel;
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag);
			sentinel = vnode.state.view;
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true;
		} else {
			vnode.state = void 0;
			sentinel = vnode.tag;
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true;
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode);
		}
		vnode._state = vnode.state;
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
		initLifecycle(vnode._state, vnode, hooks);
		vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null;
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks);
		if (vnode.instance != null) {
			var element = createNode(parent, vnode.instance, hooks, ns, nextSibling);
			vnode.dom = vnode.instance.dom;
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
			insertNode(parent, element, nextSibling);
			return element
		}
		else {
			vnode.domSize = 0;
			return $emptyFragment
		}
	}
	//update
	function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns);
		else if (vnodes == null) removeNodes(old, 0, old.length, vnodes);
		else {
			if (old.length === vnodes.length) {
				var isUnkeyed = false;
				for (var i = 0; i < vnodes.length; i++) {
					if (vnodes[i] != null && old[i] != null) {
						isUnkeyed = vnodes[i].key == null && old[i].key == null;
						break
					}
				}
				if (isUnkeyed) {
					for (var i = 0; i < old.length; i++) {
						if (old[i] === vnodes[i]) continue
						else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling));
						else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes);
						else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns);
					}
					return
				}
			}
			recycling = recycling || isRecyclable(old, vnodes);
			if (recycling) {
				var pool = old.pool;
				old = old.concat(old.pool);
			}
			var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map;
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldStart], v = vnodes[start];
				if (o === v && !recycling) oldStart++, start++;
				else if (o == null) oldStart++;
				else if (v == null) start++;
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling);
					oldStart++, start++;
					updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns);
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
				}
				else {
					var o = old[oldEnd];
					if (o === v && !recycling) oldEnd--, start++;
					else if (o == null) oldEnd--;
					else if (v == null) start++;
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling);
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
						if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling));
						oldEnd--, start++;
					}
					else break
				}
			}
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldEnd], v = vnodes[end];
				if (o === v && !recycling) oldEnd--, end--;
				else if (o == null) oldEnd--;
				else if (v == null) end--;
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling);
					updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling);
					if (o.dom != null) nextSibling = o.dom;
					oldEnd--, end--;
				}
				else {
					if (!map) map = getKeyMap(old, oldEnd);
					if (v != null) {
						var oldIndex = map[v.key];
						if (oldIndex != null) {
							var movable = old[oldIndex];
							var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling);
							updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns);
							insertNode(parent, toFragment(movable), nextSibling);
							old[oldIndex].skip = true;
							if (movable.dom != null) nextSibling = movable.dom;
						}
						else {
							var dom = createNode(parent, v, hooks, ns, nextSibling);
							nextSibling = dom;
						}
					}
					end--;
				}
				if (end < start) break
			}
			createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
			removeNodes(old, oldStart, oldEnd + 1, vnodes);
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		var oldTag = old.tag, tag = vnode.tag;
		if (oldTag === tag) {
			vnode.state = old.state;
			vnode._state = old._state;
			vnode.events = old.events;
			if (!recycling && shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					if (recycling) {
						vnode.state = {};
						initLifecycle(vnode.attrs, vnode, hooks);
					}
					else updateLifecycle(vnode.attrs, vnode, hooks);
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, nextSibling); break
					case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, recycling, hooks, ns);
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns);
		}
		else {
			removeNode(old, null);
			createNode(parent, vnode, hooks, ns, nextSibling);
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children;
		}
		vnode.dom = old.dom;
	}
	function updateHTML(parent, old, vnode, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old);
			createHTML(parent, vnode, nextSibling);
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize;
	}
	function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns);
		var domSize = 0, children = vnode.children;
		vnode.dom = null;
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i];
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom;
					domSize += child.domSize || 1;
				}
			}
			if (domSize !== 1) vnode.domSize = domSize;
		}
	}
	function updateElement(old, vnode, recycling, hooks, ns) {
		var element = vnode.dom = old.dom;
		ns = getNameSpace(vnode) || ns;
		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {};
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text; //FIXME handle0 multiple children
				vnode.text = undefined;
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns);
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode);
		}
		else if (old.text != null && vnode.text != null && vnode.text !== "") {
			if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text;
		}
		else {
			if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)];
			if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)];
			updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns);
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		if (recycling) {
			initComponent(vnode, hooks);
		} else {
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode));
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);
			updateLifecycle(vnode._state, vnode, hooks);
		}
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns);
			vnode.dom = vnode.instance.dom;
			vnode.domSize = vnode.instance.domSize;
		}
		else if (old.instance != null) {
			removeNode(old.instance, null);
			vnode.dom = undefined;
			vnode.domSize = 0;
		}
		else {
			vnode.dom = old.dom;
			vnode.domSize = old.domSize;
		}
	}
	function isRecyclable(old, vnodes) {
		if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
			var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0;
			var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0;
			var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0;
			if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
				return true
			}
		}
		return false
	}
	function getKeyMap(vnodes, end) {
		var map = {}, i = 0;
		for (var i = 0; i < end; i++) {
			var vnode = vnodes[i];
			if (vnode != null) {
				var key2 = vnode.key;
				if (key2 != null) map[key2] = i;
			}
		}
		return map
	}
	function toFragment(vnode) {
		var count0 = vnode.domSize;
		if (count0 != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment();
			if (count0 > 0) {
				var dom = vnode.dom;
				while (--count0) fragment.appendChild(dom.nextSibling);
				fragment.insertBefore(dom, fragment.firstChild);
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}
	function insertNode(parent, dom, nextSibling) {
		if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling);
		else parent.appendChild(dom);
	}
	function setContentEditable(vnode) {
		var children = vnode.children;
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children;
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}
	//remove
	function removeNodes(vnodes, start, end, context) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i];
			if (vnode != null) {
				if (vnode.skip) vnode.skip = false;
				else removeNode(vnode, context);
			}
		}
	}
	function removeNode(vnode, context) {
		var expected = 1, called = 0;
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode);
			if (result != null && typeof result.then === "function") {
				expected++;
				result.then(continuation, continuation);
			}
		}
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
			var result = vnode._state.onbeforeremove.call(vnode.state, vnode);
			if (result != null && typeof result.then === "function") {
				expected++;
				result.then(continuation, continuation);
			}
		}
		continuation();
		function continuation() {
			if (++called === expected) {
				onremove(vnode);
				if (vnode.dom) {
					var count0 = vnode.domSize || 1;
					if (count0 > 1) {
						var dom = vnode.dom;
						while (--count0) {
							removeNodeFromDOM(dom.nextSibling);
						}
					}
					removeNodeFromDOM(vnode.dom);
					if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
						if (!context.pool) context.pool = [vnode];
						else context.pool.push(vnode);
					}
				}
			}
		}
	}
	function removeNodeFromDOM(node) {
		var parent = node.parentNode;
		if (parent != null) parent.removeChild(node);
	}
	function onremove(vnode) {
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode);
		if (typeof vnode.tag !== "string") {
			if (typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode);
			if (vnode.instance != null) onremove(vnode.instance);
		} else {
			var children = vnode.children;
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i];
					if (child != null) onremove(child);
				}
			}
		}
	}
	//attrs2
	function setAttrs(vnode, attrs2, ns) {
		for (var key2 in attrs2) {
			setAttr(vnode, key2, null, attrs2[key2], ns);
		}
	}
	function setAttr(vnode, key2, old, value, ns) {
		var element = vnode.dom;
		if (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return
		var nsLastIndex = key2.indexOf(":");
		if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
			element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value);
		}
		else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value);
		else if (key2 === "style") updateStyle(element, old, value);
		else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
			if (key2 === "value") {
				var normalized0 = "" + value; // eslint-disable-line no-implicit-coercion
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select") {
					if (value === null) {
						if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
					} else {
						if (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
					}
				}
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return
			}
			// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
			if (vnode.tag === "input" && key2 === "type") {
				element.setAttribute(key2, value);
				return
			}
			element[key2] = value;
		}
		else {
			if (typeof value === "boolean") {
				if (value) element.setAttribute(key2, "");
				else element.removeAttribute(key2);
			}
			else element.setAttribute(key2 === "className" ? "class" : key2, value);
		}
	}
	function setLateAttrs(vnode) {
		var attrs2 = vnode.attrs;
		if (vnode.tag === "select" && attrs2 != null) {
			if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined);
			if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined);
		}
	}
	function updateAttrs(vnode, old, attrs2, ns) {
		if (attrs2 != null) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, old && old[key2], attrs2[key2], ns);
			}
		}
		if (old != null) {
			for (var key2 in old) {
				if (attrs2 == null || !(key2 in attrs2)) {
					if (key2 === "className") key2 = "class";
					if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined);
					else if (key2 !== "key") vnode.dom.removeAttribute(key2);
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function isAttribute(attr) {
		return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
	}
	function isCustomElement(vnode){
		return vnode.attrs.is || vnode.tag.indexOf("-") > -1
	}
	function hasIntegrationMethods(source) {
		return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
	}
	//style
	function updateStyle(element, old, style) {
		if (old === style) element.style.cssText = "", old = null;
		if (style == null) element.style.cssText = "";
		else if (typeof style === "string") element.style.cssText = style;
		else {
			if (typeof old === "string") element.style.cssText = "";
			for (var key2 in style) {
				element.style[key2] = style[key2];
			}
			if (old != null && typeof old !== "string") {
				for (var key2 in old) {
					if (!(key2 in style)) element.style[key2] = "";
				}
			}
		}
	}
	//event
	function updateEvent(vnode, key2, value) {
		var element = vnode.dom;
		var callback = typeof onevent !== "function" ? value : function(e) {
			var result = value.call(element, e);
			onevent.call(element, e);
			return result
		};
		if (key2 in element) element[key2] = typeof value === "function" ? callback : null;
		else {
			var eventName = key2.slice(2);
			if (vnode.events === undefined) vnode.events = {};
			if (vnode.events[key2] === callback) return
			if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false);
			if (typeof value === "function") {
				vnode.events[key2] = callback;
				element.addEventListener(eventName, vnode.events[key2], false);
			}
		}
	}
	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode);
		if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode));
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode));
	}
	function shouldNotUpdate(vnode, old) {
		var forceVnodeUpdate, forceComponentUpdate;
		if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old);
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old);
		if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
			vnode.dom = old.dom;
			vnode.domSize = old.domSize;
			vnode.instance = old.instance;
			return true
		}
		return false
	}
	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = [];
		var active = $doc.activeElement;
		var namespace = dom.namespaceURI;
		// First time0 rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = "";
		if (!Array.isArray(vnodes)) vnodes = [vnodes];
		updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace);
		dom.vnodes = vnodes;
		// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
		if (active != null && $doc.activeElement !== active) active.focus();
		for (var i = 0; i < hooks.length; i++) hooks[i]();
	}
	return {render: render, setEventCallback: setEventCallback}
};
function throttle(callback) {
	//60fps translates to 16.6ms, round it down since setTimeout requires int
	var time = 16;
	var last = 0, pending = null;
	var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout;
	return function() {
		var now = Date.now();
		if (last === 0 || now - last >= time) {
			last = now;
			callback();
		}
		else if (pending === null) {
			pending = timeout(function() {
				pending = null;
				callback();
				last = Date.now();
			}, time - (now - last));
		}
	}
}
var _11 = function($window) {
	var renderService = coreRenderer($window);
	renderService.setEventCallback(function(e) {
		if (e.redraw === false) e.redraw = undefined;
		else redraw();
	});
	var callbacks = [];
	function subscribe(key1, callback) {
		unsubscribe(key1);
		callbacks.push(key1, throttle(callback));
	}
	function unsubscribe(key1) {
		var index = callbacks.indexOf(key1);
		if (index > -1) callbacks.splice(index, 2);
	}
	function redraw() {
		for (var i = 1; i < callbacks.length; i += 2) {
			callbacks[i]();
		}
	}
	return {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}
};
var redrawService = _11(window);
requestService.setCompletionCallback(redrawService.redraw);
var _16 = function(redrawService0) {
	return function(root, component) {
		if (component === null) {
			redrawService0.render(root, []);
			redrawService0.unsubscribe(root);
			return
		}
		
		if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")
		
		var run0 = function() {
			redrawService0.render(root, Vnode(component));
		};
		redrawService0.subscribe(root, run0);
		redrawService0.redraw();
	}
};
m.mount = _16(redrawService);
var Promise = PromisePolyfill;
var parseQueryString = function(string) {
	if (string === "" || string == null) return {}
	if (string.charAt(0) === "?") string = string.slice(1);
	var entries = string.split("&"), data0 = {}, counters = {};
	for (var i = 0; i < entries.length; i++) {
		var entry = entries[i].split("=");
		var key5 = decodeURIComponent(entry[0]);
		var value = entry.length === 2 ? decodeURIComponent(entry[1]) : "";
		if (value === "true") value = true;
		else if (value === "false") value = false;
		var levels = key5.split(/\]\[?|\[/);
		var cursor = data0;
		if (key5.indexOf("[") > -1) levels.pop();
		for (var j = 0; j < levels.length; j++) {
			var level = levels[j], nextLevel = levels[j + 1];
			var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
			var isValue = j === levels.length - 1;
			if (level === "") {
				var key5 = levels.slice(0, j).join();
				if (counters[key5] == null) counters[key5] = 0;
				level = counters[key5]++;
			}
			if (cursor[level] == null) {
				cursor[level] = isValue ? value : isNumber ? [] : {};
			}
			cursor = cursor[level];
		}
	}
	return data0
};
var coreRouter = function($window) {
	var supportsPushState = typeof $window.history.pushState === "function";
	var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout;
	function normalize1(fragment0) {
		var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent);
		if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data;
		return data
	}
	var asyncId;
	function debounceAsync(callback0) {
		return function() {
			if (asyncId != null) return
			asyncId = callAsync0(function() {
				asyncId = null;
				callback0();
			});
		}
	}
	function parsePath(path, queryData, hashData) {
		var queryIndex = path.indexOf("?");
		var hashIndex = path.indexOf("#");
		var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length;
		if (queryIndex > -1) {
			var queryEnd = hashIndex > -1 ? hashIndex : path.length;
			var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd));
			for (var key4 in queryParams) queryData[key4] = queryParams[key4];
		}
		if (hashIndex > -1) {
			var hashParams = parseQueryString(path.slice(hashIndex + 1));
			for (var key4 in hashParams) hashData[key4] = hashParams[key4];
		}
		return path.slice(0, pathEnd)
	}
	var router = {prefix: "#!"};
	router.getPath = function() {
		var type2 = router.prefix.charAt(0);
		switch (type2) {
			case "#": return normalize1("hash").slice(router.prefix.length)
			case "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")
			default: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")
		}
	};
	router.setPath = function(path, data, options) {
		var queryData = {}, hashData = {};
		path = parsePath(path, queryData, hashData);
		if (data != null) {
			for (var key4 in data) queryData[key4] = data[key4];
			path = path.replace(/:([^\/]+)/g, function(match2, token) {
				delete queryData[token];
				return data[token]
			});
		}
		var query = buildQueryString(queryData);
		if (query) path += "?" + query;
		var hash = buildQueryString(hashData);
		if (hash) path += "#" + hash;
		if (supportsPushState) {
			var state = options ? options.state : null;
			var title = options ? options.title : null;
			$window.onpopstate();
			if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path);
			else $window.history.pushState(state, title, router.prefix + path);
		}
		else $window.location.href = router.prefix + path;
	};
	router.defineRoutes = function(routes, resolve, reject) {
		function resolveRoute() {
			var path = router.getPath();
			var params = {};
			var pathname = parsePath(path, params, params);
			var state = $window.history.state;
			if (state != null) {
				for (var k in state) params[k] = state[k];
			}
			for (var route0 in routes) {
				var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");
				if (matcher.test(pathname)) {
					pathname.replace(matcher, function() {
						var keys = route0.match(/:[^\/]+/g) || [];
						var values = [].slice.call(arguments, 1, -2);
						for (var i = 0; i < keys.length; i++) {
							params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i]);
						}
						resolve(routes[route0], params, path, route0);
					});
					return
				}
			}
			reject(path, params);
		}
		if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute);
		else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute;
		resolveRoute();
	};
	return router
};
var _20 = function($window, redrawService0) {
	var routeService = coreRouter($window);
	var identity = function(v) {return v};
	var render1, component, attrs3, currentPath, lastUpdate;
	var route = function(root, defaultRoute, routes) {
		if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")
		var run1 = function() {
			if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)));
		};
		var bail = function(path) {
			if (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true});
			else throw new Error("Could not resolve default route " + defaultRoute)
		};
		routeService.defineRoutes(routes, function(payload, params, path) {
			var update = lastUpdate = function(routeResolver, comp) {
				if (update !== lastUpdate) return
				component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div";
				attrs3 = params, currentPath = path, lastUpdate = null;
				render1 = (routeResolver.render || identity).bind(routeResolver);
				run1();
			};
			if (payload.view || typeof payload === "function") update({}, payload);
			else {
				if (payload.onmatch) {
					Promise.resolve(payload.onmatch(params, path)).then(function(resolved) {
						update(payload, resolved);
					}, bail);
				}
				else update(payload, "div");
			}
		}, bail);
		redrawService0.subscribe(root, run1);
	};
	route.set = function(path, data, options) {
		if (lastUpdate != null) {
			options = options || {};
			options.replace = true;
		}
		lastUpdate = null;
		routeService.setPath(path, data, options);
	};
	route.get = function() {return currentPath};
	route.prefix = function(prefix0) {routeService.prefix = prefix0;};
	route.link = function(vnode1) {
		vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href);
		vnode1.dom.onclick = function(e) {
			if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return
			e.preventDefault();
			e.redraw = false;
			var href = this.getAttribute("href");
			if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length);
			route.set(href, undefined, undefined);
		};
	};
	route.param = function(key3) {
		if(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]
		return attrs3
	};
	return route
};
m.route = _20(window, redrawService);
m.withAttr = function(attrName, callback1, context) {
	return function(e) {
		callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName));
	}
};
var _28 = coreRenderer(window);
m.render = _28.render;
m.redraw = redrawService.redraw;
m.request = requestService.request;
m.jsonp = requestService.jsonp;
m.parseQueryString = parseQueryString;
m.buildQueryString = buildQueryString;
m.version = "1.1.6";
m.vnode = Vnode;
module["exports"] = m;
}());
});

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * A function that returns a subclass of its argument.
 *
 * @example
 * const M = (superclass) => class extends superclass {
 *   getMessage() {
 *     return "Hello";
 *   }
 * }
 *
 * @typedef {Function} MixinFunction
 * @param {Function} superclass
 * @return {Function} A subclass of `superclass`
 */

/**
 * Applies `mixin` to `superclass`.
 *
 * `apply` stores a reference from the mixin application to the unwrapped mixin
 * to make `isApplicationOf` and `hasMixin` work.
 *
 * This function is usefull for mixin wrappers that want to automatically enable
 * {@link hasMixin} support.
 *
 * @example
 * const Applier = (mixin) => wrap(mixin, (superclass) => apply(superclass, mixin));
 *
 * // M now works with `hasMixin` and `isApplicationOf`
 * const M = Applier((superclass) => class extends superclass {});
 *
 * class C extends M(Object) {}
 * let i = new C();
 * hasMixin(i, M); // true
 *
 * @function
 * @param {Function} superclass A class or constructor function
 * @param {MixinFunction} mixin The mixin to apply
 * @return {Function} A subclass of `superclass` produced by `mixin`
 */


/**
 * Returns `true` iff `proto` is a prototype created by the application of
 * `mixin` to a superclass.
 *
 * `isApplicationOf` works by checking that `proto` has a reference to `mixin`
 * as created by `apply`.
 *
 * @function
 * @param {Object} proto A prototype object created by {@link apply}.
 * @param {MixinFunction} mixin A mixin function used with {@link apply}.
 * @return {boolean} whether `proto` is a prototype created by the application of
 * `mixin` to a superclass
 */


/**
 * Returns `true` iff `o` has an application of `mixin` on its prototype
 * chain.
 *
 * @function
 * @param {Object} o An object
 * @param {MixinFunction} mixin A mixin applied with {@link apply}
 * @return {boolean} whether `o` has an application of `mixin` on its prototype
 * chain
 */


/**
 * Sets up the function `mixin` to be wrapped by the function `wrapper`, while
 * allowing properties on `mixin` to be available via `wrapper`, and allowing
 * `wrapper` to be unwrapped to get to the original function.
 *
 * `wrap` does two things:
 *   1. Sets the prototype of `mixin` to `wrapper` so that properties set on
 *      `mixin` inherited by `wrapper`.
 *   2. Sets a special property on `mixin` that points back to `mixin` so that
 *      it can be retreived from `wrapper`
 *
 * @function
 * @param {MixinFunction} mixin A mixin function
 * @param {MixinFunction} wrapper A function that wraps {@link mixin}
 * @return {MixinFunction} `wrapper`
 */


/**
 * Unwraps the function `wrapper` to return the original function wrapped by
 * one or more calls to `wrap`. Returns `wrapper` if it's not a wrapped
 * function.
 *
 * @function
 * @param {MixinFunction} wrapper A wrapped mixin produced by {@link wrap}
 * @return {MixinFunction} The originally wrapped mixin
 */


/**
 * Decorates `mixin` so that it caches its applications. When applied multiple
 * times to the same superclass, `mixin` will only create one subclass, memoize
 * it and return it for each application.
 *
 * Note: If `mixin` somehow stores properties its classes constructor (static
 * properties), or on its classes prototype, it will be shared across all
 * applications of `mixin` to a super class. It's reccomended that `mixin` only
 * access instance state.
 *
 * @function
 * @param {MixinFunction} mixin The mixin to wrap with caching behavior
 * @return {MixinFunction} a new mixin function
 */


/**
 * Decorates `mixin` so that it only applies if it's not already on the
 * prototype chain.
 *
 * @function
 * @param {MixinFunction} mixin The mixin to wrap with deduplication behavior
 * @return {MixinFunction} a new mixin function
 */


/**
 * Adds [Symbol.hasInstance] (ES2015 custom instanceof support) to `mixin`.
 *
 * @function
 * @param {MixinFunction} mixin The mixin to add [Symbol.hasInstance] to
 * @return {MixinFunction} the given mixin function
 */


/**
 * A basic mixin decorator that applies the mixin with {@link apply} so that it
 * can be used with {@link isApplicationOf}, {@link hasMixin} and the other
 * mixin decorator functions.
 *
 * @function
 * @param {MixinFunction} mixin The mixin to wrap
 * @return {MixinFunction} a new mixin function
 */


/**
 * Decorates a mixin function to add deduplication, application caching and
 * instanceof support.
 *
 * @function
 * @param {MixinFunction} mixin The mixin to wrap
 * @return {MixinFunction} a new mixin function
 */


/**
 * A fluent interface to apply a list of mixins to a superclass.
 *
 * ```javascript
 * class X extends mix(Object).with(A, B, C) {}
 * ```
 *
 * The mixins are applied in order to the superclass, so the prototype chain
 * will be: X->C'->B'->A'->Object.
 *
 * This is purely a convenience function. The above example is equivalent to:
 *
 * ```javascript
 * class X extends C(B(A(Object))) {}
 * ```
 *
 * @function
 * @param {Function} [superclass=Object]
 * @return {MixinBuilder}
 */
var mix = function mix(superclass) {
  return new MixinBuilder(superclass);
};

var MixinBuilder = function () {
  function MixinBuilder(superclass) {
    classCallCheck(this, MixinBuilder);

    this.superclass = superclass || function () {
      function _class() {
        classCallCheck(this, _class);
      }

      return _class;
    }();
  }

  /**
   * Applies `mixins` in order to the superclass given to `mix()`.
   *
   * @param {Array.<Mixin>} mixins
   * @return {Function} a subclass of `superclass` with `mixins` applied
   */


  createClass(MixinBuilder, [{
    key: 'with',
    value: function _with() {
      for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
        mixins[_key] = arguments[_key];
      }

      return mixins.reduce(function (c, m) {
        return m(c);
      }, this.superclass);
    }
  }]);
  return MixinBuilder;
}();

/**
 * @description Helper function for detecting null or undefined.
 */

var isNil = function isNil(o) {
  return o === null || o === undefined;
};

/**
 * @description
 * Bounds
 * Class representing a 2D bounds, having the same properties as a DOMRect.
 * This class can be instantiated by script, unlike DOMRect object itself which
 * comes from the browser's DOM by getBoundingClientRect().
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
 */
var Bounds = function () {
  /**
   * Create a Bounds
   *
   * @param {Object} params - having the following properties:
   * @param {Number} bottom
   * @param {Number} left
   * @param {Number} right
   * @param {Number} top
   * @param {Number} width
   * @param {Number} height
   * @returns {Object}
   */
  function Bounds(_ref) {
    var top = _ref.top,
        left = _ref.left,
        bottom = _ref.bottom,
        right = _ref.right,
        width = _ref.width,
        height = _ref.height,
        _ref$allowSubpixel = _ref.allowSubpixel,
        allowSubpixel = _ref$allowSubpixel === undefined ? true : _ref$allowSubpixel;
    classCallCheck(this, Bounds);

    this._bottom = bottom;
    this._left = left;
    this._right = right;
    this._top = top;
    this._height = height;
    this._width = width;
    this.allowSubpixel = allowSubpixel;

    if (isNil(this.width)) this._width = this.right - this.left;
    if (isNil(this.height)) this._height = this.bottom - this.top;
    if (isNil(this.bottom)) this._bottom = this.top + this.height;
    if (isNil(this.right)) this._right = this.left + this.width;

    if (!allowSubpixel) {
      // noinspection JSSuspiciousNameCombination
      this._bottom = Math.floor(this.bottom);
      // noinspection JSSuspiciousNameCombination
      this._top = Math.floor(this.top);
      this._left = Math.floor(this.left);
      this._right = Math.floor(this.right);
      this._width = Math.floor(this.width);
      // noinspection JSSuspiciousNameCombination
      this._height = Math.floor(this.height);
      if (this.x) this.x = Math.floor(this.x);
      if (this.y) {
        // noinspection JSSuspiciousNameCombination
        this.y = Math.floor(this.y);
      }
    }
  }

  /**
   * Getters and setters, should be allowed to update bounds without having to
   * resort to making a new bounds object.
   */

  createClass(Bounds, [{
    key: 'equals',


    /**
     * Instance method call of Bounds.equals()
     */
    value: function equals(otherBounds) {
      return Bounds.equals(this, otherBounds);
    }

    /**
     * Area equality, rounds to integer pixel.
     */

  }, {
    key: 'areaEquals',
    value: function areaEquals(otherBounds) {
      return Bounds.areaEquals(this, otherBounds);
    }
  }, {
    key: 'bottom',
    get: function get$$1() {
      return this._bottom;
    },
    set: function set$$1(val) {
      if (this.allowSubpixel) {
        this._bottom = val;
        this._height = this._bottom - this._top;
      } else {
        this._bottom = Math.floor(val);
        this._height = Math.floor(this._bottom - this._top);
      }
    }
  }, {
    key: 'top',
    get: function get$$1() {
      return this._top;
    },
    set: function set$$1(val) {
      if (this.allowSubpixel) {
        this._top = val;
        this._height = this._bottom - this._top;
      } else {
        this._top = Math.floor(val);
        this._height = Math.floor(this._bottom - this._top);
      }
    }
  }, {
    key: 'left',
    get: function get$$1() {
      return this._left;
    },
    set: function set$$1(val) {
      if (this.allowSubpixel) {
        this._left = val;
        this._width = this._right - this._left;
      } else {
        this._left = Math.floor(val);
        this._width = Math.floor(this._right - this._left);
      }
    }
  }, {
    key: 'right',
    get: function get$$1() {
      return this._right;
    },
    set: function set$$1(val) {
      if (this.allowSubpixel) {
        this._right = val;
        this._width = this._right - this._left;
      } else {
        this._right = Math.floor(val);
        this._width = Math.floor(this._right - this._left);
      }
    }
  }, {
    key: 'width',
    get: function get$$1() {
      return this._width;
    },
    set: function set$$1(val) {
      if (this.allowSubpixel) {
        this._width = val;
        this._right = this._left + this._width;
      } else {
        this._right = Math.floor(val);
        this._width = Math.floor(this._left + this._width);
      }
    }
  }, {
    key: 'height',
    get: function get$$1() {
      return this._height;
    },
    set: function set$$1(val) {
      if (this.allowSubpixel) {
        this._height = val;
        this._bottom = this._top + this._height;
      } else {
        this._height = Math.floor(val);
        this._bottom = Math.floor(this._top + this._height);
      }
    }

    /**
     * Check if width or height is zero, making the Bounds effectively empty.
     */

  }, {
    key: 'isEmptyArea',
    get: function get$$1() {
      return !this.width || !this.height;
    }

    /**
     * Area of bounds (width * height)
     */

  }, {
    key: 'area',
    get: function get$$1() {
      return this.width * this.height;
    }

    /**
     * Class method- test whether two bounds are equal (rounds to nearest pixel)
     *
     * @param bounds1 - DOMRect or Bounds instance
     * @param bounds2 - DOMRect or Bounds instance
     * @returns Boolean
     */

  }], [{
    key: 'equals',
    value: function equals(bounds1, bounds2) {
      var p = void 0,
          n1 = void 0,
          n2 = void 0;
      if (!bounds1 || !bounds2) return false; // check for null args
      for (var i = 0; i < PROPS.length; i++) {
        p = PROPS[i];
        n1 = bounds1[p];
        n2 = bounds2[p];
        if (n1 === undefined || n2 === undefined) {
          // skip test, see note about x,y
          continue;
        }
        // cast properties from float to int before equality comparison
        if (Math.floor(n1) !== Math.floor(n2)) return false;
      }
      return true;
    }

    /**
     * Class method- test whether two bounds are equal in area (rounds to nearest pixel)
     *
     * @param bounds1 - DOMRect or Bounds instance
     * @param bounds2 - DOMRect or Bounds instance
     * @returns Boolean
     */

  }, {
    key: 'areaEquals',
    value: function areaEquals(bounds1, bounds2) {
      if (!bounds1 || !bounds2) return false; // check for null args
      return Math.floor(bounds1.area) === Math.floor(bounds2.area);
    }
  }]);
  return Bounds;
}();

// DOMRect may *not* have iterable properties, so hardcode them here
var PROPS = [
// note: x any y may not exist!
'bottom', 'left', 'right', 'top', 'width', 'height', 'x', 'y'];

/**
 * LayoutBase
 * A Mithril component Base class for Layouts, e.g. HorizontalLayout and
 * CircosLayout.
 */
var LayoutBase = function () {
  function LayoutBase() {
    classCallCheck(this, LayoutBase);
  }

  createClass(LayoutBase, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril lifecycle callback
     * @param vnode
     */

    value: function oninit(vnode) {
      this.appState = vnode.attrs.appState;
    }

    /**
     * mithril lifecycle method
     * @param vnode
     */

  }, {
    key: 'oncreate',
    value: function oncreate(vnode) {
      // save a reference to this component's dom element
      this.el = vnode.dom;
      this.bounds = new Bounds(vnode.dom.getBoundingClientRect());
    }

    /**
     * mithril lifecycle method
     * @param vnode
     */

  }, {
    key: 'onupdate',
    value: function onupdate(vnode) {
      this.bounds = new Bounds(vnode.dom.getBoundingClientRect());
    }
  }]);
  return LayoutBase;
}();

/**
 * @file Helper functions for calculating canvas points.
 */

/**
 * Takes a point on a map and translates it from the newScale to the baseScale scale
 * @param point - Map point in terms of new scale
 * @param baseScale - largest and smallest possible values of the scale
 * @param newScale - largest and smallest values of the adjusted scale
 * @param {boolean} invert - is the scale to be drawn "flipped"
 * @returns {number} point converted from location on new scale to location on base scale
 */

function translateScale(point, baseScale, newScale, invert) {
  var loc = (baseScale.stop - baseScale.start) * (point - newScale.start) / (newScale.stop - newScale.start) + baseScale.start - baseScale.start;
  if (invert) {
    loc = baseScale.start + baseScale.stop - loc;
  }
  return loc;
}

/**
 * Takes an event and translates the event coordinates to canvas coordinates
 * here because webkit events vs mozilla events vs ie events don't all provide
 * the same data
 *
 * @param evt - dom event
 * @param canvas - target canvas
 * @returns {{x: number, y: number}} location translated from page event coordinates to canvas coordinates.
 */

function pageToCanvas(evt, canvas) {
  function getOffset(el) {
    var _x = 0;
    var _y = 0;
    while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
      _x += el.offsetLeft - el.scrollLeft;
      _y += el.offsetTop - el.scrollTop;
      el = el.offsetParent;
    }
    return { top: _y, left: _x };
  }

  var pageOffset = getOffset(canvas);
  return {
    'x': evt.srcEvent.pageX - pageOffset.left,
    'y': evt.srcEvent.pageY - pageOffset.top
  };
}

var hammer = createCommonjsModule(function (module) {
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof undefined === 'function' && undefined.amd) {
    undefined(function() {
        return Hammer;
    });
} else if ('object' != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');
});

/**
 * lazily draw on the canvas, because mithril updates the dom asynchronously.
 * The canvas will be cleared when mithril writes the new width and height
 * of canvas element into dom. So we cannot draw upon canvas until after that.
 */
var DrawLazilyMixin = function DrawLazilyMixin(superclass) {
  return function (_superclass) {
    inherits(_class, _superclass);

    function _class() {
      classCallCheck(this, _class);
      return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    createClass(_class, [{
      key: 'drawLazily',


      /**
       *
       * @param wantedBounds
       */

      value: function drawLazily(wantedBounds) {
        var _this2 = this;

        if (wantedBounds.area === 0) return;
        if (this._drawLazilyTimeoutId) clearTimeout(this._drawLazilyTimeoutId);
        if (!Bounds.areaEquals(this.lastDrawnMithrilBounds, wantedBounds)) {
          console.log('waiting for wantedBounds from mithril: ', wantedBounds.width, wantedBounds.height);
          var tid1 = this._drawLazilyTimeoutId = setTimeout(function () {
            if (tid1 !== _this2._drawLazilyTimeoutId) return;
            _this2.drawLazily(wantedBounds);
          });
        } else {
          console.log('scheduling lazy draw for: ', wantedBounds.width, wantedBounds.height);
          var tid2 = this._drawLazilyTimeoutId = setTimeout(function () {
            if (tid2 !== _this2._drawLazilyTimeoutId) return;
            if (!Bounds.areaEquals(_this2.lastDrawnCanvasBounds, wantedBounds)) {
              _this2.draw();
            }
          });
        }
      }
    }]);
    return _class;
  }(superclass);
};

/**
 * Store a reference to the mithril component on it's corresponding dom
 * element.
 */

var RegisterComponentMixin = function RegisterComponentMixin(superclass) {
  return function (_superclass) {
    inherits(_class, _superclass);

    function _class() {
      classCallCheck(this, _class);
      return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    createClass(_class, [{
      key: "oninit",


      /**
       *
       * @param vnode
       */

      value: function oninit(vnode) {
        if (get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "oninit", this)) get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "oninit", this).call(this, vnode);
        if (vnode.attrs && vnode.attrs.registerComponentCallback) {
          vnode.attrs.registerComponentCallback(this);
        }
      }

      /**
       *
       * @param vnode
       */

    }, {
      key: "oncreate",
      value: function oncreate(vnode) {
        if (get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "oncreate", this)) get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "oncreate", this).call(this, vnode);
        vnode.dom.mithrilComponent = this;
      }

      /**
       *
       * @param vnode
       */

    }, {
      key: "onbeforeremove",
      value: function onbeforeremove(vnode) {
        if (get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "onbeforeremove", this)) get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), "onbeforeremove", this).call(this, vnode);
        delete vnode.dom.mithrilComponent;
      }
    }]);
    return _class;
  }(superclass);
};

var quickselect$1 = createCommonjsModule(function (module, exports) {
(function (global, factory) {
	module.exports = factory();
}(commonjsGlobal, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));
});

var index = rbush;
var default_1 = rbush;

var quickselect = quickselect$1;

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

index.default = default_1;

/**
 * SceneGraphNodeBase
 * Base Class representing a drawable element in canvas scenegraph
 */

var SceneGraphNodeBase = function () {

  /**
   * Create a SceneGraphNode.
   * Constructor uses ES6 destructuring of parameters from an object.
   * e.g. new SceneGraphNode({param: .., param2, etc.})
   *
   * @param {Object} params - having the following properties:
   * @param {Array} tags - an label or slug
   * @param {Object} parent - the parent node
   * @param {Object} bounds - local Canvas bounds, relative to our parent.
   * This is not the same as DOM bounds of the canvas element!
   * @param {Number} rotation - degrees, default 0.
   */

  function SceneGraphNodeBase(_ref) {
    var parent = _ref.parent,
        bounds = _ref.bounds,
        _ref$rotation = _ref.rotation,
        rotation = _ref$rotation === undefined ? 0 : _ref$rotation,
        _ref$tags = _ref.tags,
        tags = _ref$tags === undefined ? [] : _ref$tags;
    classCallCheck(this, SceneGraphNodeBase);

    this.parent = parent;
    this._rotation = rotation;
    this._tags = tags;
    this.bounds = bounds;
    this._children = []; // note: subclasses implement own children data structure
    this.locMap = index();
    this._visble = [];
  }

  /* getters and setters */
  /* define getters for our properties; note subclasses can override setters,
    e.g. to perform layout or calculations based on new state */

  /* getters */

  /**
   * Children scene graph nodes
   * @returns {Array|*} any child nodes this node has
   */

  createClass(SceneGraphNodeBase, [{
    key: 'translatePointToGlobal',


    /* public methods */

    /**
     * Translate coordinates to canvas space. When an element wants to draw on
     * canvas, it requires translating into global coordinates for the canvas.
     *
     * @param {Object} params - object with following properties:
     * @param {Number} x - x location
     * @param {Number} y - y location
     * @returns {Object} - { x, y } x,y location in global terms
     */

    value: function translatePointToGlobal(_ref2) {
      var x = _ref2.x,
          y = _ref2.y;

      var gb = this.globalBounds;
      return { x: x + gb.left, y: y + gb.top };
    }

    /**
     * Adds a child node to the _children array
     * and changes child node's parent to this node
     *
     * @param {object} node - SceneGraphNode derived item to insert as a child
     **/

  }, {
    key: 'addChild',
    value: function addChild(node) {
      if (node.parent) {
        node.parent.removeChild(node);
      }
      node.parent = this;
      if (this._children.indexOf(node) === -1) this._children.push(node);
    }

    /**
     * Removes a child node from the _children array
     * and changes child node's parent to undefined
     *
     * @param {object} node - SceneGraphNode derived node to remove
     **/

  }, {
    key: 'removeChild',
    value: function removeChild(node) {
      //TODO: May need to use a indexOf polyfill if targeting IE < 9
      var index$$1 = this._children.indexOf(node);
      if (index$$1 > -1) {
        this._children.splice(index$$1, 1);
      }
      node.parent = null;
    }

    /**
     * Traverse children and call their draw on the provided context
     *
     * @param {object} ctx - canvas context
     */

  }, {
    key: 'draw',
    value: function draw(ctx) {
      this.children.forEach(function (child) {
        return child.draw(ctx);
      });
    }
  }, {
    key: 'children',
    get: function get$$1() {
      return this._children;
    }

    /**
     * Local bounds
     * @returns {*} local bounds
     */

    ,


    /* setters */

    /**
     * Child scene graph nodes
     * @param {Array|*} b
     */

    set: function set$$1(b) {
      this._children = b;
    }

    /**
     * Nodes local bounds
     * @param b - bounds object
     */

  }, {
    key: 'bounds',
    get: function get$$1() {
      return this._bounds;
    }

    /**
     *  Rotation applied on this and subsequent children
     * @returns {*} rotation
     */

    ,
    set: function set$$1(b) {
      this._bounds = b;
    }

    /**
     * Rotation
     * @param {number} degrees - rotation in degrees
     */

  }, {
    key: 'rotation',
    get: function get$$1() {
      return this._rotation;
    }

    /**
     * Info tags
     * @returns {*} tags
     */

    ,
    set: function set$$1(degrees) {
      this._rotation = degrees;
    }

    /**
     * Tags
     * @param {array} tags - object's descriptive tags
     */

  }, {
    key: 'tags',
    get: function get$$1() {
      return this._tags;
    }

    /**
     * Traverse all parents bounds to calculate self Bounds on Canvas.
     * @returns {Object} - Bounds instance
     */

    ,
    set: function set$$1(tags) {
      this._tags = tags;
    }
  }, {
    key: 'globalBounds',
    get: function get$$1() {
      console.assert(this.bounds, 'bounds missing');
      if (!this.parent) return this.bounds;
      var gb = this.parent.globalBounds;
      return new Bounds({
        top: this.bounds.top + gb.top,
        bottom: this.bounds.bottom + gb.top,
        left: this.bounds.left + gb.left,
        right: this.bounds.right + gb.left,
        width: this.bounds.width,
        height: this.bounds.height
      });
    }

    /**
     * Use rbush to return children nodes that may be visible.
     * At this level, it is assumed that there is no viewport
     * constraints to the filter.
     *
     *  @return {Array} - array of rbush nodes
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      var vis = [];
      var childVisible = this.children.map(function (child) {
        return child.locMap.all();
      });
      childVisible.forEach(function (item) {
        vis = vis.concat(item);
      });
      return vis;
    }

    /**
     *  Traverse children, returning hitmap
     *  @returns {Array} - array of rbush entries
     */

  }, {
    key: 'hitMap',
    get: function get$$1() {
      var hits = [];
      var childMap = this.children.map(function (child) {
        return child.hitMap;
      });
      childMap.forEach(function (item) {
        hits = hits.concat(item);
      });
      return hits;
    }
  }]);
  return SceneGraphNodeBase;
}();

/**
 * SceneGraphNodeCanvas
 * Mithril component representing a html5 canvas element.
 *
 */

var SceneGraphNodeCanvas = function (_mix$with) {
  inherits(SceneGraphNodeCanvas, _mix$with);

  /**
   * constructor
   * @param model - data model for canvas
   * @param appState - app state model
   */

  function SceneGraphNodeCanvas(_ref) {
    var model = _ref.model,
        appState = _ref.appState;
    classCallCheck(this, SceneGraphNodeCanvas);

    var _this = possibleConstructorReturn(this, (SceneGraphNodeCanvas.__proto__ || Object.getPrototypeOf(SceneGraphNodeCanvas)).call(this, {}));

    _this.model = model;
    _this.appState = appState;
    _this.verticalScale = 1;
    _this.info = {
      visible: false,
      top: 0,
      left: 0
    };
    _this._gestureRegex = {
      pan: new RegExp('^pan'),
      pinch: new RegExp('^pinch'),
      tap: new RegExp('^tap'),
      wheel: new RegExp('^wheel')
    };
    return _this;
  }

  /**
   * Getter if canvas has focus
   * @returns {boolean}
   */

  createClass(SceneGraphNodeCanvas, [{
    key: 'oncreate',


    /**
     * mithril lifecycle method
     * @param vnode
     */

    value: function oncreate(vnode) {
      get(SceneGraphNodeCanvas.prototype.__proto__ || Object.getPrototypeOf(SceneGraphNodeCanvas.prototype), 'oncreate', this).call(this, vnode);
      this.canvas = this.el = vnode.dom;
      this.context2d = this.canvas.getContext('2d');
      this.drawLazily(this.domBounds);
    }

    /**
     * mithril lifecycle method
     * @param vnode - current virtual dom node
     */

  }, {
    key: 'onupdate',
    value: function onupdate(vnode) {
      // TODO: remove this development assistive method
      console.assert(this.el === vnode.dom);
      var b = new Bounds(this.el.getBoundingClientRect());
      console.log('BioMap.onupdate', this.el.mithrilComponent, b);
    }

    /**
     * mithril component render method
     */

  }, {
    key: 'view',
    value: function view() {
      // store these bounds, for checking in drawLazily()
      if (this.domBounds && !this.domBounds.isEmptyArea) {
        this.lastDrawnMithrilBounds = this.domBounds;
      }
      var b = this.domBounds || {};
      var selectedClass = this.selected ? 'selected' : '';
      return mithril('canvas', {
        class: 'cmap-canvas cmap-biomap ' + selectedClass,
        style: 'left: ' + b.left + 'px; top: ' + b.top + 'px;\n               width: ' + b.width + 'px; height: ' + b.height + 'px;\n               transform: rotate(' + this.rotation + 'deg);',
        width: b.width,
        height: b.height
      });
    }

    /**
     * draw our scene graph children on canvas element
     */

  }, {
    key: 'draw',
    value: function draw() {
      var ctx = this.context2d;
      if (!ctx) return;
      if (!this.domBounds) return;
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.save();
      //ctx.translate(0.5, 0.5); // prevent subpixel rendering of 1px lines
      this.visible.map(function (child) {
        return child && child.data.draw(ctx);
      });
      ctx.restore();
      // store these bounds, for checking in drawLazily()
      this.lastDrawnCanvasBounds = this.bounds;
      this.dirty = false;
    }

    /**
     * custom gesture event dispatch listener; see LayoutContainer
     * @param evt
     * @returns {boolean} Don't stop event propagation
     */

  }, {
    key: 'handleGesture',
    value: function handleGesture(evt) {
      if (evt.type.match(this._gestureRegex.tap)) {
        return this._onTap(evt);
      } else if (evt.type.match(this._gestureRegex.pinch)) {
        return this._onZoom(evt);
      } else if (evt.type.match(this._gestureRegex.wheel)) {
        return this._onZoom(evt);
      } else if (evt.type.match(this._gestureRegex.pan)) {
        if (evt.type === 'panend') {
          return this._onPanEnd(evt);
        } else if (evt.type === 'panstart') {
          return this._onPanStart(evt);
        } else {
          return this._onPan(evt);
        }
      }

      return false; // don't stop evt propagation
    }

    /**
     * Handle zoom event
     * @param evt - zoom event (mousewheel or gesture)
     * @returns {boolean} don't stop event propagation
     * @private
     */

  }, {
    key: '_onZoom',
    value: function _onZoom(evt) {
      // TODO: send zoom event to the scenegraph elements which compose the biomap
      // (don't scale the canvas element itself)
      console.warn('BioMap -> onZoom -- implement me', evt);
      return false; // stop event propagation
    }

    /**
     * Tap/Click event
     * @param evt
     * @returns {boolean} Don't stop event propagation by default
     * @private
     */

  }, {
    key: '_onTap',
    value: function _onTap(evt) {
      var sel = this.appState.selection.bioMaps;
      var i = sel.indexOf(this);
      if (i === -1) {
        sel.push(this);
      } else {
        sel.splice(i, 1);
      }
      mithril.redraw();
      pubsub.publish(selectedMap, {
        evt: evt,
        data: this.appState.selection.bioMaps
      });
      return false;
    }

    /**
     * Pan event that isn't first or last in sequence
     * @param evt
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_onPan',
    value: function _onPan(evt) {
      // TODO: send pan events to the scenegraph elements which compose the biomap
      // (don't scale the canvas element itself)
      if (evt.direction && hammer.DIRECTION_VERTICAL) {
        console.warn('BioMap -> onPan -- vertically; implement me', evt);
        return false; // stop event propagation
      }
      return false; // do not stop propagation
    }

    /**
     * First pan event in sequence
     * @param evt
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_onPanStart',
    value: function _onPanStart(evt) {
      // TODO: send pan events to the scenegraph elements which compose the biomap
      // (don't scale the canvas element itself)
      console.warn('BioMap -> onPanStart -- vertically; implement me', evt);
      return false;
    }

    /**
     * Final pan event in sequence
     * @param evt
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_onPanEnd',
    value: function _onPanEnd(evt) {
      // TODO: send pan events to the scenegraph elements which compose the biomap
      // (don't scale the canvas element itself)
      console.warn('BioMap -> onPanEnd -- vertically; implement me', evt);
      return false; // do not stop propagation
    }
  }, {
    key: 'selected',
    get: function get$$1() {
      return this.appState.selection.bioMaps.indexOf(this) !== -1;
    }
  }]);
  return SceneGraphNodeCanvas;
}(mix(SceneGraphNodeBase).with(DrawLazilyMixin, RegisterComponentMixin));

/**
 * FeatureMarker
 * A SceneGraphNode representing a feature on a Map with a line or hash mark.
 */
var SceneGraphNodeGroup = function (_SceneGraphNodeBase) {
  inherits(SceneGraphNodeGroup, _SceneGraphNodeBase);

  /**
   * constructor
   * @param params
   */

  function SceneGraphNodeGroup(params) {
    classCallCheck(this, SceneGraphNodeGroup);
    return possibleConstructorReturn(this, (SceneGraphNodeGroup.__proto__ || Object.getPrototypeOf(SceneGraphNodeGroup)).call(this, params));
  }

  /**
   * Return visible children elements
   * @returns {Array}
   */

  createClass(SceneGraphNodeGroup, [{
    key: 'visible',
    get: function get$$1() {
      var vis = [];
      var cVis = this.children.map(function (child) {
        return child.visible;
      });
      cVis.forEach(function (item) {
        vis = vis.concat(item);
      });
      return vis;
    }
  }]);
  return SceneGraphNodeGroup;
}(SceneGraphNodeBase);

var index$2 = TinyQueue;
var default_1$2 = TinyQueue;

function TinyQueue(data, compare) {
    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

    this.data = data || [];
    this.length = this.data.length;
    this.compare = compare || defaultCompare;

    if (this.length > 0) {
        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

TinyQueue.prototype = {

    push: function (item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    },

    pop: function () {
        if (this.length === 0) return undefined;

        var top = this.data[0];
        this.length--;

        if (this.length > 0) {
            this.data[0] = this.data[this.length];
            this._down(0);
        }
        this.data.pop();

        return top;
    },

    peek: function () {
        return this.data[0];
    },

    _up: function (pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
            var parent = (pos - 1) >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }

        data[pos] = item;
    },

    _down: function (pos) {
        var data = this.data;
        var compare = this.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];

        while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var right = left + 1;
            var best = data[left];

            if (right < this.length && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;

            data[pos] = best;
            pos = left;
        }

        data[pos] = item;
    }
};

index$2.default = default_1$2;

var Queue = index$2;

var index$1 = knn;
var default_1$1 = knn;

function knn(tree, x, y, n, predicate, maxDistance) {
    var node = tree.data,
        result = [],
        toBBox = tree.toBBox,
        i, child, dist, candidate;

    var queue = new Queue(null, compareDist);

    while (node) {
        for (i = 0; i < node.children.length; i++) {
            child = node.children[i];
            dist = boxDist(x, y, node.leaf ? toBBox(child) : child);
            if (!maxDistance || dist <= maxDistance) {
                queue.push({
                    node: child,
                    isItem: node.leaf,
                    dist: dist
                });
            }
        }

        while (queue.length && queue.peek().isItem) {
            candidate = queue.pop().node;
            if (!predicate || predicate(candidate))
                result.push(candidate);
            if (n && result.length === n) return result;
        }

        node = queue.pop();
        if (node) node = node.node;
    }

    return result;
}

function compareDist(a, b) {
    return a.dist - b.dist;
}

function boxDist(x, y, box) {
    var dx = axisDist(x, box.minX, box.maxX),
        dy = axisDist(y, box.minY, box.maxY);
    return dx * dx + dy * dy;
}

function axisDist(k, min, max) {
    return k < min ? min - k : k <= max ? 0 : k - max;
}

index$1.default = default_1$1;

/**
 * Placeholder for advanced group nodes 
 */
var SceneGraphNodeTrack = function (_SceneGraphNodeBase) {
  inherits(SceneGraphNodeTrack, _SceneGraphNodeBase);

  /**
   * Constructor
   * @param params
   */

  function SceneGraphNodeTrack(params) {
    classCallCheck(this, SceneGraphNodeTrack);
    return possibleConstructorReturn(this, (SceneGraphNodeTrack.__proto__ || Object.getPrototypeOf(SceneGraphNodeTrack)).call(this, params));
  }

  return SceneGraphNodeTrack;
}(SceneGraphNodeBase);

/**
 * FeatureMarker
 * A SceneGraphNode representing a feature on a Map with a line or hash mark.
 *
 * @extends SceneGraphNodeBase
 */
var FeatureMark = function (_SceneGraphNodeBase) {
  inherits(FeatureMark, _SceneGraphNodeBase);

  /**
   * Constructor
   * @param parent - parent scene graph node
   * @param bioMap - map data
   * @param featureModel - feature data
   */

  function FeatureMark(_ref) {
    var parent = _ref.parent,
        bioMap = _ref.bioMap,
        featureModel = _ref.featureModel,
        config = _ref.config;
    classCallCheck(this, FeatureMark);

    var _this = possibleConstructorReturn(this, (FeatureMark.__proto__ || Object.getPrototypeOf(FeatureMark)).call(this, { parent: parent, tags: [featureModel.name] }));

    _this.model = featureModel;
    _this.featureMap = bioMap;
    _this.config = config;

    _this.offset = _this.featureMap.view.base.start * -1;
    _this.invert = _this.featureMap.view.invert;
    _this.start = _this.model.coordinates.start;

    _this.pixelScaleFactor = _this.featureMap.view.pixelScaleFactor;
    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: 0,
      left: 0,
      width: parent.bounds.width,
      height: _this.lineWeight
    });
    return _this;
  }

  /**
   * Draw the marker
   * @param ctx - active canvas2D context
   */

  createClass(FeatureMark, [{
    key: 'draw',
    value: function draw(ctx) {
      var config = this.config;
      var y = translateScale(this.start, this.featureMap.view.base, this.featureMap.view.visible, this.invert) * this.pixelScaleFactor;
      this.bounds.top = y;
      var gb = this.globalBounds || {};
      ctx.beginPath();
      ctx.strokeStyle = config.lineColor;
      ctx.lineWidth = config.lineWeight;
      // noinspection JSSuspiciousNameCombination
      ctx.moveTo(Math.floor(gb.left), Math.floor(gb.top));
      // noinspection JSSuspiciousNameCombination
      ctx.lineTo(Math.floor(gb.right), Math.floor(gb.top));
      ctx.stroke();
      // reset bounding box to fit the new stroke location/width
      // lineWidth adds equal percent of passed width above and below path
      this.bounds.top = Math.floor(y - config.lineWeight / 2);
      this.bounds.bottom = Math.floor(y + config.lineWeight / 2);
    }
  }]);
  return FeatureMark;
}(SceneGraphNodeBase);

/**
 * MapBackbone
 * A SceneGraphNode representing a backbone, simply a rectangle enclosing the upper and
 * lower bounds of the map of the current feature, providing a delineated region to draw
 * features of interest
 *
 * @extends SceneGraphNodeBase
 */

var MapBackbone = function (_SceneGraphNodeBase) {
  inherits(MapBackbone, _SceneGraphNodeBase);

  /**
   * Constructor
   * @param parent - Parent scene graph node
   * @param bioMap - Map data
   */

  function MapBackbone(_ref) {
    var parent = _ref.parent,
        bioMap = _ref.bioMap,
        config = _ref.config;
    classCallCheck(this, MapBackbone);

    var _this = possibleConstructorReturn(this, (MapBackbone.__proto__ || Object.getPrototypeOf(MapBackbone)).call(this, { parent: parent }));

    _this.config = config;
    var b = parent.bounds;
    var backboneWidth = config.width;
    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: 0,
      left: b.width * 0.5 - backboneWidth * 0.5,
      width: backboneWidth + config.lineWeight,
      height: b.height
    });
    bioMap.view.backbone = _this.globalBounds;
    return _this;
  }

  /**
   * Draw the map backbone, then iterate through and draw its children
   * @param ctx - currently active canvas2D context
   */

  createClass(MapBackbone, [{
    key: 'draw',
    value: function draw(ctx) {
      var config = this.config;
      var gb = this.globalBounds || {};
      ctx.fillStyle = config.fillColor;
      // noinspection JSSuspiciousNameCombination
      // noinspection JSSuspiciousNameCombination
      ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));

      if (this.lineWidth > 0) {
        ctx.strokeStyle = config.lineColor;
        ctx.lineWidth = config.lineWeight;
        ctx.strokeRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));
      }

      this.children.forEach(function (child) {
        return child.draw(ctx);
      });
    }
  }]);
  return MapBackbone;
}(SceneGraphNodeBase);

/**
 *
 * A SceneGraphNode representing a text label for a feature on a Map.
 *
 * @extends SceneGraphNodeBase
 */

var FeatureLabel = function (_SceneGraphNodeBase) {
  inherits(FeatureLabel, _SceneGraphNodeBase);

  /**
   * Constructor
   *
   * @param parent - parent scene graph node
   * @param bioMap - map data
   * @param featureModel - feature data
   */

  function FeatureLabel(_ref) {
    var parent = _ref.parent,
        bioMap = _ref.bioMap,
        featureModel = _ref.featureModel,
        config = _ref.config;
    classCallCheck(this, FeatureLabel);

    var _this = possibleConstructorReturn(this, (FeatureLabel.__proto__ || Object.getPrototypeOf(FeatureLabel)).call(this, { parent: parent, tags: [featureModel.name] }));

    _this.config = config;
    _this.model = featureModel;
    _this.view = bioMap.view;
    _this.pixelScaleFactor = _this.view.pixelScaleFactor;
    _this.invert = bioMap.view.invert;
    _this.start = _this.model.coordinates.start;
    _this.bounds = new Bounds({
      top: 0,
      left: 5,
      width: 200, //this.fontSize*(this.model.name.length),
      height: 12,
      allowSubpixel: false
    });
    return _this;
  }

  /**
   * Draw label on cmap canvas context
   * @param ctx
   */

  createClass(FeatureLabel, [{
    key: 'draw',
    value: function draw(ctx) {
      var config = this.config;
      var y = translateScale(this.start, this.view.base, this.view.visible, this.invert) * this.pixelScaleFactor;
      this.bounds.top = y;
      this.bounds.bottom = y + config.labelSize;
      var gb = this.globalBounds || {};
      ctx.font = config.labelSize + 'px ' + config.labelFace;
      ctx.textAlign = 'left';
      ctx.fillStyle = config.labelColor;
      ctx.fillText(this.model.name, gb.left, gb.top);
      // reset bounding box to fit the new stroke location/width
      this.bounds.width = this.bounds.left + Math.floor(ctx.measureText(this.model.name).width) + 1;
      if (this.parent.bounds.width < this.bounds.width) this.parent.bounds.width = this.bounds.width;
    }
  }]);
  return FeatureLabel;
}(SceneGraphNodeBase);

/**
 * MapTrack
 * A SceneGraphNode representing a backbone, simply a rectangle representing
 * the background.
 */
var MapTrack = function (_SceneGraphNodeTrack) {
  inherits(MapTrack, _SceneGraphNodeTrack);

  /**
   *
   * @param params
   */

  function MapTrack(params) {
    classCallCheck(this, MapTrack);

    console.log('MapTrack-> Constructing Map');

    var _this = possibleConstructorReturn(this, (MapTrack.__proto__ || Object.getPrototypeOf(MapTrack)).call(this, params));

    var b = _this.parent.bounds;
    _this.model = _this.parent.model;
    //const backboneWidth = b.width * 0.2;
    var backboneWidth = _this.model.config.backbone.width;
    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: 0,
      left: 0,
      width: backboneWidth,
      height: b.height
    });
    _this.mC = _this.parent.mapCoordinates;
    _this.backbone = new MapBackbone({ parent: _this, bioMap: _this.model, config: _this.model.config.backbone });
    _this.addChild(_this.backbone);

    // calculate scale factor between backbone coordinates in pixels
    _this.model.view.pixelScaleFactor = _this.backbone.bounds.height / _this.model.length;
    _this.model.view.backbone = _this.globalBounds;

    // Setup groups for markers and labels
    var markerGroup = new SceneGraphNodeGroup({ parent: _this });
    _this.addChild(markerGroup);
    _this.markerGroup = markerGroup;
    markerGroup.bounds = _this.backbone.bounds;
    _this.addChild(markerGroup);
    var labelGroup = new SceneGraphNodeGroup({ parent: _this });
    _this.addChild(labelGroup);
    _this.labelGroup = labelGroup;
    labelGroup.bounds = new Bounds({
      top: 0,
      left: _this.backbone.bounds.right + 1,
      height: _this.bounds.height,
      width: 0
    });

    // Filter features for drawing
    _this.filteredFeatures = _this.model.features.filter(function (model) {
      return model.length <= 0.00001;
    });

    //Place features and their labels, prepare to add to rtree
    var fmData = [];
    var lmData = [];
    _this.featureMarks = _this.filteredFeatures.map(function (model) {
      var fm = new FeatureMark({
        featureModel: model,
        parent: _this.backbone,
        bioMap: _this.model,
        config: _this.model.config.marker
      });

      var lm = new FeatureLabel({
        featureModel: model,
        parent: _this.labelGroup,
        bioMap: _this.parent.model,
        config: _this.model.config.marker
      });
      markerGroup.addChild(fm);
      labelGroup.addChild(lm);
      fmData.push({
        minY: model.coordinates.start,
        maxY: model.coordinates.stop,
        minX: fm.globalBounds.left,
        maxX: fm.globalBounds.right,
        data: fm
      });
      lmData.push({
        minY: model.coordinates.start,
        maxY: model.coordinates.stop,
        minX: lm.globalBounds.left,
        maxX: lm.globalBounds.left + _this.labelGroup.bounds.width,
        data: lm
      });
      if (lm.bounds.right > _this.labelGroup.bounds.right) _this.labelGroup.bounds.right = lm.bounds.right;
      return fm;
    });

    // Load group rTrees for markers and labels
    markerGroup.locMap.load(fmData);
    labelGroup.locMap.load(lmData);
    // load this rtree with markers (elements that need hit detection)
    _this.locMap.load(fmData);
    return _this;
  }

  /**
   *
   * @returns {*[]}
   */

  createClass(MapTrack, [{
    key: 'draw',


    /**
     *
     * @param ctx
     */

    value: function draw(ctx) {
      var gb = this.globalBounds || {};
      ctx.fillStyle = 'blue';
      // noinspection JSSuspiciousNameCombination
      // noinspection JSSuspiciousNameCombination
      ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));
      ctx.fillStyle = 'green';
      gb = this.labelGroup.globalBounds || {};
      // noinspection JSSuspiciousNameCombination
      // noinspection JSSuspiciousNameCombination
      ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));
    }
  }, {
    key: 'loadLabelMap',
    value: function loadLabelMap() {}
  }, {
    key: 'visible',
    get: function get$$1() {
      var coord = this.parent.model.view.base;
      var visc = this.parent.model.view.visible;

      var vis = [{
        minX: this.bounds.left,
        maxX: this.bounds.right,
        minY: coord.start,
        maxY: coord.stop,
        data: this.backbone
      }];
      vis = vis.concat(this.locMap.search({
        minX: this.bounds.left,
        maxX: this.bounds.right,
        minY: visc.start,
        maxY: visc.stop
      }));
      var labels = [];
      var start = visc.start;
      var stop = visc.stop;
      var psf = this.labelGroup.children[0].pixelScaleFactor;
      var step = (visc.start * (coord.stop * psf - 12) + visc.stop * (12 - coord.start * psf)) / (psf * (coord.stop - coord.start)) - start - coord.start * -1;
      for (var i = start; i < stop; i += step) {

        var item = index$1(this.labelGroup.locMap, this.labelGroup.children[0].globalBounds.left, i, 1)[0];
        if (labels.length === 0) {
          labels.push(item);
          continue;
        }
        var last = labels[labels.length - 1];
        if (item !== last && item.minY > last.maxY + step) {
          labels.push(item);
        }
      }
      vis = vis.concat(labels);
      return vis;
    }

    /**
     *
     */

  }, {
    key: 'hitMap',
    get: function get$$1() {
      var bbGb = this.backbone.globalBounds;
      return this.markerGroup.children.map(function (child) {
        return {
          minY: child.globalBounds.bottom + 1,
          maxY: child.globalBounds.top - 1,
          minX: bbGb.left,
          maxX: bbGb.right,
          data: child
        };
      });
    }
  }]);
  return MapTrack;
}(SceneGraphNodeTrack);

/**
 *
 * A SceneGraphNode representing a circular mark.
 *
 * @extends SceneGraphNodeBase
 */

var Dot = function (_SceneGraphNodeBase) {
  inherits(Dot, _SceneGraphNodeBase);

  /**
   * Constructor
   *
   * @param parent - parent scene graph node
   * @param bioMap - map data
   * @param featureModel - feature data
   * @param config - configuration information object
   */

  function Dot(_ref) {
    var parent = _ref.parent,
        bioMap = _ref.bioMap,
        featureModel = _ref.featureModel,
        config = _ref.config;
    classCallCheck(this, Dot);

    //setup config
    var _this = possibleConstructorReturn(this, (Dot.__proto__ || Object.getPrototypeOf(Dot)).call(this, { parent: parent, tags: [featureModel.name] }));

    _this.config = config;
    _this.model = featureModel;
    _this.view = bioMap.view;
    _this.pixelScaleFactor = _this.view.pixelScaleFactor;
    _this.invert = bioMap.view.invert;
    _this.start = _this.model.coordinates.start;
    _this.radius = config.width;
    _this.depth = 0;

    // setup initial placement
    if (_this.model.coordinates.depth) {
      _this.depth = translateScale(_this.model.coordinates.depth, {
        start: 0,
        stop: config.displayWidth
      }, config.view, false);
    }
    _this.bounds = new Bounds({
      top: 0,
      left: 0,
      width: 2 * _this.radius, //this.fontSize*(this.model.name.length),
      height: 2 * _this.radius,
      allowSubpixel: false
    });
    return _this;
  }

  /**
   * Draw label on cmap canvas context
   * @param ctx
   */

  createClass(Dot, [{
    key: 'draw',
    value: function draw(ctx) {
      //Setup a base offset based on parent track
      if (this.start < this.view.visible.start || this.start > this.view.visible.stop) return;
      if (!this.offset) {
        var left = this.globalBounds.left;
        var top = this.globalBounds.top;
        this.offset = { top: top, left: left };
      }
      var config = this.config;
      var y = translateScale(this.start, this.view.base, this.view.visible, this.invert) * this.pixelScaleFactor;
      var x = this.depth;

      // Draw dot
      ctx.beginPath();
      ctx.fillStyle = config.fillColor;
      ctx.arc(x + this.offset.left, y + this.offset.top, this.radius, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.lineWidth = config.lineWeight;
      ctx.strokeStyle = config.lineColor;
      ctx.stroke();

      //update bounding box
      this.bounds.top = y - this.radius;
      this.bounds.left = x - this.radius;
      this.bounds.width = 2 * this.radius;
      this.bounds.height = 2 * this.radius;
    }
  }]);
  return Dot;
}(SceneGraphNodeBase);

/**
 * QTL - A feature with a length and width drawn as part of a group of similar
 * features
 *
 * @extends SceneGraphNodeBase
 */

var manhattanRuler = function (_SceneGraphNodeBase) {
  inherits(manhattanRuler, _SceneGraphNodeBase);

  /**
   * Construct the QTL feature
   * @param parent - parent scene graph node
   * @param bioMap - map data
   * @param featureModel - feature data
   * @param initialConfig - configuration object for display variables
   */

  function manhattanRuler(_ref) {
    var parent = _ref.parent,
        featureModel = _ref.featureModel,
        config = _ref.config;
    classCallCheck(this, manhattanRuler);

    var _this = possibleConstructorReturn(this, (manhattanRuler.__proto__ || Object.getPrototypeOf(manhattanRuler)).call(this, { parent: parent }));

    _this.config = config;
    _this.manhattanPlot = featureModel;
    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: 0,
      left: 0,
      width: config.displayWidth,
      height: _this.parent.bounds.height
    });
    return _this;
  }

  /**
   *
   * @param ctx
   */

  createClass(manhattanRuler, [{
    key: 'draw',
    value: function draw(ctx) {
      var _this2 = this;

      var config = this.config;
      ctx.save();
      ctx.globalAlpha = .5;
      var cb = this.globalBounds;
      var depth = 0;
      if (this.manhattanPlot) {
        //Draw "ruler"
        ctx.strokeStyle = config.rulerColor;
        ctx.lineWidth = config.rulerWeight;

        //Baseline marks
        ctx.beginPath();

        ctx.moveTo(cb.left, cb.top);
        ctx.lineTo(cb.right, cb.top);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cb.left, cb.bottom);
        ctx.lineTo(cb.right, cb.bottom);
        ctx.stroke();

        //Ruler
        for (var i = 0; i <= this.manhattanPlot.view.stop; i++) {
          if (i % config.rulerMinorMark === 0 || i % config.rulerMajorMark === 0) {
            depth = translateScale(i, {
              start: 0,
              stop: config.displayWidth
            }, this.manhattanPlot.view, false);
            ctx.beginPath();
            ctx.moveTo(cb.left + depth, cb.top);
            ctx.lineTo(cb.left + depth, cb.top - 10);
            ctx.stroke();
            if (i % config.rulerMajorMark === 0) {
              ctx.font = config.labelSize;
              ctx.fillStyle = config.labelColor;
              ctx.textAlign = 'center';
              ctx.fillText(String(i), cb.left + depth, cb.top - 11);
            }
          }
        }
        ctx.fillText('-log10(p)', cb.left + config.displayWidth / 2, cb.top - 25);

        // Reference lines

        if (this.manhattanPlot.lines) {
          this.manhattanPlot.lines.forEach(function (line) {
            depth = translateScale(line.value, {
              start: 0,
              stop: config.displayWidth
            }, _this2.manhattanPlot.view, false);
            ctx.strokeStyle = line.lineColor;
            ctx.lineWidth = line.lineWeight;
            ctx.beginPath();
            ctx.moveTo(cb.left + depth, cb.top);
            ctx.lineTo(cb.left + depth, cb.bottom);
            ctx.stroke();
          });
        }
      }
      ctx.restore();

      this.children.forEach(function (child) {
        return child.draw(ctx);
      });
    }
  }]);
  return manhattanRuler;
}(SceneGraphNodeBase);

/**
 * ManhattanPlot
 * A SceneGraphNodeTrack representing a Manhattan Plot.
 *
 * @extends SceneGraphNodeTrack
 */
var ManhattanPlot = function (_SceneGraphNodeTrack) {
  inherits(ManhattanPlot, _SceneGraphNodeTrack);

  /**
   * Constructor - sets up a track that's a group of QTL rectangles
   * @param params
   */

  function ManhattanPlot(params) {
    classCallCheck(this, ManhattanPlot);

    var _this = possibleConstructorReturn(this, (ManhattanPlot.__proto__ || Object.getPrototypeOf(ManhattanPlot)).call(this, params));

    console.log('manhattan -> constructor', params);
    var manhattanPlot = params.config;
    var b = _this.parent.bounds;
    _this.trackPos = params.position || 1;
    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: 0,
      left: 0,
      width: 0,
      height: b.height
    });
    if (manhattanPlot !== null) {
      var manhattanInfo = manhattanPlot;
      //merge configuration information with default config
      for (var key in _this.parent.model.config.manhattan) {
        if (!manhattanInfo.hasOwnProperty(key)) {
          manhattanInfo[key] = _this.parent.model.config.manhattan[key];
        }
      }
      manhattanInfo.lines.forEach(function (line) {
        if (!line.lineWeight) {
          line.lineWeigth = manhattanInfo.featureLineWeight;
        }
        if (!line.lineColor) {
          line.lineColor = manhattanInfo.featureLineColor;
        }
      });

      // If data hasn't been attached to this map to plot, filter and attach it.
      if (manhattanInfo.data === undefined) {
        manhattanInfo.view = {
          start: 0,
          stop: manhattanInfo.maxValue || 0
        };
        var baseData = _this.parent.sources.filter(function (model) {
          return model.id === manhattanInfo.dataId;
        });

        var prefix = manhattanInfo.prefix || '';
        manhattanInfo.data = baseData[0].parseResult.data.filter(function (mdata) {
          if (prefix + mdata[manhattanInfo.targetField] === _this.parent.model.name) {
            if (manhattanInfo.max === undefined && -Math.log10(mdata[manhattanInfo.pField]) >= manhattanInfo.view.stop) {
              //determine max value while filtering data
              manhattanInfo.view.stop = Math.ceil(-Math.log10(mdata[manhattanInfo.pField]));
            }
            return true;
          }
          return false;
        });
      }

      //Draw manhattan plot
      //let left = this.parent.bbGroup.bounds.right;

      _this.bounds = new Bounds({
        allowSubpixel: false,
        top: 0,
        left: 0,
        width: manhattanInfo.displayWidth || 0,
        height: b.height
      });

      var fmData = [];
      var locData = [];
      _this.fmData = fmData;

      _this.manhattanMarks = manhattanInfo.data.map(function (model) {
        model.coordinates = {
          start: model[manhattanInfo.posField],
          depth: -Math.log10(model[manhattanInfo.pField])
        };
        if (model.coordinates.start > _this.parent.model.view.base.stop || model.coordinates.start < _this.parent.model.view.base.start) {
          return;
        }

        var fm = new Dot({
          featureModel: model,
          parent: _this,
          bioMap: _this.parent.model,
          config: manhattanInfo
        });
        fmData.push(fm);

        var loc = {
          minY: model.coordinates.start,
          maxY: model.coordinates.start,
          minX: fm.globalBounds.left,
          maxX: fm.globalBounds.right,
          data: fm
        };

        locData.push(loc);
        return fm;
      });

      _this.ruler = {
        minY: 0,
        maxY: 100000000,
        minX: _this.globalBounds.left,
        maxX: _this.globalBounds.right,
        data: new manhattanRuler({
          featureModel: manhattanInfo,
          parent: _this,
          config: manhattanInfo
        })
      };

      _this.locMap.load(locData);
      _this.tags = ['manhattan'];
    }
    return _this;
  }

  /**
   *
   */

  createClass(ManhattanPlot, [{
    key: 'draw',


    // /**
    //  * Debug draw to check track positioning
    //  * @param ctx
    //  */

    value: function draw(ctx) {
      // ctx.save();
      // ctx.globalAlpha = .5;
      // ctx.fillStyle = 'green';
      // let cb = this.globalBounds;
      // ctx.fillRect(cb.left,cb.top,cb.width,cb.height);
      // ctx.restore();

      this.children.forEach(function (child) {
        return child.draw(ctx);
      });
    }

    // /**
    //  * Get RTree children that are visible in the canvas' current zoom bounds
    //   * @returns {Array}
    //   */
    //

  }, {
    key: 'visible',
    get: function get$$1() {
      return this.locMap.all().concat(this.ruler);
    }
  }, {
    key: 'hitMap',
    get: function get$$1() {
      //return this.locMap.all();
      return this.children.map(function (child) {
        return {
          minY: child.globalBounds.top,
          maxY: child.globalBounds.bottom,
          minX: child.globalBounds.left,
          maxX: child.globalBounds.right,
          data: child
        };
      });
    }
  }]);
  return ManhattanPlot;
}(SceneGraphNodeTrack);

/**
 * QTL - A feature with a length and width drawn as part of a group of similar
 * features
 *
 * @extends SceneGraphNodeBase
 */

var QTL = function (_SceneGraphNodeBase) {
  inherits(QTL, _SceneGraphNodeBase);

  /**
   * Construct the QTL feature
   * @param parent - parent scene graph node
   * @param bioMap - map data
   * @param featureModel - feature data
   * @param initialConfig - configuration object for display variables
   */

  function QTL(_ref) {
    var parent = _ref.parent,
        bioMap = _ref.bioMap,
        featureModel = _ref.featureModel,
        initialConfig = _ref.initialConfig,
        config = _ref.config;
    classCallCheck(this, QTL);

    var _this = possibleConstructorReturn(this, (QTL.__proto__ || Object.getPrototypeOf(QTL)).call(this, { parent: parent, tags: [featureModel.name] }));

    _this.model = featureModel;
    _this.featureMap = bioMap;
    _this.view = _this.featureMap.view;
    _this.lineWidth = 1.0;
    //min and max location in pixels
    _this.pixelScaleFactor = _this.featureMap.view.pixelScaleFactor;
    _this.fill = config.fillColor;
    if (initialConfig.fillColor) {
      _this.fill = initialConfig.fillColor[initialConfig.filters.indexOf(_this.model.tags[0])] || initialConfig.fillColor[0];
    }

    _this.width = initialConfig.width || config.width;
    _this.trackSpacing = initialConfig.internalPadding || config.internalPadding;
    _this.labelColor = initialConfig.labelColor || config.labelColor;
    _this.labelSize = initialConfig.labelSize || config.labelSize;
    _this.labelFace = initialConfig.labelFace || config.labelFace;
    _this.offset = _this.trackSpacing + _this.labelSize;
    _this.invert = _this.view.invert;
    _this.start = _this.invert ? _this.model.coordinates.stop : _this.model.coordinates.start;
    _this.stop = _this.invert ? _this.model.coordinates.start : _this.model.coordinates.stop;

    // Calculate start/end position, then
    // Iterate across QTLs in group and try to place QTL region where it can
    // minimize stack width in parent group 
    var y1 = translateScale(_this.start, _this.view.base, _this.view.visible, _this.invert) * _this.pixelScaleFactor;
    var y2 = translateScale(_this.stop, _this.view.base, _this.view.visible, _this.invert) * _this.pixelScaleFactor;
    var leftLoc = 0;
    var leftArr = void 0;
    leftArr = _this.parent.locMap.search({
      minY: _this.model.coordinates.start,
      maxY: _this.model.coordinates.stop,
      minX: 0,
      maxX: 10000
    });
    leftArr = leftArr.sort(function (a, b) {
      return a.data.bounds.right - b.data.bounds.right;
    });
    var stepOffset = _this.width + _this.offset;
    var stackEnd = leftArr.length;
    for (var i = 0; i <= stackEnd; ++i) {
      leftLoc = i * stepOffset;
      if (leftArr[i] && leftArr[i].data.bounds.left !== leftLoc) {
        break;
      }
    }

    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: y1,
      left: leftLoc,
      width: _this.width,
      height: y2 - y1
    });
    return _this;
  }

  /**
   *
   * @param ctx
   */

  createClass(QTL, [{
    key: 'draw',
    value: function draw(ctx) {
      // Get start and stop of QTL on current region, if it isn't located in
      // current view, don't draw, else cutoff when it gets to end of currently
      // visible region.
      if (this.model.coordinates.stop < this.view.visible.start || this.model.coordinates.start > this.view.visible.stop) return;
      var y1pos = this.model.coordinates.start > this.view.visible.start ? this.model.coordinates.start : this.view.visible.start;
      var y2pos = this.model.coordinates.stop < this.view.visible.stop ? this.model.coordinates.stop : this.view.visible.stop;
      this.start = y1pos;
      this.stop = y2pos;
      if (this.invert) {
        this.start = y2pos;
        this.stop = y1pos;
      }

      var y1 = translateScale(this.start, this.view.base, this.view.visible, this.invert) * this.pixelScaleFactor;
      var y2 = translateScale(this.stop, this.view.base, this.view.visible, this.invert) * this.pixelScaleFactor;

      //setup bounds and draw
      this.bounds = new Bounds({
        top: y1,
        height: y2 - y1,
        left: this.bounds.left,
        width: this.width
      });
      var gb = this.globalBounds || {};
      var qtlHeight = gb.height > 1 ? gb.height : 1;
      var fontSize = this.labelSize;
      var fontStyle = this.labelFace;
      ctx.font = fontSize + 'px ' + fontStyle;
      ctx.fillStyle = this.fill;
      // noinspection JSSuspiciousNameCombination
      // noinspection JSSuspiciousNameCombination
      ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(this.width), Math.floor(qtlHeight));
      var textWidth = ctx.measureText(this.model.name).width + ctx.measureText('M').width * 6;
      var textStop = this.stop - (translateScale(textWidth / this.pixelScaleFactor, this.view.base, this.view.visible) + this.view.base.start);
      var overlap = this.parent.locMap.search({
        minY: textStop > this.view.visible.start ? textStop : this.view.visible.start,
        maxY: this.stop,
        minX: gb.left,
        maxX: gb.right
      });
      if (overlap.length <= 1 || textWidth <= gb.height) {
        ctx.save();
        ctx.translate(gb.left, gb.top);
        ctx.fillStyle = this.labelColor;
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(this.model.name, -gb.height, this.width + fontSize + 1);
        ctx.restore();
      }

      // Draw any children
      this.children.forEach(function (child) {
        return child.draw(ctx);
      });
    }
  }]);
  return QTL;
}(SceneGraphNodeBase);

/**
 * QtlTrack
 * A SceneGraphNode representing a collection of QTLs.
 *
 * @extends SceneGraphNodeTrack
 */
var QtlTrack = function (_SceneGraphNodeTrack) {
  inherits(QtlTrack, _SceneGraphNodeTrack);

  /**
   * Constructor - sets up a track that's a group of QTL rectangles
   * @param params
   */

  /**
   * TODO: Allow for subtracks
   */

  function QtlTrack(params) {
    classCallCheck(this, QtlTrack);

    var _this = possibleConstructorReturn(this, (QtlTrack.__proto__ || Object.getPrototypeOf(QtlTrack)).call(this, params));

    _this.filteredFeatures = [];
    var b = _this.parent.bounds;
    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: 0,
      left: 0,
      width: _this.parent.model.config.qtl.trackMinWidth,
      height: b.height
    });

    var qtlConf = params.config;
    for (var key in _this.parent.model.config.qtl) {
      if (!qtlConf.hasOwnProperty(key)) {
        qtlConf[key] = _this.parent.model.config.qtl[key];
      }
    }

    qtlConf.filters.forEach(function (filter, order) {
      var test = _this.parent.model.features.filter(function (model) {
        return model.tags[0].match(filter) !== null;
      });
      if (test.length === 0) {
        // get rid of any tags that don't actually get used
        qtlConf.filters.splice(order, 1);
      } else {
        _this.filteredFeatures = _this.filteredFeatures.concat(test);
      }
    });

    _this.filteredFeatures.sort(function (a, b) {
      return a.coordinates.start - b.coordinates.start;
    });
    var fmData = [];

    _this.maxLoc = 0;
    _this.qtlMarks = _this.filteredFeatures.map(function (model) {
      var fm = new QTL({
        featureModel: model,
        parent: _this,
        bioMap: _this.parent.model,
        initialConfig: qtlConf,
        config: _this.parent.model.config.qtl
      });

      _this.addChild(fm);

      var loc = {
        minY: model.coordinates.start,
        maxY: model.coordinates.stop,
        minX: fm.globalBounds.left,
        maxX: fm.globalBounds.right,
        data: fm
      };

      _this.locMap.insert(loc);

      fmData.push(loc);

      if (fm.globalBounds.right > _this.globalBounds.right) {
        _this.bounds.right = fm.globalBounds.right - _this.globalBounds.left;
      }

      return fm;
    });
    _this.locMap.clear();
    _this.locMap.load(fmData);
    return _this;
  }

  /**
   *
   */

  createClass(QtlTrack, [{
    key: 'draw',


    /**
     * Debug draw to check track positioning
     * @param ctx
     */

    value: function draw(ctx) {
      ctx.save();
      ctx.globalAlpha = .5;
      ctx.fillStyle = '#ADD8E6';
      this.children.forEach(function (child) {
        var cb = child.globalBounds;
        // noinspection JSSuspiciousNameCombination
        // noinspection JSSuspiciousNameCombination
        ctx.fillRect(Math.floor(cb.left), Math.floor(cb.top), Math.floor(cb.width), Math.floor(cb.height));
      });
      ctx.restore();
    }

    /**
     * Get RTree children that are visible in the canvas' current zoom bounds
     * @returns {Array}
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      // let visible = [];
      // this.children.forEach(child => {
      //   visible = visible.concat(child.locMap.all());
      // });
      //
      // return visible;
      return this.locMap.all();
      //return this.locMap.all().concat([{data:this}]); // debugging statement to test track width bounds
    }
  }, {
    key: 'hitMap',
    get: function get$$1() {
      //return this.locMap.all();
      return this.children.map(function (child) {
        return {
          minY: child.globalBounds.top,
          maxY: child.globalBounds.bottom,
          minX: child.globalBounds.left,
          maxX: child.globalBounds.right,
          data: child
        };
      });
    }
  }]);
  return QtlTrack;
}(SceneGraphNodeTrack);

/**
 * FeatureTrack
 * A SceneGraphNode representing a collection of tracks.
 *
 * @extends SceneGraphNodeTrack
 */

var FeatureTrack = function (_SceneGraphNodeTrack) {
  inherits(FeatureTrack, _SceneGraphNodeTrack);

  /**
   * Constructor - sets up a track that's a group of QTL rectangles
   * @param params
   */

  function FeatureTrack(params) {
    classCallCheck(this, FeatureTrack);

    var _this = possibleConstructorReturn(this, (FeatureTrack.__proto__ || Object.getPrototypeOf(FeatureTrack)).call(this, params));

    _this.model = _this.parent.model;
    var b = _this.parent.bounds;
    _this.trackPos = params.position || 1;

    var left = _this.trackPos < 0 ? 10 : _this.parent.bbGroup.bounds.right;
    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: b.top,
      left: left,
      width: 0,
      height: b.height
    });
    if (_this.parent.model.tracks) {
      var tracks = _this.trackPos === 1 ? _this.parent.tracksLeft : _this.parent.tracksRight;
      tracks.forEach(function (track, order) {
        // newFeatureTrack is a group with two components, the feature data track, and the feature label track
        //track.appState = this.parent.appState;
        var newFeatureTrack = new SceneGraphNodeGroup({ parent: _this });
        newFeatureTrack.model = _this.model;
        newFeatureTrack.config = track;
        newFeatureTrack.order = order;

        var trackLeft = order === 0 ? 0 : _this.children[order - 1].bounds.right;
        trackLeft += _this.model.config.qtl.padding;

        newFeatureTrack.bounds = new Bounds({
          allowSubpixel: false,
          top: 0,
          left: trackLeft,
          width: _this.model.config.qtl.trackMinWidth,
          height: b.height
        });

        var featureData = {};
        if (track.type === 'qtl') {
          newFeatureTrack.title = track.title || _this.model.config.qtl.title || track.filters[0];
          featureData = new QtlTrack({ parent: newFeatureTrack, config: track });
        } else if (track.type === 'manhattan') {
          newFeatureTrack.sources = _this.parent.appState.sources;
          newFeatureTrack.title = track.title || _this.model.config.manhattan.title || 'Manhattan';
          featureData = new ManhattanPlot({ parent: newFeatureTrack, config: track });
        }

        newFeatureTrack.addChild(featureData);
        if (featureData.globalBounds.right > newFeatureTrack.globalBounds.right) {
          newFeatureTrack.bounds.right += featureData.bounds.right;
        }

        if (newFeatureTrack.globalBounds.right > _this.globalBounds.right) {
          _this.bounds.right = _this.bounds.left + (newFeatureTrack.globalBounds.right - _this.globalBounds.left);
        }

        _this.addChild(newFeatureTrack);
      });
    } else {
      _this.parent.model.tracks = [];
    }

    return _this;
  }

  /**
   *
   */

  createClass(FeatureTrack, [{
    key: 'draw',


    /**
     * Debug draw to check track positioning
     * @param ctx
     */

    value: function draw(ctx) {
      ctx.save();
      ctx.globalAlpha = .5;
      ctx.fillStyle = '#ADD8E6';
      this.children.forEach(function (child) {
        var cb = child.globalBounds;
        // noinspection JSSuspiciousNameCombination
        // noinspection JSSuspiciousNameCombination
        ctx.fillRect(Math.floor(cb.left), Math.floor(cb.top), Math.floor(cb.width), Math.floor(cb.height));
      });
      //ctx.fillStyle = 'red';
      //let cb = this.globalBounds;
      //ctx.fillRect(
      //  Math.floor(cb.left),
      //  Math.floor(cb.top),
      //  Math.floor(cb.width),
      //  Math.floor(cb.height)
      //);
      ctx.restore();
    }

    /**
     * Get RTree children that are visible in the canvas' current zoom bounds
     * @returns {Array}
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      var visible = [];
      this.children.forEach(function (child) {
        visible = visible.concat(child.visible);
      });
      return visible;
      //return visible.concat([{data:this}]); // debugging statement to test track width bounds
    }
  }, {
    key: 'hitMap',
    get: function get$$1() {
      //return [];
      // console.log('hits child',child);
      var hits = [];
      this.children.forEach(function (child) {
        return child.children.map(function (qtlGroup) {
          hits = hits.concat(qtlGroup.hitMap);
        });
      });
      return hits;
    }
  }]);
  return FeatureTrack;
}(SceneGraphNodeTrack);

/**
 * ruler
 * A SceneGraphNode representing ruler and zoom position for a given backbone
 *
 * @extends SceneGraphNodeBase
 */

var Ruler = function (_SceneGraphNodeBase) {
  inherits(Ruler, _SceneGraphNodeBase);

  /**
   * Constructor
   * @param parent - parent scene graph node
   * @param bioMap - map data
   * @param config - ruler configuration object
   */

  function Ruler(_ref) {
    var parent = _ref.parent,
        bioMap = _ref.bioMap,
        config = _ref.config;
    classCallCheck(this, Ruler);

    var _this = possibleConstructorReturn(this, (Ruler.__proto__ || Object.getPrototypeOf(Ruler)).call(this, { parent: parent }));

    _this.config = config;
    _this.mapCoordinates = bioMap.view;
    _this.offset = _this.mapCoordinates.base.start * -1;
    _this.pixelScaleFactor = _this.mapCoordinates.pixelScaleFactor;
    _this.invert = _this.mapCoordinates.invert;
    _this.fillColor = config.fillColor;
    _this.textFace = config.labelFace;
    _this.textSize = config.labelSize;
    _this.textColor = config.labelColor;
    _this.rulerPrecision = config.precision;
    _this.rulerWidth = config.width;
    _this.rulerPadding = config.padding;
    _this.innerSize = config.innerLineWeight;
    _this.innerColor = config.innerLineColor;

    var b = _this.parent.backbone.bounds;
    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: 0,
      left: b.left - config.width - config.padding - config.lineWeight, //arbitrary spacing to look goo
      width: config.width,
      height: b.height
    });
    return _this;
  }

  /**
   * Draw ruler and zoom bar
   * @param ctx - linked canvas2D context
   */

  createClass(Ruler, [{
    key: 'draw',
    value: function draw(ctx) {
      var config = this.config;
      var vStart = this.invert ? this.mapCoordinates.visible.stop : this.mapCoordinates.visible.start;
      var vStop = this.invert ? this.mapCoordinates.visible.start : this.mapCoordinates.visible.stop;
      var start = translateScale(vStart, this.mapCoordinates.base, this.mapCoordinates.base, this.invert) * this.pixelScaleFactor;
      var stop = translateScale(vStop, this.mapCoordinates.base, this.mapCoordinates.base, this.invert) * this.pixelScaleFactor;
      var text = [this.mapCoordinates.base.start.toFixed(config.precision), this.mapCoordinates.base.stop.toFixed(config.precision)];

      this.textWidth = ctx.measureText(text[0]).width > ctx.measureText(text[1]).width ? ctx.measureText(text[0]).width : ctx.measureText(text[1]).width;

      var gb = this.globalBounds || {};
      // draw baseline labels
      ctx.font = config.labelSize + 'px ' + config.labelFace;
      ctx.fillStyle = config.labelColor;
      ctx.textAlign = 'left';
      if (this.invert) {
        ctx.fillText(text[1], gb.left - ctx.measureText(text[1]).width - gb.width / 2, Math.floor(gb.top - config.labelSize / 2));
        ctx.fillText(text[0], gb.left - ctx.measureText(text[0]).width - gb.width / 2, Math.floor(gb.bottom + config.labelSize));
      } else {
        ctx.fillText(text[0], gb.left - ctx.measureText(text[0]).width - gb.width / 2, Math.floor(gb.top - config.labelSize / 2));
        ctx.fillText(text[1], gb.left - ctx.measureText(text[1]).width - gb.width / 2, Math.floor(gb.bottom + config.labelSize));
      }
      // Draw zoom position labels
      text = [this.mapCoordinates.visible.start.toFixed(config.precision), this.mapCoordinates.visible.stop.toFixed(config.precision)];
      if (this.invert) {
        ctx.fillText(text[1], gb.left + config.width + config.padding, Math.floor(gb.top - config.labelSize / 2));
        ctx.fillText(text[0], gb.left + config.width + config.padding, gb.bottom + config.labelSize);
      } else {
        ctx.fillText(text[0], gb.left + config.width + config.padding, Math.floor(gb.top - config.labelSize / 2));
        ctx.fillText(text[1], gb.left + config.width + config.padding, gb.bottom + config.labelSize);
      }

      //Draw baseline ruler
      ctx.beginPath();
      ctx.lineWidth = config.innerLineWeight;
      ctx.strokeStyle = config.innerLineColor;
      // noinspection JSSuspiciousNameCombination
      ctx.moveTo(Math.floor(gb.left + gb.width / 2), Math.floor(gb.top));
      // noinspection JSSuspiciousNameCombination
      ctx.lineTo(Math.floor(gb.left + gb.width / 2), Math.floor(gb.bottom));
      ctx.stroke();

      // Draw "zoom box"
      ctx.fillStyle = config.fillColor; //'aqua';
      var height = stop - start > 1 ? stop - start : 1.0;
      // noinspection JSSuspiciousNameCombination
      ctx.fillRect(Math.floor(gb.left), Math.floor(start + gb.top), Math.floor(gb.width), Math.floor(height));
      //draw border if asked for
      if (config.lineWeight > 0) {
        ctx.strokeStyle = config.lineColor;
        ctx.lineWidth = config.lineWeight;
        ctx.strokeRect(Math.floor(gb.left), Math.floor(start + gb.top), Math.floor(gb.width), Math.floor(height));
      }
      ////debugging rectangle to test group bounds
      //ctx.fillStyle = 'red';
      //ctx.fillRect(
      //  Math.floor(gb.left),
      //  Math.floor(gb.top),
      //  Math.floor(gb.width),
      //  Math.floor(gb.height)
      //);

      this.children.forEach(function (child) {
        return child.draw(ctx);
      });
    }

    /**
     * Return the ruler as data for an scenegraph visibility check. (Ruler by definition is
     * always visible, and does own logic for the position bar)
     * @returns {{data: Ruler}}
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      return { data: this };
    }
  }]);
  return Ruler;
}(SceneGraphNodeBase);

/**
 * Class representing a biological map and its associated tracks
 * @class BioMap
 * @extends SceneGraphNodeCanvas
 */

//import PubSub from 'pubsub-js';
//import {featureUpdate, dataLoaded} from '../../topics';

var BioMap = function (_SceneGraphNodeCanvas) {
  inherits(BioMap, _SceneGraphNodeCanvas);

  /**
   * Create a new bio map
   *
   * @param {object} bioMapModel - Parsed model of the bio map to be drawn
   * @param {object} appState - Application's meta state object
   * @param {object} layoutBounds - Bounds object of position on screen
   * @param {number} bioMapIndex - bio map's order on screen,
   * @param {object} initialView - bio map's original layout, used for resetting view
   */

  function BioMap(_ref) {
    var bioMapModel = _ref.bioMapModel,
        appState = _ref.appState,
        layoutBounds = _ref.layoutBounds,
        bioMapIndex = _ref.bioMapIndex,
        initialView = _ref.initialView;
    classCallCheck(this, BioMap);

    var _this = possibleConstructorReturn(this, (BioMap.__proto__ || Object.getPrototypeOf(BioMap)).call(this, { model: bioMapModel }));

    _this.initialView = initialView;
    _this.bioMapIndex = bioMapIndex;
    _this.model.visible = {
      start: _this.model.coordinates.start,
      stop: _this.model.coordinates.stop
    };
    _this.model.view = {
      base: {
        start: _this.model.coordinates.start,
        stop: _this.model.coordinates.stop
      },
      visible: {
        start: _this.model.coordinates.start,
        stop: _this.model.coordinates.stop
      },
      invert: _this.model.config.invert
    };

    _this.model.manhattanPlot = _this.initialView.manhattan || null;
    _this.zoomDelta = (_this.model.view.base.stop - _this.model.view.base.start) / _this.model.config.ruler.steps;
    // set up coordinate bounds for view scaling
    _this.appState = appState;
    _this.verticalScale = 0;
    _this.backbone = null;
    _this.featureMarks = [];
    _this.featureLabels = [];
    _this.info = {
      top: 0,
      left: 0,
      display: 'none'

    };

    // create some regular expressions for faster dispatching of events
    _this._gestureRegex = {
      pan: new RegExp('^pan'),
      pinch: new RegExp('^pinch'),
      tap: new RegExp('^tap'),
      wheel: new RegExp('^wheel')
    };
    _this._layout(layoutBounds);
    _this.dirty = true;
    return _this;
  }

  /*
   *  debug draw to test that the layer is positioned properly
   */
  /*
    draw(ctx){
   ctx = this.context2d;
   this.children.forEach(child => child.draw(ctx));
   ctx.save();
   ctx.globalAlpha = .5;
   ctx.fillStyle = '#f442e2';
   this.children.forEach( child => {
     let cb = child.globalBounds;
     ctx.fillRect(
       Math.floor(cb.left),
       Math.floor(cb.top),
       Math.floor(cb.width),
       Math.floor(cb.height)
     );
   });
   ctx.restore();
  }
  */
  /**
   * Mithril lifecycle method on initial vnode creation.
   * @param {object} vnode - node on mithril vnode representing this canvas item
   */

  createClass(BioMap, [{
    key: 'oncreate',
    value: function oncreate(vnode) {
      get(BioMap.prototype.__proto__ || Object.getPrototypeOf(BioMap.prototype), 'oncreate', this).call(this, vnode);
      //    PubSub.subscribe(featureUpdate, () => {
      //      this._layout(this.lb);
      //      this._redrawViewport(this.model.view.visible);
      //    });
    }

    // getters and setters

    /**
     * Culls elements to draw.
     *
     * @return array of elements visible in current canvas' viewport
     *
     */

  }, {
    key: '_onZoom',


    // Private functions

    // gesture components

    /**
     * Handles mouse wheel zoom
     * @param evt - zoom event
     * @returns {boolean} returns true to stop event propagation further down layers
     * @private
     */

    value: function _onZoom(evt) {
      // TODO: send zoom event to the scenegraph elements which compose the biomap
      // (don't scale the canvas element itself)
      console.warn('BioMap -> onZoom', evt);
      // normalise scroll delta
      this.verticalScale = evt.deltaY < 0 ? -this.zoomDelta : this.zoomDelta;
      var mcv = this.model.view.base;
      var zStart = this.model.view.visible.start + this.verticalScale;
      var zStop = this.model.view.visible.stop - this.verticalScale;
      if (zStop - zStart < .01) {
        this.verticalScale -= 0.5;
        return true;
      }
      if (zStart < mcv.start) {
        zStart = mcv.start;
      } else if (zStart > zStop) {
        zStart = zStop;
      }

      if (zStop > mcv.stop) {
        zStop = mcv.stop;
      } else if (zStop < zStart) {
        zStop = zStart;
      }
      this._redrawViewport({ start: zStart, stop: zStop });
      return true; // stop event propagation
    }

    /**
     * Handles tap/click event on canvas
     * @param evt - tap event
     * @returns {boolean} return true to stop event prorogation further down layers
     * @private
     */

  }, {
    key: '_onTap',
    value: function _onTap(evt) {
      var _this2 = this;

      console.log('BioMap -> onTap', evt, this);
      var globalPos = pageToCanvas(evt, this.canvas);
      this._loadHitMap();
      var hits = [];

      this.hitMap.search({
        minX: globalPos.x,
        maxX: globalPos.x,
        minY: globalPos.y - 2,
        maxY: globalPos.y + 2
      }).forEach(function (hit) {
        // temp fix, find why hit map stopped updating properly
        if (hit.data.model.coordinates.start >= _this2.model.view.visible.start && hit.data.model.coordinates.start <= _this2.model.view.visible.stop) {
          hits.push(hit.data);
        } else if (hit.data.model.coordinates.stop >= _this2.model.view.visible.start && hit.data.model.coordinates.stop <= _this2.model.view.visible.stop) {
          hits.push(hit.data);
        }
      });
      if (hits.length > 0) {
        hits.sort(function (a, b) {
          return a.model.coordinates.start - b.model.coordinates.start;
        });
        this.info.display = 'inline-block';
        this.info.top = hits[0].globalBounds.top;
        this.info.left = hits[0].globalBounds.right;
        this.info.data = hits;
        var names = hits.map(function (hit) {
          return hit.model.name;
        });
        //@awilkey: is this obsolete?
        //TODO: Revisit info popovers
        this.info.innerHTML = '<p> ' + names.join('\n') + ' </p>';
        mithril.redraw();
      } else if (this.info.display !== 'none') {
        this.info.display = 'none';
        mithril.redraw();
      }

      return true;
    }

    /**
     *  Handle start of pan events on canvas, box zooms if ruler is part of selected or
     *  mass select if not.
     *
     * @param evt - tap event
     * @returns {boolean} return true to stop event prorogation further down layers
     * @private
     */

  }, {
    key: '_onPanStart',
    value: function _onPanStart(evt) {
      // TODO: send pan events to the scenegraph elements which compose the biomap
      // (don't scale the canvas element itself)
      this.zoomP = {
        start: 0,
        end: 0,
        pStart: true,
        ruler: false,
        delta: 0,
        corner: 0
      };
      this.zoomP.pStart = true;
      console.warn('BioMap -> onPanStart -- vertically; implement me', evt);
      var globalPos = pageToCanvas(evt, this.canvas);
      var left = this.ruler.globalBounds.left;
      // scroll view vs box select
      if (left < globalPos.x - evt.deltaX && globalPos.x - evt.deltaX < left + this.ruler.bounds.width) {
        this.zoomP.ruler = true;
        this._moveRuler(evt);
      } else {
        this.zoomP.ruler = false;
        this.zoomP.start = this._pixelToCoordinate(globalPos.y - this.ruler.globalBounds.top - evt.deltaY);
        if (this.zoomP.start < this.model.view.base.start) {
          this.zoomP.start = this.model.view.base.start;
        }
        var ctx = this.context2d;
        this.zoomP.corner = { top: globalPos.y - evt.deltaY, left: globalPos.x - evt.deltaX };
        ctx.lineWidth = 1.0;
        ctx.strokeStyle = 'black';
        // noinspection JSSuspiciousNameCombination
        ctx.strokeRect(Math.floor(globalPos.x - evt.deltaX), Math.floor(globalPos.y - evt.deltaY), Math.floor(evt.deltaX), Math.floor(evt.deltaY));
      }
      return true;
    }

    /**
     * Pans ruler's position box on click-and-pan
     *
     * @param evt - pan event
     * @private
     */

  }, {
    key: '_moveRuler',
    value: function _moveRuler(evt) {
      if (this.model.config.invert) {
        evt.deltaY = -evt.deltaY;
      }

      var delta = (evt.deltaY - this.zoomP.delta) / this.model.view.pixelScaleFactor;
      if (this.model.view.visible.start + delta < this.model.view.base.start) {
        delta = this.model.view.base.start - this.model.view.visible.start;
      } else if (this.model.view.visible.stop + delta > this.model.view.base.stop) {
        delta = this.model.view.base.stop - this.model.view.visible.stop;
      }
      this.model.view.visible.start += delta;
      this.model.view.visible.stop += delta;
      this._redrawViewport({ start: this.model.view.visible.start, stop: this.model.view.visible.stop });
      this.zoomP.delta = evt.deltaY;
    }

    /**
     * Continue pre-exiting pan event
     *
     * @param evt - continuation of pan event
     * @returns {boolean} return true to stop event prorogation further down layers
     * @private
     */

  }, {
    key: '_onPan',
    value: function _onPan(evt) {
      // block propagation if pan hasn't started
      if (!this.zoomP || !this.zoomP.pStart) return true;
      if (this.zoomP && this.zoomP.ruler) {
        this._moveRuler(evt);
      } else {
        var globalPos = pageToCanvas(evt, this.canvas);
        this.draw();
        var ctx = this.context2d;
        ctx.lineWidth = 1.0;
        ctx.strokeStyle = 'black';
        // noinspection JSSuspiciousNameCombination
        ctx.strokeRect(Math.floor(this.zoomP.corner.left), Math.floor(this.zoomP.corner.top), Math.floor(globalPos.x - this.zoomP.corner.left), Math.floor(globalPos.y - this.zoomP.corner.top));
      }
      return true;
    }

    /**
     * Finalize pan event
     *
     * @param evt - tap event
     * @returns {boolean} return true to stop event propagation further down layers
     * @private
     */

  }, {
    key: '_onPanEnd',
    value: function _onPanEnd(evt) {
      var _this3 = this;

      // TODO: send pan events to the scenegraph elements which compose the biomap
      // (don't scale the canvas element itself)
      console.warn('BioMap -> onPanEnd -- vertically; implement me', evt, this.model.view.base);
      // block propagation if pan hasn't started
      if (!this.zoomP || !this.zoomP.pStart) return true;
      if (this.zoomP && this.zoomP.ruler) {
        this._moveRuler(evt);
      } else {
        var globalPos = pageToCanvas(evt, this.canvas);

        // test if any part of the box select is in the ruler zone
        var rLeft = this.ruler.globalBounds.left;
        var rRight = this.ruler.globalBounds.right;
        var lCorner = this.zoomP.corner.left < globalPos.x ? this.zoomP.corner.left : globalPos.x;
        var rCorner = lCorner === this.zoomP.corner.left ? globalPos.x : this.zoomP.corner.left;
        // if zoom rectangle contains the ruler, zoom, else populate popover
        if (lCorner <= rLeft && rCorner >= rLeft || lCorner <= rRight && rCorner >= rRight) {
          this.model.view.visible = this.model.view.base;

          this.zoomP.start = this._pixelToCoordinate(this.zoomP.corner.top - this.ruler.globalBounds.top);
          this.zoomP.stop = this._pixelToCoordinate(globalPos.y - this.ruler.globalBounds.top);
          var swap = this.zoomP.start < this.zoomP.stop;
          var zStart = swap ? this.zoomP.start : this.zoomP.stop;
          var zStop = swap ? this.zoomP.stop : this.zoomP.start;

          if (zStart < this.model.view.base.start) {
            zStart = this.model.view.base.start;
          }
          if (zStop > this.model.view.base.stop) {
            zStop = this.model.view.base.stop;
          }

          this._redrawViewport({ start: zStart, stop: zStop });
        } else {

          this._loadHitMap();
          var hits = [];
          var _swap = this.zoomP.corner.left < globalPos.x;
          var swapV = this.zoomP.corner.top < globalPos.y;
          this.hitMap.search({
            minX: _swap ? this.zoomP.corner.left : globalPos.x,
            maxX: _swap ? globalPos.x : this.zoomP.corner.left,
            minY: swapV ? this.zoomP.corner.top : globalPos.y,
            maxY: swapV ? globalPos.y : this.zoomP.corner.top
          }).forEach(function (hit) {
            // temp fix, find why hit map stopped updating properly
            if (!hit.data.model) return;
            if (hit.data.model.coordinates.start >= _this3.model.view.visible.start && hit.data.model.coordinates.start <= _this3.model.view.visible.stop) {
              hits.push(hit.data);
            } else if (hit.data.model.coordinates.stop >= _this3.model.view.visible.start && hit.data.model.coordinates.stop <= _this3.model.view.visible.stop) {
              hits.push(hit.data);
            }
          });
          if (hits.length > 0) {
            hits.sort(function (a, b) {
              return a.model.coordinates.start - b.model.coordinates.start;
            });
            this.info.display = 'inline-block';
            this.info.top = this.ruler.globalBounds.top;
            this.info.left = 0;
            this.info.data = hits;
            var names = hits.map(function (hit) {
              return hit.model.name;
            });
            //@awilkey: is this obsolete?
            this.info.innerHTML = '<p> ' + names.join('\n') + ' </p>';
            mithril.redraw();
          } else if (this.info.display !== 'none') {
            this.info.display = 'none';
            mithril.redraw();
          }
        }
      }
      this.draw();
      this.zoomP = {
        start: 0,
        end: 0,
        pStart: false,
        ruler: false,
        delta: 0,
        corner: {
          top: 0,
          left: 0
        }
      };
      //    this.zoomP.ruler = false;
      //    this.zoomP.pStart = false;
      return true; // do not stop propagation
    }

    /**
     *  Converts a pixel position to the  canvas' backbone coordinate system.
     *
     *  @param {number} point - pixel position on screen
     *  @return {number} backbone position
     *
     *  @private
     */

  }, {
    key: '_pixelToCoordinate',
    value: function _pixelToCoordinate(point) {
      var coord = this.model.view.base;
      var visc = this.model.view.visible;
      var psf = this.model.view.pixelScaleFactor;
      return (visc.start * (coord.stop * psf - point) + visc.stop * (point - coord.start * psf)) / (psf * (coord.stop - coord.start)) - coord.start * -1;
    }

    /**
     * perform layout of backbone, feature markers, and feature labels.
     *
     * @param {object} layoutBounds - bounds object representing bounds of this canvas
     *
     * @private
     */

  }, {
    key: '_layout',
    value: function _layout(layoutBounds) {
      var _this4 = this;

      // TODO: calculate width based on # of SNPs in layout, and width of feature
      // labels
      // Setup Canvas
      //const width = Math.floor(100 + Math.random() * 200);
      this.lb = this.lb || layoutBounds;
      console.log('BioMap -> layout');
      var width = Math.floor(this.lb.width / this.appState.bioMaps.length);
      this.children = [];
      this.domBounds = this.domBounds || new Bounds({
        left: this.lb.left,
        top: this.lb.top,
        width: width > 300 ? width : 300,
        height: this.lb.height
      });

      this.bounds = this.bounds || new Bounds({
        left: 0,
        top: this.lb.top + 40,
        width: this.domBounds.width,
        height: Math.floor(this.domBounds.height - 140) // set to reasonably re-size for smaller windows
      });
      //Add children tracks
      this.bbGroup = new SceneGraphNodeGroup({ parent: this });
      this.bbGroup.bounds = new Bounds({
        top: this.bounds.top,
        left: this.model.config.ruler.labelSize * 10,
        width: 10,
        height: this.bounds.height
      });
      this.bbGroup.model = this.model;
      this.backbone = new MapTrack({ parent: this });
      this.bbGroup.addChild(this.backbone);
      this.model.view.backbone = this.backbone.backbone.globalBounds;
      this.ruler = new Ruler({ parent: this, bioMap: this.model, config: this.model.config.ruler });
      this.bbGroup.addChild(this.ruler);
      this.backbone.children.forEach(function (child) {
        if (child.globalBounds.left < _this4.bbGroup.bounds.left) {
          _this4.bbGroup.bounds.left = child.globalBounds.left;
        }
        if (child.globalBounds.right > _this4.bbGroup.bounds.right) {
          _this4.bbGroup.bounds.right = child.globalBounds.right;
        }
      });
      this.children.push(this.bbGroup);

      this.tracksRight = [];
      this.tracksLeft = [];
      if (this.model.tracks) {
        this.model.tracks.forEach(function (track, order) {
          track.tracksIndex = order;
          if (track.position === -1) {
            _this4.tracksRight.push(track);
          } else {
            _this4.tracksLeft.push(track);
          }
        });
      }

      var qtlRight = new FeatureTrack({ parent: this, position: 1 });
      var qtlLeft = new FeatureTrack({ parent: this, position: -1 });
      // let qtlRight = {};
      //let qtlRight = new QtlTrack({parent: this , position: 1});
      //let qtlLeft = new QtlTrack({parent: this, position: -1});
      this.addChild(qtlRight);
      this.addChild(qtlLeft);

      if (qtlLeft && qtlLeft.bounds.right > this.bbGroup.bounds.left) {
        var bbw = this.bbGroup.bounds.width;
        this.bbGroup.bounds.left = qtlLeft.globalBounds.right + 100;
        this.bbGroup.bounds.width = bbw;
        var qrw = qtlRight.bounds.width;
        qtlRight.bounds.left += qtlLeft.globalBounds.right;
        qtlRight.bounds.right = qtlRight.bounds.left + qrw;
      }

      if (this.domBounds.width < qtlRight.globalBounds.right + 30) {
        this.domBounds.width = qtlRight.globalBounds.right + 50;
      }

      //load local rBush tree for hit detection
      this._loadHitMap();
      //let layout know that width has changed on an element;
      //m.redraw();
      this.dirty = true;
    }

    /**
     * Adds children nodes to the R-tree
     *
     * @private
     */

  }, {
    key: '_loadHitMap',
    value: function _loadHitMap() {
      var hits = [];
      var childrenHits = this.children.map(function (child) {
        return child.hitMap;
      });
      childrenHits.forEach(function (child) {
        hits = hits.concat(child);
      });
      this.locMap.clear(); // = rbush();
      this.locMap.load(hits);
    }

    /**
     * Redraw restricted view
     *
     * @param coordinates
     * @private
     */

  }, {
    key: '_redrawViewport',
    value: function _redrawViewport(coordinates) {
      this.model.view.visible = {
        start: coordinates.start,
        stop: coordinates.stop
      };
      this.backbone.loadLabelMap();
      this.draw();

      var cMaps = document.getElementsByClassName('cmap-correspondence-map');
      [].forEach.call(cMaps, function (el) {
        el.mithrilComponent.draw();
      });
      // move top of popover if currently visible
      if (this.info.display !== 'none') {
        this.info.top = this.info.data[0].globalBounds.top;
      }
      mithril.redraw();
    }
  }, {
    key: 'visible',
    get: function get$$1() {
      var vis = [];
      var cVis = this.children.map(function (child) {
        return child.visible;
      });
      cVis.forEach(function (item) {
        vis = vis.concat(item);
      });
      return vis;
    }

    /**
     * getter for the R-tree of subnodes.
     * @return rbush R-tree
     */

  }, {
    key: 'hitMap',
    get: function get$$1() {
      return this.locMap;
    }
  }]);
  return BioMap;
}(SceneGraphNodeCanvas);

/**
 * FeatureMarker
 * A SceneGraphNode representing a feature on a Map with a line or hash mark.
 *
 * @extends SceneGraphNodeBase
 */

var CorrespondenceMark = function (_SceneGraphNodeBase) {
  inherits(CorrespondenceMark, _SceneGraphNodeBase);

  /**
   * Construct the CorrespondenceMark layer
   * @param parent - parent scene graph node
   * @param featurePair - array of features being compared
   * @param mapCoordinates - current zoom level of each feature maps
   * @param bioMap - array of both sets of map data
   */

  /**
   * TODO: Allow configuration as part of config file
   */

  function CorrespondenceMark(_ref) {
    var parent = _ref.parent,
        featurePair = _ref.featurePair,
        mapCoordinates = _ref.mapCoordinates,
        bioMap = _ref.bioMap;
    classCallCheck(this, CorrespondenceMark);

    var _this = possibleConstructorReturn(this, (CorrespondenceMark.__proto__ || Object.getPrototypeOf(CorrespondenceMark)).call(this, { parent: parent }));

    _this.model = featurePair;
    _this.mapCoordinates = mapCoordinates;
    _this.lineWidth = 1.0;
    _this.bioMap = bioMap;
    _this.invert = [bioMap[0].model.config.invert, bioMap[1].model.config.invert];

    _this.pixelScaleFactor = [bioMap[0].model.view.pixelScaleFactor, bioMap[1].model.view.pixelScaleFactor];

    var leftY = translateScale(_this.model[0].coordinates.start, bioMap[0].model.view.base, bioMap[0].model.view.visible, _this.invert[0]) * _this.pixelScaleFactor[0];

    var rightY = translateScale(_this.model[1].coordinates.start, bioMap[1].model.view.base, bioMap[1].model.view.visible, _this.invert[1]) * _this.pixelScaleFactor[1];

    _this.bounds = new Bounds({
      allowSubpixel: false,
      top: leftY,
      left: parent.bounds.left,
      height: leftY - rightY,
      width: parent.bounds.width
    });
    return _this;
  }

  /**
   * Draw the correspondence marks
   * @param {object} ctx - canvas context 2D
   */

  createClass(CorrespondenceMark, [{
    key: 'draw',
    value: function draw(ctx) {
      var bioMap = this.bioMap;
      var leftYStart = translateScale(this.model[0].coordinates.start, bioMap[0].model.view.base, bioMap[0].model.view.visible, this.invert[0]) * this.pixelScaleFactor[0];

      var rightYStart = translateScale(this.model[1].coordinates.start, bioMap[1].model.view.base, bioMap[1].model.view.visible, this.invert[1]) * this.pixelScaleFactor[1];

      if (this.model[0].coordinates.start === this.model[0].coordinates.stop && this.model[1].coordinates.start === this.model[1].coordinates.stop) {
        // correspondence line
        this.bounds.top = leftYStart;
        this.bounds.bottom = rightYStart;
        var gb = this.globalBounds || {};
        ctx.beginPath();
        ctx.lineWidth = this.lineWidth;
        ctx.strokeStyle = '#CAA91E';
        ctx.globalAlpha = 0.7;
        // noinspection JSSuspiciousNameCombination
        ctx.moveTo(Math.floor(gb.left), Math.floor(gb.top));
        // noinspection JSSuspiciousNameCombination
        ctx.lineTo(Math.floor(gb.right), Math.floor(gb.bottom));
        ctx.stroke();
      } else {
        // correspondence region 
        var leftYStop = translateScale(this.model[0].coordinates.stop, bioMap[0].model.view.base, bioMap[0].model.view.visible, this.invert[0]) * this.pixelScaleFactor[0];
        var rightYStop = translateScale(this.model[1].coordinates.stop, bioMap[1].model.view.base, bioMap[1].model.view.visible, this.invert[1]) * this.pixelScaleFactor[1];

        this.bounds.top = leftYStart;
        this.bounds.bottom = leftYStop;
        var gbLeft = this.globalBounds || {};
        //let leftTop = gbLeft.top;
        //let leftBot = gbLeft.bottom;
        this.bounds.top = rightYStart;
        this.bounds.bottom = rightYStop;
        var gbRight = this.globalBounds || {};
        //let rightTop = gbRight.top;
        //let rightBot = gbRight.bottom;

        ctx.beginPath();
        ctx.lineWidth = this.lineWidth;
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#7C6400'; //'#A4870C';
        // noinspection JSSuspiciousNameCombination
        ctx.moveTo(Math.floor(gbLeft.left), Math.floor(gbLeft.top));
        // noinspection JSSuspiciousNameCombination
        ctx.lineTo(Math.floor(gbLeft.left), Math.floor(gbLeft.bottom));
        // noinspection JSSuspiciousNameCombination
        ctx.lineTo(Math.floor(gbRight.right), Math.floor(gbRight.bottom));
        // noinspection JSSuspiciousNameCombination
        ctx.lineTo(Math.floor(gbRight.right), Math.floor(gbRight.top));
        ctx.fill();
      }
    }
  }]);
  return CorrespondenceMark;
}(SceneGraphNodeBase);

/**
 * Feature
 * A base class for biological map feature
 */
var Feature = function () {

  /**
   * Create a Feature
   *
   * @param {Object} params - having the following properties
   * @param {String} name - name of feature
   * @param {Object} tags - array of String, optional slugs or tags, optional
   * @param {Object} aliases - array of alternate names, optional
   * @returns {Object}
   */

  function Feature(_ref) {
    var source = _ref.source,
        _ref$coordinates = _ref.coordinates,
        coordinates = _ref$coordinates === undefined ? { start: 0, stop: 0 } : _ref$coordinates,
        name = _ref.name,
        _ref$tags = _ref.tags,
        tags = _ref$tags === undefined ? [] : _ref$tags,
        _ref$aliases = _ref.aliases,
        aliases = _ref$aliases === undefined ? [] : _ref$aliases;
    classCallCheck(this, Feature);

    this.source = source;
    this.coordinates = Object.freeze(coordinates); // object w/ start and end props
    this.name = name;
    this.tags = tags;
    this.aliases = aliases;
  }

  /**
   *
   * @returns {number}
   */

  createClass(Feature, [{
    key: "typeLinkedBy",


    /**
     *
     * @param linkout
     * @returns {Array|*|boolean}
     */

    value: function typeLinkedBy(linkout) {
      return linkout.featuretypePattern !== undefined ? this.tags.some(function (t) {
        return linkout.featuretypePattern.test(t);
      }) : this.tags.includes(linkout.featuretype);
    }
  }, {
    key: "length",
    get: function get$$1() {
      return this.coordinates.stop - this.coordinates.start;
    }

    /**
     *
     * @returns {boolean}
     */

  }, {
    key: "typeHasLinkouts",
    get: function get$$1() {
      var _this = this;

      return this.source.linkouts.some(function (l) {
        return _this.typeLinkedBy(l);
      });
    }
  }]);
  return Feature;
}();

/**
 * @param Array features1 - 1st collection of features
 * @param Array features2 - 2nd collection of features
 * @return Array - tuples of results in common [[feat1, feat2], ...]
 */
/**
 * Find the common features based on name and aliases.
 * @param features1
 * @param features2
 * @returns {any[]}
 */

// TODO: support more than two collections of features


function featuresInCommon(features1, features2) {
  var setupDict = function setupDict(features) {
    var dict = {};
    features.forEach(function (f) {
      dict[f.name] = f;
      f.aliases.forEach(function (a) {
        if (a) dict[a] = f;
      });
    });
    return dict;
  };
  var dict1 = setupDict(features1);
  var dict2 = setupDict(features2);
  var intersectedKeys = Object.keys(dict1).filter(function (key) {
    return dict2[key];
  });
  return intersectedKeys.map(function (key) {
    return [dict1[key], dict2[key]];
  });
}

/**
 * Mithril component for correspondence lines between 2 or more BioMaps with an
 * html5 canvas element.
 *
 * @extends SceneGraphNodeCanvas
 *
 */
var CorrespondenceMap = function (_SceneGraphNodeCanvas) {
  inherits(CorrespondenceMap, _SceneGraphNodeCanvas);

  function CorrespondenceMap(_ref) {
    var bioMapComponents = _ref.bioMapComponents,
        appState = _ref.appState,
        layoutBounds = _ref.layoutBounds;
    classCallCheck(this, CorrespondenceMap);

    var _this = possibleConstructorReturn(this, (CorrespondenceMap.__proto__ || Object.getPrototypeOf(CorrespondenceMap)).call(this, {}));

    console.log('CorrespondenceMap -> constructor');
    _this.bioMapComponents = bioMapComponents;
    _this.appState = appState;
    _this.verticalScale = 1;
    _this.correspondenceMarks = [];
    _this._layout(layoutBounds);
    return _this;
  }

  /**
   * draw our scenegraph children our canvas element
   */


  createClass(CorrespondenceMap, [{
    key: 'draw',
    value: function draw() {
      var ctx = this.context2d;
      if (!ctx) return;
      if (!this.domBounds) return;
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      var gb = this.globalBounds || {};
      ctx.save();
      ctx.globalAlpha = 0;
      // noinspection JSSuspiciousNameCombination
      // noinspection JSSuspiciousNameCombination
      ctx.fillRect(Math.floor(gb.left), Math.floor(gb.top), Math.floor(gb.width), Math.floor(gb.height));
      ctx.restore();
      this.visible.map(function (child) {
        return child.data.draw(ctx);
      });
      // store these bounds, for checking in drawLazily()
      this.lastDrawnCanvasBounds = this.bounds;
    }

    /**
     * getter for common features between our bioMaps.
     */

  }, {
    key: 'view',


    /**
     * mithril component render callback
     *
     */

    value: function view() {
      if (this.domBounds && !this.domBounds.isEmptyArea) {
        this.lastDrawnMithrilBounds = this.domBounds;
      }
      var b = this.domBounds || {};
      return mithril('canvas', {
        class: 'cmap-canvas cmap-correspondence-map',
        style: 'left: ' + b.left + 'px; top: ' + b.top + 'px;\n      width: ' + b.width + 'px; height: ' + b.height + 'px;',
        width: b.width,
        height: b.height
      });
    }

    /**
     * Lay out correspondence lines between features
     * @param layoutBounds - bounds of the linked canvas
     * @private
     */

  }, {
    key: '_layout',
    value: function _layout(layoutBounds) {
      var _this2 = this;

      this.domBounds = layoutBounds;
      // this.bounds (scenegraph) has the same width and height, but zero the
      // left/top because we are the root node in a canvas sceneGraphNode
      // hierarchic.
      var gb1 = this.bioMapComponents[0].backbone.markerGroup.globalBounds;
      this.bounds = new Bounds({
        allowSubpixel: false,
        left: 1,
        top: 0,
        width: this.domBounds.width,
        height: this.domBounds.height
      });

      var corrData = [];
      var coorGroup = new SceneGraphNodeGroup({ parent: this });
      coorGroup.bounds = new Bounds({
        allowSubpixel: false,
        top: gb1.top,
        left: 0,
        width: this.domBounds.width,
        height: gb1.height
      });
      this.addChild(coorGroup);

      var bioMapCoordinates = [this.bioMapComponents[0].mapCoordinates, this.bioMapComponents[1].mapCoordinates];
      this.commonFeatures.forEach(function (feature) {
        var corrMark = new CorrespondenceMark({
          parent: coorGroup,
          featurePair: feature,
          mapCoordinates: bioMapCoordinates,
          bioMap: _this2.bioMapComponents
        });
        coorGroup.addChild(corrMark);
        corrData.push({
          minX: _this2.bounds.left,
          maxX: _this2.bounds.right,
          minY: feature[0].coordinates.start,
          maxY: feature[1].coordinates.start,
          data: corrMark
        });
      });
      this.locMap.load(corrData);
    }

    /**
     * Return visible elements in R-Tree
     */

  }, {
    key: 'commonFeatures',
    get: function get$$1() {
      // TODO: support more than 2 sets of features (e.g. for circos layout)
      var leftFeatures = this.bioMapComponents[0].model.features;
      var rightFeatures = this.bioMapComponents[1].model.features;
      //let leftFeatures = this.bioMapComponents[0].backbone.filteredFeatures;
      //let rightFeatures = this.bioMapComponents[1].backbone.filteredFeat
      return featuresInCommon(leftFeatures, rightFeatures);
      //return common;
    }
  }, {
    key: 'visible',
    get: function get$$1() {
      return this.locMap.all();
    }
  }]);
  return CorrespondenceMap;
}(SceneGraphNodeCanvas);

/**
 * LayoutBase
 * A Mithril component Base class for Layouts, e.g. HorizontalLayout and
 * CircosLayout.
 */
var Menu = function () {
  function Menu() {
    classCallCheck(this, Menu);
  }

  createClass(Menu, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril lifecycle callback
     * @param vnode
     */

    value: function oninit(vnode) {
      this.appState = vnode.attrs.appState;
    }

    /**
     * mithril lifecycle method
     * @param vnode
     */

  }, {
    key: 'oncreate',
    value: function oncreate(vnode) {
      // save a reference to this component's dom element

      this.el = vnode.dom;
      vnode.dom.mithrilComponent = this;
      this.bounds = new Bounds(vnode.dom.getBoundingClientRect());
    }

    /**
     * mithril lifecycle method
     * @param vnode
     */

  }, {
    key: 'onupdate',
    value: function onupdate(vnode) {
      this.bounds = new Bounds(vnode.dom.getBoundingClientRect());
    }
  }]);
  return Menu;
}();

/**
 * popover
 * A mithril component for displaying feature information.
 */
var Popover = function (_mix$with) {
  inherits(Popover, _mix$with);

  function Popover() {
    classCallCheck(this, Popover);
    return possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).apply(this, arguments));
  }

  createClass(Popover, [{
    key: 'oninit',


    /**
     *
     * @param vnode
     */

    value: function oninit(vnode) {
      get(Popover.prototype.__proto__ || Object.getPrototypeOf(Popover.prototype), 'oninit', this).call(this, vnode);
    }

    /**
     * mithril component render method
     * @param vnode
     * @returns {*}
     */

  }, {
    key: 'view',
    value: function view(vnode) {
      var b = vnode.attrs.domBounds || {};
      var info = vnode.attrs.info || { data: [] };
      return mithril('div', {
        class: 'biomap-info',
        style: 'left: ' + (info.left + b.left) + 'px; top: ' + (info.top + b.top) + 'px;\n               display: ' + info.display + ';'
      }, this._generateInner(info.data));
    }

    /**
     *
     * @param data
     * @returns {*}
     * @private
     */

  }, {
    key: '_generateInner',
    value: function _generateInner(data) {
      var _this2 = this;

      if (!data) return;

      var popover = data.map(function (item) {
        var start = mithril('div', 'start:  ' + item.model.coordinates.start);
        var stop = mithril('div', 'stop:  ' + item.model.coordinates.stop);
        var tags = item.model.tags.length > 0 && typeof item.model.tags[0] !== 'undefined' ? mithril('div', 'tags:  ', item.model.tags.join('\n')) : [];
        var aliases = item.model.aliases.length > 0 && typeof item.model.aliases[0] !== 'undefined' ? mithril('div', 'aliases:  ', item.model.aliases.join('\n')) : [];
        var links = item.model.source.linkouts.length > 0 ? mithril('div', { id: 'links-div-' + item.model.name }, item.model.source.linkouts.filter(function (l) {
          return !l.isLinkingService && item.model.typeLinkedBy(l);
        }).map(function (l) {
          return mithril('div', {}, mithril('a', {
            'target': '_blank',
            'href': l.url.replace(/\${item.id}/, item.model.name)
          }, l.text));
        }).concat(item.model.source.linkouts.some(function (l) {
          return l.isLinkingService && item.model.typeHasLinkouts;
        }) ? item.model.links === undefined ? mithril('img[src=images/ajax-loader.gif]') : item.model.links.map(function (l) {
          return mithril('div', {}, mithril('a', { target: '_blank', href: l.href }, l.text));
        }) : [])) : [];

        return [mithril(_this2._buttonTest(item.model), { targetId: item.model.name }), mithril('div', {
          class: 'biomap-info-data',
          id: 'biomap-info-' + item.model.name,
          style: 'display: none;'
        }, [start, stop, tags, aliases, links])];
      });

      return mithril('div', {}, popover);
    }

    /**
     *
     * @param feature
     * @returns {{view: view}}
     * @private
     */

  }, {
    key: '_buttonTest',
    value: function _buttonTest(feature) {
      var Links = {
        fetch: function fetch() {
          var url = void 0;
          return feature.source.linkouts.filter(function (l) {
            return l.isLinkingService && feature.tags.includes(l.featuretype);
          }).map(function (l) {
            url = l.url;
            url = url.replace(/\${item\.id}/, feature.name);
            return mithril.request({
              method: 'GET',
              url: url
            }).then(function (result) {
              feature.links = result;
            });
          });
        }
      };

      return {
        view: function view(vnode) {
          var targetName = 'biomap-info-' + vnode.attrs.targetId;
          return mithril('div', {
            class: 'biomap-info-name',
            onclick: function onclick() {
              var target = document.getElementById(targetName);
              target.style.display = target.style.display === 'none' ? 'block' : 'none';
              if (feature.links === undefined) {
                if (feature.source.linkouts.some(function (l) {
                  return l.isLinkingService && feature.typeHasLinkouts;
                })) {
                  var p = Links.fetch();
                  if (p !== undefined) {
                    p[0].then(vnode.redraw);
                  }
                } else {
                  feature.links = [];
                  vnode.redraw();
                }
              }
            }
          }, vnode.attrs.targetId);
        }
      };
    }

    /**
     *
     * @returns {boolean}
     */

  }, {
    key: 'handleGesture',
    value: function handleGesture() {
      // prevent interacting with div from propagating events
      console.log('popover gesture!');
      return true;
    }
  }]);
  return Popover;
}(mix(Menu).with(RegisterComponentMixin));

/**
 * ColorPicker.js
 * Mithril component for a colorselector tool.
 *
 */
/**
 *
 * @type {{oninit: ColorPicker.oninit, onupdate: ColorPicker.onupdate, view: ColorPicker.view}}
 */
var ColorPicker = {
  /**
   *
   * @param vnode
   */

  oninit: function oninit(vnode) {
    vnode.state = vnode.attrs;
    vnode.state.colors = {
      baseColor: vnode.attrs.settings.fillColor[vnode.attrs.order] || 'red',
      currentColor: null,
      hueValueColor: null
    };
  },

  /**
   *
   * @param vnode
   */

  onupdate: function onupdate(vnode) {
    vnode.attrs.settings.fillColor[vnode.attrs.order] = vnode.state.colors.baseColor;
  },

  /**
   *
   * @param vnode
   * @returns {*[]}
   */

  view: function view(vnode) {
    // store these bounds, for checking in drawLazily()
    return [mithril('div.color-picker', { style: 'display:' + vnode.state.hidden[vnode.state.order] }, [mithril(BaseSelector, { info: vnode.state }), mithril(SaturationSelector, { info: vnode.state }), mithril(ColorPreview, { info: vnode.state }), mithril('div#color-apply-controls', { style: 'text-align:center; margin-left:10px; display:inline-block; padding:auto' }, [mithril(ColorBox, { info: vnode.state }), //,settings:vnode.attrs.settings}),
    mithril(ColorApplyButton, { info: vnode.state, settings: vnode.state.settings }), mithril(ColorResetButton, { info: vnode.state })])])];
  }
};
/**
 *
 * @type {{oncreate: BaseSelector.oncreate, onupdate: BaseSelector.onupdate, view: BaseSelector.view, draw: BaseSelector.draw, handleGesture: BaseSelector.handleGesture, _locationChange: BaseSelector._locationChange, _changeColor: BaseSelector._changeColor, _posFromHsv: BaseSelector._posFromHsv, _hsvFromPos: BaseSelector._hsvFromPos}}
 */

var BaseSelector = {

  /**
   *
   * @param vnode
   */

  oncreate: function oncreate(vnode) {
    vnode.dom.mithrilComponent = this;
    this.vnode = vnode;
    vnode.state = vnode.attrs;
    vnode.state.canvas = this.el = vnode.dom;
    vnode.state.context2d = vnode.dom.getContext('2d');
    if (!vnode.state.info.currentColor || !vnode.state.info.hueValueColor) {
      vnode.state.context2d.fillStyle = vnode.state.info.colors.baseColor;
      //use the context to convert the original color into a hex string
      //avoiding needing to parse html color words
      vnode.state.info.colors.baseColor = vnode.state.context2d.fillStyle;
      vnode.state.info.colors.currentColor = vnode.state.context2d.fillStyle;
      vnode.state.info.colors.hueValueColor = rgbToHsv(hexToRgb(vnode.state.context2d.fillStyle));
    }
    vnode.state.ptrPos = this._posFromHsv(vnode.state.info.colors.hueValueColor);
    this._gestureRegex = {
      pan: new RegExp('^pan'),
      tap: new RegExp('^tap')
    };
    this.draw();
  },

  /**
   * mithril lifecycle method
   * @param vnode
   */

  onupdate: function onupdate(vnode) {
    vnode.state.ptrPos = vnode.dom.mithrilComponent._posFromHsv(vnode.state.info.colors.hueValueColor);
    vnode.dom.mithrilComponent.draw();
  },

  /**
   *
   * @returns {*}
   */

  view: function view() {
    // store these bounds, for checking in drawLazily()
    return mithril('canvas', {
      class: 'color-canvas-main',
      style: 'width: 200; height: 100;',
      width: 200,
      height: 100
    });
  },

  /**
   *
   */

  draw: function draw() {
    var canvas = this.vnode.state.canvas;
    var ctx = this.vnode.state.context2d;
    var ptrPos = this.vnode.state.ptrPos;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // RGB gradient
    var hGrad = ctx.createLinearGradient(0, 0, canvas.width, 0);
    hGrad.addColorStop(0 / 6, '#F00');
    hGrad.addColorStop(1 / 6, '#FF0');
    hGrad.addColorStop(2 / 6, '#0F0');
    hGrad.addColorStop(3 / 6, '#0FF');
    hGrad.addColorStop(4 / 6, '#00F');
    hGrad.addColorStop(5 / 6, '#F0F');
    hGrad.addColorStop(6 / 6, '#F00');
    ctx.fillStyle = hGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    //Fade to black gradient
    var vGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    vGrad.addColorStop(0, 'rgba(0,0,0,0)');
    vGrad.addColorStop(1, 'rgba(0,0,0,1)');
    ctx.fillStyle = vGrad;

    // Draw the selection pointer
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ptrPos.x - 10, ptrPos.y);
    ctx.lineTo(ptrPos.x - 3, ptrPos.y);
    ctx.stroke();
    ctx.beginPath();
    ctx.strokeStyle = 'white';
    ctx.moveTo(ptrPos.x - 3, ptrPos.y);
    ctx.lineTo(ptrPos.x - 1, ptrPos.y);
    ctx.moveTo(ptrPos.x + 1, ptrPos.y);
    ctx.lineTo(ptrPos.x + 3, ptrPos.y);
    ctx.stroke();
    ctx.beginPath();
    ctx.strokeStyle = 'black';
    ctx.moveTo(ptrPos.x + 3, ptrPos.y);
    ctx.lineTo(ptrPos.x + 10, ptrPos.y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ptrPos.x, ptrPos.y - 10);
    ctx.lineTo(ptrPos.x, ptrPos.y - 3);
    ctx.stroke();
    ctx.beginPath();
    ctx.strokeStyle = 'white';
    ctx.moveTo(ptrPos.x, ptrPos.y - 3);
    ctx.lineTo(ptrPos.x, ptrPos.y - 1);
    ctx.moveTo(ptrPos.x, ptrPos.y + 1);
    ctx.lineTo(ptrPos.x, ptrPos.y + 3);
    ctx.stroke();
    ctx.beginPath();
    ctx.strokeStyle = 'black';
    ctx.moveTo(ptrPos.x, ptrPos.y + 3);
    ctx.lineTo(ptrPos.x, ptrPos.y + 10);
    ctx.stroke();
  },

  /**
   *
   * @param evt
   * @returns {boolean}
   */

  handleGesture: function handleGesture(evt) {
    if (evt.type.match(this._gestureRegex.tap) || evt.type.match(this._gestureRegex.pan)) {
      var point = pageToCanvas(evt, this.vnode.state.canvas);
      this._locationChange(point);
    }
    return true;
  },

  /**
   *
   * @param evt
   * @private
   */

  _locationChange: function _locationChange(evt) {
    var hueValue = this.vnode.state.info.colors.hueValueColor;
    this.vnode.state.ptrPos = {
      x: evt.x,
      y: evt.y
    };
    var hsv = this._hsvFromPos(this.vnode.state.ptrPos);
    hueValue[0] = hsv[0];
    hueValue[2] = hsv[2];
    if (!hueValue[1]) {
      hueValue[1] = 100;
    }
    this._changeColor();
  },
  /**
   *
   * @private
   */

  _changeColor: function _changeColor() {
    //PubSub to alert the Saturation slider that the position has changed
    //order is passed to not update *every* color selector
    //Can be removed, but using PubSub means dynamic response from other forms
    pubsub.publish('hueValue', { color: this.vnode.state.colors, order: this.vnode.state.info.order });
    this.draw();
  },

  /**
   *
   * @param hsv
   * @returns {{x: number, y: number}}
   * @private
   */

  _posFromHsv: function _posFromHsv(hsv) {
    // Math.round to avoid annoying sub-pixel rendering
    hsv[0] = Math.max(0, Math.min(360, hsv[0]));
    hsv[2] = Math.max(0, Math.min(100, hsv[2]));
    return {
      x: parseFloat(hsv[0] / 360) * this.vnode.state.canvas.width,
      y: (1 - hsv[2] / 100) * this.vnode.state.canvas.height
    };
  },

  /**
   *
   * @param pos
   * @returns {*[]}
   * @private
   */

  _hsvFromPos: function _hsvFromPos(pos) {
    var h = Math.max(0, pos.x * 360 / this.vnode.state.canvas.width);
    var s = 100;
    var l = 100 * (1 - pos.y / this.vnode.state.canvas.height);
    return [h, s, l];
  }
};
/**
 *
 * @type {{oncreate: SaturationSelector.oncreate, onupdate: SaturationSelector.onupdate, view: SaturationSelector.view, draw: SaturationSelector.draw, handleGesture: SaturationSelector.handleGesture, _changeColor: SaturationSelector._changeColor, _hueUpdated: SaturationSelector._hueUpdated, _posFromHsv: SaturationSelector._posFromHsv, _sFromPos: SaturationSelector._sFromPos}}
 */

var SaturationSelector = {
  /**
   *
   * @param vnode
   */

  oncreate: function oncreate(vnode) {
    var _this = this;

    vnode.dom.mithrilComponent = this;
    this.vnode = vnode;
    vnode.state = vnode.attrs;
    vnode.state.canvas = this.el = vnode.dom;
    vnode.state.context2d = vnode.dom.getContext('2d');
    if (!vnode.state.info.colors.hueValueColor[1]) {
      vnode.context2d.fillStyle = vnode.state.info.colors.baseColor;
      //use the context to convert the original color into a hex string
      //avoiding needing to parse html color words
      vnode.state.info.colors.hueValueColor[1] = rgbToHsv(hexToRgb(vnode.state.context2d.fillStyle))[1];
    }
    vnode.state.ptrPos = this._posFromHsv(vnode.state.info.colors.hueValueColor);
    this._gestureRegex = {
      pan: new RegExp('^pan'),
      tap: new RegExp('^tap')
    };
    pubsub.subscribe('hueValue', function (msg, data) {
      if (data.order === vnode.state.info.order) _this._hueUpdated(data.color);
    });
    this._gestureRegex = {
      pan: new RegExp('^pan'),
      tap: new RegExp('^tap')
    };
    this.draw();
  },

  /**
   *
   * @param vnode
   */

  onupdate: function onupdate(vnode) {
    vnode.state.ptrPos = vnode.dom.mithrilComponent._posFromHsv(vnode.state.info.colors.hueValueColor);
    pubsub.publish('satUpdated', { order: vnode.state.info.order, currentColors: vnode.state.info.colors }); // keeps hex value in sync
    vnode.dom.mithrilComponent.draw();
  },

  /**
   * mithril component render method
   * @returns {*}
   */

  view: function view() {
    // store these bounds, for checking in drawLazily()
    return mithril('canvas#color-canvas-sat', {
      style: 'margin-left:10px; width: 20; height: 100;',
      width: 20,
      height: 100
    });
  },

  /**
   *
   */

  draw: function draw() {
    var canvas = this.vnode.state.canvas;
    var ctx = this.vnode.state.context2d;
    var ptrPos = this.vnode.state.ptrPos;
    // clear and redraw gradient slider for current picked HueValue color;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    var grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    var hueValueColor = this.vnode.state.info.colors.hueValueColor;
    var rgbStart = hsvToRgb([hueValueColor[0], 100, hueValueColor[2]]).map(function (color) {
      return Math.floor(color);
    });
    var rgbStop = hsvToRgb([hueValueColor[0], 0, hueValueColor[2]]).map(function (color) {
      return Math.floor(color);
    });
    grad.addColorStop(0, 'rgba(' + rgbStart[0] + ',' + rgbStart[1] + ',' + rgbStart[2] + ',1)');
    grad.addColorStop(1, 'rgba(' + rgbStop[0] + ',' + rgbStop[1] + ',' + rgbStop[2] + ',1)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // draw slider pointer
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.strokeStyle = 'white';
    ctx.moveTo(canvas.width, ptrPos + 5);
    ctx.lineTo(canvas.width / 2, ptrPos);
    ctx.lineTo(canvas.width, ptrPos - 5);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  },

  /**
   *
   * @param evt
   * @returns {boolean}
   */

  handleGesture: function handleGesture(evt) {
    if (evt.type.match(this._gestureRegex.tap) || evt.type.match(this._gestureRegex.pan)) {
      var point = pageToCanvas(evt, this.vnode.state.canvas);
      this._changeColor(point);
    }
    return true;
  },

  /**
   *
   * @param evt
   * @private
   */

  _changeColor: function _changeColor(evt) {
    this.vnode.state.ptrPos = evt.y;
    this.vnode.state.info.colors.hueValueColor[1] = this._sFromPos(this.vnode.state.ptrPos);
    this._hueUpdated(this.vnode.state.info.colors);
  },

  /**
   *
   * @private
   */

  _hueUpdated: function _hueUpdated() {
    pubsub.publish('satUpdated', { order: this.vnode.state.info.order, currentColors: this.vnode.state.info.colors });
    this.draw();
  },

  /**
   *
   * @param hsv
   * @returns {number}
   * @private
   */

  _posFromHsv: function _posFromHsv(hsv) {
    return Math.round((1 - hsv[1] / 100) * this.vnode.state.canvas.height);
  },

  /**
   *
   * @param pos
   * @returns {number}
   * @private
   */

  _sFromPos: function _sFromPos(pos) {
    return 100 * (1 - pos / this.vnode.state.canvas.height);
  }
};

/**
 *
 * @type {{oncreate: ColorPreview.oncreate, onupdate: ColorPreview.onupdate, view: ColorPreview.view, draw: ColorPreview.draw}}
 */

var ColorPreview = {

  /**
   *
   * @param vnode
   */

  oncreate: function oncreate(vnode) {
    var _this2 = this;

    this.order = vnode.attrs.info.order;
    this.colors = vnode.attrs.info.colors;
    this.canvas = this.el = vnode.dom;
    this.context2d = this.canvas.getContext('2d');
    pubsub.subscribe('satUpdated', function (msg, data) {
      if (_this2.order === data.order) {
        var fillColor = hsvToRgb(data.currentColors.hueValueColor).map(function (color) {
          return Math.floor(color);
        });
        _this2.context2d.fillStyle = 'rgba(' + fillColor[0] + ',' + fillColor[1] + ',' + fillColor[2] + ',1)';
        _this2.colors.currentColor = _this2.context2d.fillStyle;
        _this2.draw();
      }
    });
    this.draw();
  },

  /**
   * mithril lifecycle method
   *
   */

  onupdate: function onupdate() {
    this.draw();
  },

  /**
   * mithril component render method
   * @returns {*}
   */

  view: function view() {
    return mithril('canvas#color-canvas-preview', {
      style: 'margin-left:10px; width: 20; height: 100;',
      width: 20,
      height: 100
    });
  },

  /**
   *
   */

  draw: function draw() {
    var ctx = this.context2d;
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    ctx.fillStyle = this.colors.currentColor;
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);
  }
};

/**
 * Use currently selected color
 * @type {{view: ColorApplyButton.view}}
 */

var ColorApplyButton = {

  /**
   * mithril component render method
   * @param vnode
   * @returns {*}
   */

  view: function view(vnode) {
    // store these bounds, for checking in drawLazily()
    return mithril('button.approve-button', {
      style: 'display:block; width:100%;',
      onclick: function onclick() {
        vnode.attrs.info.colors.baseColor = vnode.attrs.info.colors.currentColor;
        vnode.attrs.info.colors.hueValueColor = rgbToHsv(hexToRgb(vnode.attrs.info.colors.baseColor));
        vnode.attrs.settings.nodeColor[vnode.attrs.info.order] = vnode.attrs.info.colors.baseColor;
        pubsub.publish('satUpdated', { order: vnode.attrs.info.order, currentColors: vnode.attrs.info.colors });
      }
    }, 'Apply');
  }
};

/**
 * Reset color to prior
 * @type {{view: ColorResetButton.view}}
 */

var ColorResetButton = {

  /**
   * mithril component render method
   * @param vnode
   * @returns {*}
   */

  view: function view(vnode) {
    // store these bounds, for checking in drawLazily()
    return mithril('button.reset-button', {
      style: 'display:block; width:100%',
      onclick: function onclick() {
        vnode.attrs.info.colors.currentColor = vnode.attrs.info.colors.baseColor;
        vnode.attrs.info.colors.hueValueColor = rgbToHsv(hexToRgb(vnode.attrs.info.colors.baseColor));
        pubsub.publish('satUpdated', { order: vnode.attrs.info.order, currentColors: vnode.attrs.info.colors });
      }
    }, 'Reset');
  }
};

/**
 * Text Box to find color
 * @type {{oninit: ColorBox.oninit, view: ColorBox.view, handleGesture: ColorBox.handleGesture}}
 */

var ColorBox = {

  /**
   *
   * @param vnode
   */

  oninit: function oninit(vnode) {
    var _this3 = this;

    this.canvas = this.el = vnode.dom;
    this.order = vnode.attrs.info.order;
    vnode.state.value = vnode.attrs.info.colors.currentColor;
    pubsub.subscribe('satUpdated', function (msg, data) {
      if (_this3.order === data.order) {
        vnode.dom.value = vnode.attrs.info.colors.currentColor;
      }
    });
  },

  /**
   * mithril component render method
   * @param vnode
   * @returns {*}
   */

  view: function view(vnode) {
    // store these bounds, for checking in drawLazily()
    return mithril('input[type=text].color-input', {
      style: 'display:block; width:100%;',
      oninput: mithril.withAttr('value', function (value) {
        try {
          var code = value.match(/^#?([a-f\d]*)$/i);
          var str = code[1];
          if (code[1].length === 3) {
            str = '#' + str[0] + str[0] + str[1] + str[1] + str[2] + str[2];
          }
          vnode.attrs.info.colors.currentColor = value;
          vnode.attrs.info.colors.hueValueColor = rgbToHsv(hexToRgb(str));
        } catch (e) {
          // expect this to fail silently, as most typing will not actually give
          // a proper hex triplet/sextet
        }
      })
    });
  },

  /**
   *
   * @returns {boolean}
   */

  handleGesture: function handleGesture() {
    return true;
  }
};

/**
 * convert hex triplet to RGB
 * #FFFFFF ->[0-255,0-255,0-255]
 * @param hex
 * @returns {*[]}
 */

function hexToRgb(hex) {
  var result = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
  return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];
}

/**
 *  convert RGB triplet to hex
 * [0-255,0-255,0-255] -> #FFFFFF
 * @param rgb
 * @returns {string}
 */



/**
 * Convert RGB triplet ot HSV
 * [0-255,0-255,0-255] -> [0-360,0-100,0-100]
 * @param rgb
 * @returns {*[]}
 */

function rgbToHsv(rgb) {
  //make sure RGB values are within 0-255 range
  //and convert to decimal
  rgb = rgb.map(function (component) {
    return Math.max(0, Math.min(255, component)) / 255;
  });

  // Conversion from RGB -> HSV colorspace

  var cmin = Math.min(Math.min(rgb[0], rgb[1]), rgb[2]);
  var cmax = Math.max(Math.max(rgb[0], rgb[1]), rgb[2]);
  var delta = parseFloat(cmax - cmin);
  var hue = 0;
  if (delta === 0) {
    hue = 0;
  } else if (cmax === rgb[0]) {
    hue = 60 * ((rgb[1] - rgb[2]) / delta);
  } else if (cmax === rgb[1]) {
    hue = 60 * ((rgb[2] - rgb[0]) / delta + 2);
  } else if (cmax === rgb[2]) {
    hue = 60 * ((rgb[0] - rgb[1]) / delta + 4);
  }
  if (hue < 0) hue += 360;
  var sat = cmax === 0 ? 0 : delta / cmax * 100;
  var value = cmax * 100;

  return [hue, sat, value];
}

/**
 * Convert from HSV to RGB
 * [0-360,0-100,0-100] -> [0-255,0-255,0-255]
 * @param hsv
 * @returns {*[]}
 */

function hsvToRgb(hsv) {
  var u = 255 * (hsv[2] / 100);
  var h = hsv[0] / 60;
  var s = hsv[1] / 100;

  var i = Math.floor(h);
  if (i < 0) i = 0;
  var f = i % 2 ? h - i : 1 - (h - i);
  var m = u * (1 - s);
  var n = u * (1 - s * f);
  switch (i) {
    case 6:
    case 0:
      return [u, n, m];
    case 1:
      return [n, u, m];
    case 2:
      return [m, u, n];
    case 3:
      return [m, n, u];
    case 4:
      return [n, m, u];
    case 5:
      return [u, m, n];
  }
}

/**
 * FeatureMenu
 * Mithril component for a modal dialog to edit track/subtrack settings
 **/
var FeatureMenu =
/**
 *
 * @param data
 * @param order
 */

function FeatureMenu(data, order) {
  classCallCheck(this, FeatureMenu);

  // Setup modal position based on current placement of the actual map
  // layout viewport. keeps things self-contained when embedding.
  var viewport = document.getElementById('cmap-menu-viewport');
  var layoutBounds = document.getElementById('cmap-layout-viewport').getBoundingClientRect();
  document.getElementById('cmap-layout-viewport').style.visibility = 'hidden';
  viewport.style.display = 'block';
  viewport.style.position = 'absolute';
  viewport.style.top = layoutBounds.top + 'px';
  viewport.style.left = layoutBounds.left + 'px';
  viewport.style.width = '95%';
  viewport.style.height = layoutBounds.height + 'px';
  // Setup track and subtrack data
  var model = data.model || data.component.model;
  var tagList = model.tags.sort();
  var settings = model.tracks[order] ? data.config : model.config.qtl;
  if (typeof settings.fillColor === 'string') {
    settings.fillColor = [settings.fillColor];
  }
  var trackGroups = [];
  var filters = settings.filters ? settings.filters.slice() : [tagList[0].slice()];
  var fillColor = settings.fillColor ? settings.fillColor.slice() : ['aqua'];
  if (typeof fillColor === 'string') {
    fillColor = [fillColor];
  }

  if (!settings.filters) {
    settings.filters = filters;
  }
  if (!settings.fillColor) {
    settings.fillColor = fillColor;
  }
  if (!settings.title) {
    settings.title = filters[0];
  }

  var defaultSettings = {
    filters: settings.filters.slice(),
    fillColor: settings.fillColor.slice(),
    title: settings.title.slice()
  };

  settings.position = data.position;

  var selected = filters.map(function (item) {
    return {
      name: item,
      index: tagList.indexOf(item)
    };
  });

  var trackConfig = {
    model: model,
    tagList: tagList,
    settings: settings,
    selected: selected,
    trackGroups: trackGroups
  };

  //Attach components to viewport, in general these are the close button (x in top
  //right), the actual modal contents, and the apply/close/delete button bar
  var controls = [mithril(_applyButton, {
    model: model,
    config: settings,
    order: order,
    bioMapIndex: model.component.bioMapIndex,
    reset: defaultSettings,
    newData: selected
  }), mithril(_cancelButton, { model: model, config: settings, order: order, reset: defaultSettings })];

  if (order < model.tracks.length) {
    controls.push(mithril(_removeButton, {
      order: order,
      model: model,
      bioMapIndex: model.component.bioMapIndex
    }));
  }

  // Build menu mithril component, then mount
  var modalDiv = {
    oncreate: function oncreate(vnode) {
      vnode.dom.mithrilComponent = this; // Without this and handleGesture, clicks in modal will pass through to the underlying view
    },
    view: function view() {
      return mithril('div', { style: 'height:100%; width:100%' }, [mithril(CloseButton, { model: model, config: settings, order: order, reset: defaultSettings }), mithril(TitleBox, { settings: settings }), mithril(TrackMenu, { info: trackConfig, count: 0 }), mithril('div', { style: 'text-align:center' }, controls)]);
    },
    handleGesture: function handleGesture() {
      return true;
    }
  };
  mithril.mount(document.getElementById('cmap-menu-viewport'), modalDiv);
};

/**
 *
 * @type {{view: _removeButton.view}}
 * @private
 */

var _removeButton = {

  /**
   *
   * @param vnode
   * @returns {*}
   */

  view: function view(vnode) {
    return mithril('button', {
      onclick: function onclick() {
        vnode.attrs.model.tracks.splice(vnode.attrs.order, 1);
        pubsub.publish(featureUpdate, { mapIndex: vnode.attrs.bioMapIndex });
        mithril.redraw();
        closeModal();
      },
      style: 'background:red'
    }, 'Remove Track');
  }
};

var TitleBox = {
  /**
   *
   * @param vnode
   * @returns {*}
   */
  oninit: function oninit(vnode) {
    vnode.state.value = vnode.attrs.settings.title;
  },
  view: function view(vnode) {
    return mithril('div', {}, 'Track title: ', mithril('input[type=text].title-input', {
      style: 'display:block; width:10%;',
      defaultValue: vnode.attrs.settings.title,
      oninput: mithril.withAttr('value', function (value) {
        try {
          vnode.attrs.settings.title = value;
        } catch (e) {
          // expect this to fail silently, as most typing will not actually give
          // a proper hex triplet/sextet
        }
      })
    }));
  }
};

/**
 *
 * @type {{view: _cancelButton.view}}
 * @private
 */

var _cancelButton = {

  /**
   *
   * @param vnode
   * @returns {*}
   */

  view: function view(vnode) {
    return mithril('button', {
      onclick: function onclick() {
        vnode.attrs.config.fillColor = vnode.attrs.reset.fillColor;
        vnode.attrs.config.filters = vnode.attrs.reset.filters;
        vnode.attrs.config.title = vnode.attrs.reset.title;
        if (vnode.attrs.order < vnode.attrs.model.tracks.length) {
          vnode.attrs.model.tracks[vnode.attrs.order] = vnode.attrs.config;
        }
        closeModal();
      }
    }, 'Cancel');
  }
};

/**
 *
 * @type {{view: _applyButton.view}}
 * @private
 */

var _applyButton = {

  /**
   *
   * @param vnode
   * @returns {*}
   */

  view: function view(vnode) {
    return mithril('button', {
      onclick: function onclick() {
        vnode.attrs.config.filters = vnode.attrs.newData.map(function (data) {
          return data.name;
        });
        vnode.attrs.model.tracks[vnode.attrs.order] = vnode.attrs.config;
        pubsub.publish(featureUpdate, { mapIndex: vnode.attrs.bioMapIndex });
        mithril.redraw();
        closeModal();
      }
    }, 'Apply Selection');
  }
};

/**
 * Div with simple close X
 * @type {{view: CloseButton.view}}
 */

var CloseButton = {

  /**
   *
   * @param vnode
   * @returns {*}
   */

  view: function view(vnode) {
    return mithril('div', {
      style: 'text-align:right;',
      onclick: function onclick() {
        vnode.attrs.config.fillColor = vnode.attrs.reset.fillColor;
        vnode.attrs.config.filters = vnode.attrs.reset.filters;
        vnode.attrs.config.title = vnode.attrs.reset.title;
        if (vnode.attrs.order < vnode.attrs.model.tracks.length) {
          vnode.attrs.model.tracks[vnode.attrs.order] = vnode.attrs.config;
        }
        closeModal();
      }
    }, 'X');
  }
};

/*
 * Mithril component
 * Div that contains the dropdowns and components for selecting track options
 * @type {{oninit: TrackMenu.oninit, view: TrackMenu.view}}
 */

var TrackMenu = {

  /**
   *
   * @param vnode
   */

  oninit: function oninit(vnode) {
    vnode.state = vnode.attrs;
    vnode.state.hidden = [];
    vnode.state.picker = [];
  },

  /**
   *
   * @param vnode
   * @returns {*}
   */

  view: function view(vnode) {
    var _this = this;

    var selected = vnode.state.info.selected;
    var settings = vnode.state.info.settings;
    this.count = 0;

    var dropdowns = selected.map(function (item, order) {
      if (settings.fillColor[order] === undefined) {
        settings.fillColor[order] = settings.fillColor.slice(0, 1);
      }
      if (!vnode.state.hidden[order]) {
        vnode.state.hidden[order] = 'none';
      }
      if (!vnode.state.picker[order]) {
        vnode.state.picker[order] = settings.fillColor[order] || 'orange';
      }

      var dropSettings = {
        selected: selected,
        name: settings.filters[order],
        fillColor: settings.fillColor,
        tags: vnode.state.info.tagList,
        nodeColor: vnode.state.picker
      };
      if (selected[order].index === -1) {
        selected[order].index = dropSettings.tags.indexOf(dropSettings.name);
      }
      var controls = [mithril('button', {
        onclick: function onclick() {
          selected[selected.length] = { name: vnode.state.info.tagList[0], index: 0 };
        }
      }, '+')];
      if (selected.length > 1) {
        controls.push(mithril('button', {
          onclick: function onclick() {
            selected.splice(order, 1);
          }
        }, '-'));
      }
      controls.push(mithril('button', {
        onclick: function onclick() {
          vnode.state.hidden[order] = vnode.state.hidden[order] === 'none' ? 'block' : 'none';
        }
      }, mithril('div', { style: 'color:' + vnode.state.picker[order] }, '■')));
      return [mithril(Dropdown, {
        settings: dropSettings,
        order: order,
        parentDiv: _this,
        hidden: vnode.state.hidden
      }), controls];
    });
    return mithril('div#track-select-div', {
      style: 'overflow:auto;width:100%;height:80%;'
    }, dropdowns);
  }
};

/*
 * Mithril component
 * Actual dropdown selector
 * @type {{oninit: Dropdown.oninit, onbeforeupdate: Dropdown.onbeforeupdate, view: Dropdown.view}}
 */

var Dropdown = {

  /**
   *
   * @param vnode
   */

  oninit: function oninit(vnode) {
    vnode.state = vnode.attrs;
  },
  /**
   *
   * @param vnode
   */

  onbeforeupdate: function onbeforeupdate(vnode) {
    if (vnode.state.count > vnode.attrs.parentDiv.count) {
      vnode.attrs.parentDiv.count = vnode.state.count;
    } else {
      vnode.state.count = vnode.attrs.parentDiv.count;
    }
  },

  /**
   *
   * @param vnode
   * @returns {*}
   */

  view: function view(vnode) {
    var order = vnode.state.order;
    var settings = vnode.state.settings;
    return mithril('div', mithril('select', {
      id: 'selector-' + order,
      selectedIndex: settings.selected[order].index,
      oninput: function oninput(e) {
        var selected = e.target.selectedIndex;
        settings.selected[order].name = settings.tags[selected];
        settings.selected[order].index = selected;
      }
    }, [settings.tags.map(function (tag) {
      return mithril('option', tag);
    })]), mithril(ColorPicker, { settings: vnode.state.settings, order: order, hidden: vnode.state.hidden }));
  }
};

/**
 * Function to close the menu-viewport and reshow the
 * layout viewport
 *
 */

function closeModal() {
  //reset cmap-menu-viewport vdom tree to empty state
  mithril.mount(document.getElementById('cmap-menu-viewport'), null);
  //explicitly set visibility to avoid weird page interaction issues
  document.getElementById('cmap-layout-viewport').style.visibility = 'visible';
  document.getElementById('cmap-menu-viewport').style.display = 'none';
}

/**
 *
 * Base Component, placeholder for other canvas components
 *
 */

var TitleComponent = {
  oninit: function oninit(vnode) {
    vnode.state = vnode.attrs;
    vnode.state.left = 0;
    vnode.state.domOrder = vnode.state.titleOrder.indexOf(vnode.state.order);
    vnode.state.leftBound = vnode.state.bioMaps[vnode.state.order].domBounds.left;
    vnode.state.rightBound = vnode.state.bioMaps[vnode.state.order].domBounds.right;
    vnode.state.leftStart = vnode.state.bioMaps[vnode.state.order].domBounds.left;
    vnode.state._gestureRegex = {
      pan: new RegExp('^pan')
    };
  },

  oncreate: function oncreate(vnode) {
    // register mithrilComponent for gesture handling
    vnode.dom.mithrilComponent = this;
    // register functions to state/dom for gesture handling
    vnode.dom.mithrilComponent.handleGesture = vnode.tag.handleGesture;
    vnode.state._onPan = vnode.tag._onPan;
    vnode.state.zIndex = 0;
    this.vnode = vnode;
  },

  onbeforeupdate: function onbeforeupdate(vnode) {
    vnode.state.bioMaps = vnode.attrs.bioMaps;
    if (this.titleOrder[this.domOrder] !== this.order) {
      this.domOrder = this.titleOrder.indexOf(this.order);
    }
  },

  onupdate: function onupdate(vnode) {
    var dispOffset = vnode.state.bioMaps[vnode.state.order].domBounds.left - vnode.state.leftStart;
    if (vnode.state.left !== dispOffset && !vnode.state.swap) {
      this.left = dispOffset;
      this.dirty = true;
    }
    if (vnode.state.swap) {
      this.left = 0;
      this.swap = false;
      this.dirty = true;
      this.left = 0;
    }
    if (this.dirty) {
      // trigger redraw on changed canvas that has possibly edited bounds in process of view layout
      this.dirty = false;
      mithril.redraw();
    }
  },

  view: function view(vnode) {
    if (!vnode.attrs || !vnode.state.contentBounds) return;
    var bMap = vnode.state.bioMaps[vnode.state.order];
    vnode.state.contentBounds.left = vnode.state.contentBounds.right - vnode.state.contentBounds.width;
    var left = vnode.state.left + vnode.state.contentBounds.left;
    return mithril('div', {
      class: 'swap-div', id: 'swap-' + vnode.state.domOrder,
      style: 'display:grid; position:relative; left:' + left + 'px; min-width:' + bMap.domBounds.width + 'px; z-index:' + vnode.state.zIndex + ';'
    }, [mithril('div', { class: 'map-title', style: 'display:inline-block;' }, [bMap.model.name, mithril('br'), bMap.model.source.id])]);
  },

  handleGesture: function handleGesture(evt) {
    if (evt.type.match(this._gestureRegex.pan)) {
      return this._onPan(evt);
    }
    return true;
  },

  _onPan: function _onPan(evt) {
    //Start pan move zIndex up to prevent interrupting pan early
    if (evt.type === 'panstart') {
      this.vnode.state.zIndex = 1000;
      this.lastPanEvent = null;
      this.left = 0;
    }
    //End pan to set rearrangement
    if (evt.type === 'panend') {
      this.vnode.state.zIndex = 0;
      pubsub.publish(mapReorder, null);
      return;
    }

    //Pan the title
    //Calculate map movement
    var delta = {};
    if (this.lastPanEvent) {
      delta.x = -1 * (this.lastPanEvent.deltaX - evt.deltaX);
    } else {
      delta.x = Math.round(evt.deltaX);
    }
    this.left += delta.x;

    //Setup maps and swap points
    var selLeftEdge = this.left + this.leftStart;
    //let selRightEdge = selLeftEdge + this.bioMaps[this.order].domBounds.width;
    var leftMap = this.domOrder > 0 ? this.titleOrder[this.domOrder - 1] : null;
    var rightMap = this.titleOrder[this.domOrder + 1] > -1 ? this.titleOrder[this.domOrder + 1] : null;
    var leftSwapBound = leftMap ? this.leftBound - this.bioMaps[leftMap].domBounds.width : null;
    var rightSwapBound = rightMap ? this.leftBound + this.bioMaps[rightMap].domBounds.width : null;

    if (leftMap && selLeftEdge < leftSwapBound) {
      // Swap Left
      this.leftBound -= this.bioMaps[leftMap].domBounds.width;
      this.rightBound -= this.bioMaps[leftMap].domBounds.width;

      this.titleOrder[this.domOrder] = this.titleOrder[this.domOrder - 1]; //= this.titleOrder[rightMap];
      this.titleOrder[this.domOrder - 1] = this.order;
      this.domOrder = this.titleOrder[this.domOrder];
    } else if (rightMap && selLeftEdge > rightSwapBound) {
      // Swap Right
      this.leftBound += this.bioMaps[rightMap].domBounds.width;
      this.rightBound += this.bioMaps[rightMap].domBounds.width;

      this.titleOrder[this.domOrder] = this.titleOrder[this.domOrder + 1]; //= this.titleOrder[rightMap];
      this.titleOrder[this.domOrder + 1] = this.order;
      this.domOrder = this.titleOrder[this.domOrder];
    } else if (!(!leftMap && selLeftEdge <= 0) && !(!rightMap && selLeftEdge > this.leftBound)) {
      //Move current map and its left/right partner

      var movedMap = rightMap;

      if (selLeftEdge < this.leftBound || selLeftEdge === this.leftBound && delta.x < 0) {
        movedMap = leftMap;
      }

      var shiftScale = this.bioMaps[this.order].domBounds.width / this.bioMaps[movedMap].domBounds.width;
      this.bioMaps[this.order].domBounds.left += delta.x;
      this.bioMaps[this.order].domBounds.right += delta.x;
      var mw = this.bioMaps[movedMap].domBounds.width;
      this.bioMaps[movedMap].domBounds.left -= delta.x * shiftScale;
      this.bioMaps[movedMap].domBounds.right = this.bioMaps[movedMap].domBounds.left + mw;
    } else {
      // edge case don't move map
      this.left -= delta.x;
    }

    this.lastPanEvent = evt;
    mithril.redraw();
    return true;
  }
};

/**
 *
 * Base Component, placeholder for other canvas components
 *
 */

//import {Bounds} from '../../../model/Bounds';

var BioMapComponent = function () {
  function BioMapComponent(vnode) {
    classCallCheck(this, BioMapComponent);

    console.log(vnode);
  }

  createClass(BioMapComponent, [{
    key: 'oncreate',
    value: function oncreate(vnode) {
      //have state be tied to passed attributes
      vnode.state = vnode.attrs;

      //dom components and state
      vnode.state.canvas = vnode.state.bioMap.canvas = vnode.dom;
      vnode.state.domBounds = vnode.state.bioMap.domBounds;
      vnode.state.context2d = vnode.state.bioMap.context2d = vnode.state.canvas.getContext('2d');
      vnode.state.context2d.imageSmoothingEnabled = false;

      //setup vnode.dom for ui gesture handling
      vnode.dom.mithrilComponent = this;

      //store vnode to be able to access state for non mithril lifecycle commands
      this.vnode = vnode;
    }
  }, {
    key: 'onupdate',
    value: function onupdate(vnode) {
      //redraw biomap if dirty (drawing has changed, instead of just changing position)
      if (vnode.state.bioMap.dirty === true) {
        vnode.state.context2d.clearRect(0, 0, vnode.state.canvas.width, vnode.state.canvas.height);
        vnode.state.bioMap.draw();
      }
    }
  }, {
    key: 'view',
    value: function view(vnode) {
      // store these bounds, for checking in drawLazily()
      var domBounds = vnode.state.domBounds || null;
      if (domBounds && !domBounds.isEmptyArea) {
        this.lastDrawnMithrilBounds = domBounds;
      }
      var b = domBounds || {};
      var selectedClass = vnode.state.selected ? 'selected' : '';
      return mithril('canvas', {
        class: 'cmap-canvas cmap-biomap ' + selectedClass,
        style: 'left: ' + b.left + 'px; top: ' + b.top + 'px;\n               width: ' + b.width + 'px; height: ' + b.height + 'px;\n               transform: rotate(' + vnode.state.rotation + 'deg);',
        width: b.width,
        height: b.height
      });
    }
  }, {
    key: 'handleGesture',
    value: function handleGesture(evt) {
      var state = this.vnode.state;
      if (state.bioMap.handleGesture(evt)) {
        state.bioMap.dirty = true;
        return true;
      }
      return false;
    }
  }]);
  return BioMapComponent;
}();

/**
 * HorizontalLayout (left to right)
 * A mithril component for horizontal layout of BioMaps.
 */
var HorizontalLayout = function (_mix$with) {
  inherits(HorizontalLayout, _mix$with);

  function HorizontalLayout() {
    classCallCheck(this, HorizontalLayout);
    return possibleConstructorReturn(this, (HorizontalLayout.__proto__ || Object.getPrototypeOf(HorizontalLayout)).apply(this, arguments));
  }

  createClass(HorizontalLayout, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril lifecycle method
     * @param vnode
     */

    value: function oninit(vnode) {
      var _this2 = this;

      get(HorizontalLayout.prototype.__proto__ || Object.getPrototypeOf(HorizontalLayout.prototype), 'oninit', this).call(this, vnode);
      this.contentBounds = vnode.attrs.contentBounds;
      this.vnode = vnode;
      this.bioMapComponents = [];
      this.correspondenceMapComponents = [];
      this.popoverComponents = [];
      this.swapComponents = [];
      this.featureControls = [];
      this.modal = [];
      this.bioMapOrder = [];
      this.test = 0;
      var handler = function handler() {
        return _this2._onDataLoaded();
      };
      this.subscriptions = [
      // all of these topics have effectively the same event handler for
      // the purposes of horizontal layout.
      pubsub.subscribe(dataLoaded, handler), pubsub.subscribe(mapRemoved, handler), pubsub.subscribe(mapAdded, handler), pubsub.subscribe(reset, function () {
        _this2._onReset();
      }), pubsub.subscribe(featureUpdate, function (msg, data) {
        _this2._onFeatureUpdate(data);
      }), pubsub.subscribe(mapReorder, function () {
        _this2._onReorder();
      })];
    }

    /**
     *
     * @param vnode
     */

  }, {
    key: 'onupdate',
    value: function onupdate(vnode) {
      this.contentBounds = vnode.attrs.contentBounds;
    }

    /**
     * mithril lifecycle method
     */

  }, {
    key: 'onremove',
    value: function onremove() {
      this.subscriptions.forEach(function (token) {
        return pubsub.unsubscribe(token);
      });
    }

    /**
     * mithril component render method
     * @returns {*} mithril vnode
     */

  }, {
    key: 'view',
    value: function view() {
      var _this3 = this;

      //m.mount(document.getElementById('cmap-layout-titles'),null);
      // let mo = this.bioMapOrder.map(i => {
      //   return this.bioMapComponents[i];
      // });
      return mithril('div.cmap-layout-horizontal', [//this.swapComponents,
      this.correspondenceMapComponents.map(mithril), this.bioMapOrder.map(function (i) {
        return mithril(BioMapComponent, { bioMap: _this3.bioMapComponents[i] });
      }), this.featureControls,
      //this.modal.map(modal =>{ return m(modal,{info:modal.info, bounds: modal.bounds, order:modal.order}); }),
      this.popoverComponents.map(function (popover) {
        return mithril(popover, { info: popover.info, domBounds: popover.domBounds });
      })]);
    }

    /**
     * pub/sub event handler
     *
     * @private
     */

  }, {
    key: '_onDataLoaded',
    value: function _onDataLoaded() {
      this._layoutBioMaps();
      this._layoutSwapComponents();
      this._layoutFeatureControls();
      this._layoutCorrespondenceMaps();
      this._layoutPopovers();
      mithril.redraw();
    }

    /**
     *
     * @private
     */

  }, {
    key: '_onReorder',
    value: function _onReorder() {
      var left = 0;
      var bmaps = this.bioMapComponents;
      var sc = this.bioMapOrder;
      bmaps.forEach(function (comp) {
        comp.dirty = true;
      });
      for (var i = 0; i < bmaps.length; i++) {
        var map = bmaps[sc[i]];
        //const mapC = bmaps[sc[i]].domBounds;
        var mw = map.domBounds.width;
        map.domBounds.left = left;
        map.domBounds.right = left + mw;
        left = map.domBounds.right;
      }
      this._layoutCorrespondenceMaps();
      this._layoutFeatureControls();
      mithril.mount(document.getElementById('cmap-layout-titles'), null);
      mithril.redraw();
      this._layoutSwapComponents();
    }

    /**
     *
     * @private
     */

  }, {
    key: '_layoutSwapComponents',
    value: function _layoutSwapComponents() {
      this.swapComponents = [];
      var sc = this.bioMapOrder;
      var maps = this;
      var cb = this.contentBounds;
      //let bmaps = this.bioMapComponents;
      var pan = [];
      pan[0] = false;
      mithril.mount(document.getElementById('cmap-layout-titles'), {
        view: function view() {
          return sc.map(function (order) {
            return mithril(TitleComponent, {
              bioMaps: maps.bioMapComponents,
              order: order,
              titleOrder: sc,
              contentBounds: cb,
              pan: pan
            });
          });
        }
      });
    }

    /**
     *
     * @private
     */

  }, {
    key: '_layoutFeatureControls',
    value: function _layoutFeatureControls() {
      var _this4 = this;

      this.featureControls = [];
      //let n = this.bioMapComponents.length;
      //let maps = this;
      this.bioMapComponents.forEach(function (component) {
        component.children.forEach(function (child) {
          if (child instanceof FeatureTrack) {
            var _loop = function _loop(i) {
              if (child.children[i].bounds.width > 0) {
                var featureGroup = child.children[i];
                _this4.featureControls.push(mithril('div', {
                  class: 'feature-title',
                  id: 'feature-' + component.model.name + '-' + i,
                  style: 'position:absolute; left: ' + Math.floor(component.domBounds.left + featureGroup.globalBounds.left) + 'px; \n                      top: ' + component.domBounds.top + 'px; width: ' + featureGroup.globalBounds.width + 'px;',
                  onclick: function onclick() {
                    var info = child.children[i];
                    info.position = child.trackPos;
                    new FeatureMenu(info, child.children[i].config.tracksIndex);
                  }
                }, featureGroup.title));
              }
            };

            for (var i = 0; i < child.children.length; i++) {
              _loop(i);
            }
            // push controller to add new track
            _this4.featureControls.push(mithril('div', {
              class: 'feature-title',
              id: 'feature-' + component.model.name + '-new',
              style: 'position:absolute; left: ' + Math.floor(component.domBounds.left + child.globalBounds.right + 20) + 'px; \n                      top: ' + component.domBounds.top + 'px; width: 20px;',
              onclick: function onclick() {
                var info = component.model;
                info.position = child.trackPos;
                var order = child.model.tracks.length;
                new FeatureMenu(info, order);
              }
            }, '+'));
          }
        });
      });
    }

    /**
     * Horizontal (left to right) layout of BioMaps
     *
     * @returns {Array}
     * @private
     */

  }, {
    key: '_layoutBioMaps',
    value: function _layoutBioMaps() {
      var _this5 = this;

      if (!this.bounds) return []; // early out if the layout bounds is unknown
      var n = this.appState.bioMaps.length;
      var padding = Math.floor(this.bounds.width * 0.1 / n);
      padding = 0; // TODO: decide whether to add padding between the biomaps
      var childHeight = Math.floor(this.bounds.height * 0.95);
      var cursor = Math.floor(padding * 0.5);
      this.bioMapComponents = this.appState.bioMaps.map(function (model, mapIndex) {
        _this5.bioMapOrder.push(mapIndex);
        var layoutBounds = new Bounds({
          left: cursor,
          top: 10,
          width: Math.floor(_this5.bounds.width), // will be calculated by bioMap
          height: childHeight
        });
        var component = new BioMap({
          bioMapModel: model,
          layoutBounds: layoutBounds,
          appState: _this5.appState,
          bioMapIndex: mapIndex,
          initialView: _this5.appState.initialView[mapIndex]
        });
        model.component = component; // save a reference for mapping model -> component
        cursor += component.domBounds.width + padding;
        return component;
      });
    }

    /**
     *
     * @private
     */

  }, {
    key: '_layoutPopovers',
    value: function _layoutPopovers() {
      this.popoverComponents = this.bioMapComponents.map(function (model) {
        var component = new Popover();
        component.info = model.info;
        component.domBounds = model.domBounds;
        return component;
      });
    }

    /**
     * Horizontal layout of Correspondence Maps. In this layout, for N maps there
     * are N -1 correspondence maps.
     * @returns {Array}
     * @private
     */

  }, {
    key: '_layoutCorrespondenceMaps',
    value: function _layoutCorrespondenceMaps() {
      if (!this.bounds) return []; // early out if our canvas bounds is unknown
      var childHeight = Math.floor(this.bounds.height * 0.95);
      var n = this.bioMapComponents.length;
      this.correspondenceMapComponents = [];
      for (var i = 0; i < n - 1; i++) {
        var left = this.bioMapComponents[i];
        var right = this.bioMapComponents[i + 1];
        var layoutBounds = new Bounds({
          left: Math.floor(left.domBounds.left + left.backbone.globalBounds.right),
          right: Math.floor(right.domBounds.left + right.backbone.globalBounds.left),
          top: 10,
          height: childHeight
        });
        var component = new CorrespondenceMap({
          bioMapComponents: [left, right],
          appState: this.appState,
          layoutBounds: layoutBounds
        });
        this.correspondenceMapComponents.push(component);
      }
    }

    /**
     * Reset local zoom here. Easier to iterate through base element
     * and redraw components once from the base layout than deal with
     * it through the individual components.
     * (Difficulty in reaching the mithril component to get canvas context)
     * @private
     */

  }, {
    key: '_onReset',
    value: function _onReset() {
      this.bioMapComponents.forEach(function (item) {
        item.model.view.visible = item.model.view.base;
        item.verticalScale = 1.0;
        item.info.visible = 'hidden';
      });
      [].forEach.call(document.getElementsByClassName('cmap-canvas'), function (el) {
        el.mithrilComponent.draw();
      });
      mithril.redraw();
    }

    /**
     *
     * @param data
     * @private
     */

  }, {
    key: '_onFeatureUpdate',
    value: function _onFeatureUpdate(data) {
      //this._onDataLoaded();
      this.bioMapComponents[data.mapIndex]._layout();
      mithril.redraw();
      this._onReorder();
    }
  }]);
  return HorizontalLayout;
}(mix(LayoutBase).with(RegisterComponentMixin));

var papaparse = createCommonjsModule(function (module, exports) {
/*@license
	Papa Parse
	v4.4.0
	https://github.com/mholt/PapaParse
	License: MIT
*/
(function(root, factory)
{
	/* globals define */
	if (typeof undefined === 'function' && undefined.amd)
	{
		// AMD. Register as an anonymous module.
		undefined([], factory);
	}
	else {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	}
}(commonjsGlobal, function()
{
	'use strict';

	var global = (function() {
		// alternative method, similar to `Function('return this')()`
		// but without using `eval` (which is disabled when
		// using Content Security Policy).

		if (typeof self !== 'undefined') { return self; }
		if (typeof window !== 'undefined') { return window; }
		if (typeof global !== 'undefined') { return global; }

		// When running tests none of the above have been defined
		return {};
	})();


	var IS_WORKER = !global.document && !!global.postMessage,
		IS_PAPA_WORKER = IS_WORKER && /(\?|&)papaworker(=|&|$)/.test(global.location.search),
		LOADED_SYNC = false, AUTO_SCRIPT_PATH;
	var workers = {}, workerIdCounter = 0;

	var Papa = {};

	Papa.parse = CsvToJson;
	Papa.unparse = JsonToCsv;

	Papa.RECORD_SEP = String.fromCharCode(30);
	Papa.UNIT_SEP = String.fromCharCode(31);
	Papa.BYTE_ORDER_MARK = '\ufeff';
	Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
	Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;
	Papa.SCRIPT_PATH = null;	// Must be set by your code if you use workers and this lib is loaded asynchronously

	// Configurable chunk sizes for local and remote files, respectively
	Papa.LocalChunkSize = 1024 * 1024 * 10;	// 10 MB
	Papa.RemoteChunkSize = 1024 * 1024 * 5;	// 5 MB
	Papa.DefaultDelimiter = ',';			// Used if not specified and detection fails

	// Exposed for testing and development only
	Papa.Parser = Parser;
	Papa.ParserHandle = ParserHandle;
	Papa.NetworkStreamer = NetworkStreamer;
	Papa.FileStreamer = FileStreamer;
	Papa.StringStreamer = StringStreamer;
	Papa.ReadableStreamStreamer = ReadableStreamStreamer;

	if (global.jQuery)
	{
		var $ = global.jQuery;
		$.fn.parse = function(options)
		{
			var config = options.config || {};
			var queue = [];

			this.each(function(idx)
			{
				var supported = $(this).prop('tagName').toUpperCase() === 'INPUT'
								&& $(this).attr('type').toLowerCase() === 'file'
								&& global.FileReader;

				if (!supported || !this.files || this.files.length === 0)
					return true;	// continue to next input element

				for (var i = 0; i < this.files.length; i++)
				{
					queue.push({
						file: this.files[i],
						inputElem: this,
						instanceConfig: $.extend({}, config)
					});
				}
			});

			parseNextFile();	// begin parsing
			return this;		// maintains chainability


			function parseNextFile()
			{
				if (queue.length === 0)
				{
					if (isFunction(options.complete))
						options.complete();
					return;
				}

				var f = queue[0];

				if (isFunction(options.before))
				{
					var returned = options.before(f.file, f.inputElem);

					if (typeof returned === 'object')
					{
						if (returned.action === 'abort')
						{
							error('AbortError', f.file, f.inputElem, returned.reason);
							return;	// Aborts all queued files immediately
						}
						else if (returned.action === 'skip')
						{
							fileComplete();	// parse the next file in the queue, if any
							return;
						}
						else if (typeof returned.config === 'object')
							f.instanceConfig = $.extend(f.instanceConfig, returned.config);
					}
					else if (returned === 'skip')
					{
						fileComplete();	// parse the next file in the queue, if any
						return;
					}
				}

				// Wrap up the user's complete callback, if any, so that ours also gets executed
				var userCompleteFunc = f.instanceConfig.complete;
				f.instanceConfig.complete = function(results)
				{
					if (isFunction(userCompleteFunc))
						userCompleteFunc(results, f.file, f.inputElem);
					fileComplete();
				};

				Papa.parse(f.file, f.instanceConfig);
			}

			function error(name, file, elem, reason)
			{
				if (isFunction(options.error))
					options.error({name: name}, file, elem, reason);
			}

			function fileComplete()
			{
				queue.splice(0, 1);
				parseNextFile();
			}
		};
	}


	if (IS_PAPA_WORKER)
	{
		global.onmessage = workerThreadReceivedMessage;
	}
	else if (Papa.WORKERS_SUPPORTED)
	{
		AUTO_SCRIPT_PATH = getScriptPath();

		// Check if the script was loaded synchronously
		if (!document.body)
		{
			// Body doesn't exist yet, must be synchronous
			LOADED_SYNC = true;
		}
		else
		{
			document.addEventListener('DOMContentLoaded', function() {
				LOADED_SYNC = true;
			}, true);
		}
	}




	function CsvToJson(_input, _config)
	{
		_config = _config || {};
		var dynamicTyping = _config.dynamicTyping || false;
		if (isFunction(dynamicTyping)) {
			_config.dynamicTypingFunction = dynamicTyping;
			// Will be filled on first row call
			dynamicTyping = {};
		}
		_config.dynamicTyping = dynamicTyping;

		if (_config.worker && Papa.WORKERS_SUPPORTED)
		{
			var w = newWorker();

			w.userStep = _config.step;
			w.userChunk = _config.chunk;
			w.userComplete = _config.complete;
			w.userError = _config.error;

			_config.step = isFunction(_config.step);
			_config.chunk = isFunction(_config.chunk);
			_config.complete = isFunction(_config.complete);
			_config.error = isFunction(_config.error);
			delete _config.worker;	// prevent infinite loop

			w.postMessage({
				input: _input,
				config: _config,
				workerId: w.id
			});

			return;
		}

		var streamer = null;
		if (typeof _input === 'string')
		{
			if (_config.download)
				streamer = new NetworkStreamer(_config);
			else
				streamer = new StringStreamer(_config);
		}
		else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))
		{
			streamer = new ReadableStreamStreamer(_config);
		}
		else if ((global.File && _input instanceof File) || _input instanceof Object)	// ...Safari. (see issue #106)
			streamer = new FileStreamer(_config);

		return streamer.stream(_input);
	}






	function JsonToCsv(_input, _config)
	{
		// Default configuration

		/** whether to surround every datum with quotes */
		var _quotes = false;

		/** whether to write headers */
		var _writeHeader = true;

		/** delimiting character */
		var _delimiter = ',';

		/** newline character(s) */
		var _newline = '\r\n';

		/** quote character */
		var _quoteChar = '"';

		unpackConfig();

		var quoteCharRegex = new RegExp(_quoteChar, 'g');

		if (typeof _input === 'string')
			_input = JSON.parse(_input);

		if (_input instanceof Array)
		{
			if (!_input.length || _input[0] instanceof Array)
				return serialize(null, _input);
			else if (typeof _input[0] === 'object')
				return serialize(objectKeys(_input[0]), _input);
		}
		else if (typeof _input === 'object')
		{
			if (typeof _input.data === 'string')
				_input.data = JSON.parse(_input.data);

			if (_input.data instanceof Array)
			{
				if (!_input.fields)
					_input.fields =  _input.meta && _input.meta.fields;

				if (!_input.fields)
					_input.fields =  _input.data[0] instanceof Array
						? _input.fields
						: objectKeys(_input.data[0]);

				if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
					_input.data = [_input.data];	// handles input like [1,2,3] or ['asdf']
			}

			return serialize(_input.fields || [], _input.data || []);
		}

		// Default (any valid paths should return before this)
		throw 'exception: Unable to serialize unrecognized input';


		function unpackConfig()
		{
			if (typeof _config !== 'object')
				return;

			if (typeof _config.delimiter === 'string'
				&& _config.delimiter.length === 1
				&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)
			{
				_delimiter = _config.delimiter;
			}

			if (typeof _config.quotes === 'boolean'
				|| _config.quotes instanceof Array)
				_quotes = _config.quotes;

			if (typeof _config.newline === 'string')
				_newline = _config.newline;

			if (typeof _config.quoteChar === 'string')
				_quoteChar = _config.quoteChar;

			if (typeof _config.header === 'boolean')
				_writeHeader = _config.header;
		}


		/** Turns an object's keys into an array */
		function objectKeys(obj)
		{
			if (typeof obj !== 'object')
				return [];
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return keys;
		}

		/** The double for loop that iterates the data and writes out a CSV string including header row */
		function serialize(fields, data)
		{
			var csv = '';

			if (typeof fields === 'string')
				fields = JSON.parse(fields);
			if (typeof data === 'string')
				data = JSON.parse(data);

			var hasHeader = fields instanceof Array && fields.length > 0;
			var dataKeyedByField = !(data[0] instanceof Array);

			// If there a header row, write it first
			if (hasHeader && _writeHeader)
			{
				for (var i = 0; i < fields.length; i++)
				{
					if (i > 0)
						csv += _delimiter;
					csv += safe(fields[i], i);
				}
				if (data.length > 0)
					csv += _newline;
			}

			// Then write out the data
			for (var row = 0; row < data.length; row++)
			{
				var maxCol = hasHeader ? fields.length : data[row].length;

				for (var col = 0; col < maxCol; col++)
				{
					if (col > 0)
						csv += _delimiter;
					var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
					csv += safe(data[row][colIdx], col);
				}

				if (row < data.length - 1)
					csv += _newline;
			}

			return csv;
		}

		/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
		function safe(str, col)
		{
			if (typeof str === 'undefined' || str === null)
				return '';

			str = str.toString().replace(quoteCharRegex, _quoteChar + _quoteChar);

			var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
							|| (_quotes instanceof Array && _quotes[col])
							|| hasAny(str, Papa.BAD_DELIMITERS)
							|| str.indexOf(_delimiter) > -1
							|| str.charAt(0) === ' '
							|| str.charAt(str.length - 1) === ' ';

			return needsQuotes ? _quoteChar + str + _quoteChar : str;
		}

		function hasAny(str, substrings)
		{
			for (var i = 0; i < substrings.length; i++)
				if (str.indexOf(substrings[i]) > -1)
					return true;
			return false;
		}
	}

	/** ChunkStreamer is the base prototype for various streamer implementations. */
	function ChunkStreamer(config)
	{
		this._handle = null;
		this._finished = false;
		this._completed = false;
		this._input = null;
		this._baseIndex = 0;
		this._partialLine = '';
		this._rowCount = 0;
		this._start = 0;
		this._nextChunk = null;
		this.isFirstChunk = true;
		this._completeResults = {
			data: [],
			errors: [],
			meta: {}
		};
		replaceConfig.call(this, config);

		this.parseChunk = function(chunk, isFakeChunk)
		{
			// First chunk pre-processing
			if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))
			{
				var modifiedChunk = this._config.beforeFirstChunk(chunk);
				if (modifiedChunk !== undefined)
					chunk = modifiedChunk;
			}
			this.isFirstChunk = false;

			// Rejoin the line we likely just split in two by chunking the file
			var aggregate = this._partialLine + chunk;
			this._partialLine = '';

			var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

			if (this._handle.paused() || this._handle.aborted())
				return;

			var lastIndex = results.meta.cursor;

			if (!this._finished)
			{
				this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
				this._baseIndex = lastIndex;
			}

			if (results && results.data)
				this._rowCount += results.data.length;

			var finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);

			if (IS_PAPA_WORKER)
			{
				global.postMessage({
					results: results,
					workerId: Papa.WORKER_ID,
					finished: finishedIncludingPreview
				});
			}
			else if (isFunction(this._config.chunk) && !isFakeChunk)
			{
				this._config.chunk(results, this._handle);
				if (this._handle.paused() || this._handle.aborted())
					return;
				results = undefined;
				this._completeResults = undefined;
			}

			if (!this._config.step && !this._config.chunk) {
				this._completeResults.data = this._completeResults.data.concat(results.data);
				this._completeResults.errors = this._completeResults.errors.concat(results.errors);
				this._completeResults.meta = results.meta;
			}

			if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {
				this._config.complete(this._completeResults, this._input);
				this._completed = true;
			}

			if (!finishedIncludingPreview && (!results || !results.meta.paused))
				this._nextChunk();

			return results;
		};

		this._sendError = function(error)
		{
			if (isFunction(this._config.error))
				this._config.error(error);
			else if (IS_PAPA_WORKER && this._config.error)
			{
				global.postMessage({
					workerId: Papa.WORKER_ID,
					error: error,
					finished: false
				});
			}
		};

		function replaceConfig(config)
		{
			// Deep-copy the config so we can edit it
			var configCopy = copy(config);
			configCopy.chunkSize = parseInt(configCopy.chunkSize);	// parseInt VERY important so we don't concatenate strings!
			if (!config.step && !config.chunk)
				configCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196
			this._handle = new ParserHandle(configCopy);
			this._handle.streamer = this;
			this._config = configCopy;	// persist the copy to the caller
		}
	}


	function NetworkStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.RemoteChunkSize;
		ChunkStreamer.call(this, config);

		var xhr;

		if (IS_WORKER)
		{
			this._nextChunk = function()
			{
				this._readChunk();
				this._chunkLoaded();
			};
		}
		else
		{
			this._nextChunk = function()
			{
				this._readChunk();
			};
		}

		this.stream = function(url)
		{
			this._input = url;
			this._nextChunk();	// Starts streaming
		};

		this._readChunk = function()
		{
			if (this._finished)
			{
				this._chunkLoaded();
				return;
			}

			xhr = new XMLHttpRequest();

			if (this._config.withCredentials)
			{
				xhr.withCredentials = this._config.withCredentials;
			}

			if (!IS_WORKER)
			{
				xhr.onload = bindFunction(this._chunkLoaded, this);
				xhr.onerror = bindFunction(this._chunkError, this);
			}

			xhr.open('GET', this._input, !IS_WORKER);
			// Headers can only be set when once the request state is OPENED
			if (this._config.downloadRequestHeaders)
			{
				var headers = this._config.downloadRequestHeaders;

				for (var headerName in headers)
				{
					xhr.setRequestHeader(headerName, headers[headerName]);
				}
			}

			if (this._config.chunkSize)
			{
				var end = this._start + this._config.chunkSize - 1;	// minus one because byte range is inclusive
				xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);
				xhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672
			}

			try {
				xhr.send();
			}
			catch (err) {
				this._chunkError(err.message);
			}

			if (IS_WORKER && xhr.status === 0)
				this._chunkError();
			else
				this._start += this._config.chunkSize;
		};

		this._chunkLoaded = function()
		{
			if (xhr.readyState !== 4)
				return;

			if (xhr.status < 200 || xhr.status >= 400)
			{
				this._chunkError();
				return;
			}

			this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);
			this.parseChunk(xhr.responseText);
		};

		this._chunkError = function(errorMessage)
		{
			var errorText = xhr.statusText || errorMessage;
			this._sendError(new Error(errorText));
		};

		function getFileSize(xhr)
		{
			var contentRange = xhr.getResponseHeader('Content-Range');
			if (contentRange === null) { // no content range, then finish!
				return -1;
			}
			return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));
		}
	}
	NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
	NetworkStreamer.prototype.constructor = NetworkStreamer;


	function FileStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.LocalChunkSize;
		ChunkStreamer.call(this, config);

		var reader, slice;

		// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
		// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
		var usingAsyncReader = typeof FileReader !== 'undefined';	// Safari doesn't consider it a function - see issue #105

		this.stream = function(file)
		{
			this._input = file;
			slice = file.slice || file.webkitSlice || file.mozSlice;

			if (usingAsyncReader)
			{
				reader = new FileReader();		// Preferred method of reading files, even in workers
				reader.onload = bindFunction(this._chunkLoaded, this);
				reader.onerror = bindFunction(this._chunkError, this);
			}
			else
				reader = new FileReaderSync();	// Hack for running in a web worker in Firefox

			this._nextChunk();	// Starts streaming
		};

		this._nextChunk = function()
		{
			if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
				this._readChunk();
		};

		this._readChunk = function()
		{
			var input = this._input;
			if (this._config.chunkSize)
			{
				var end = Math.min(this._start + this._config.chunkSize, this._input.size);
				input = slice.call(input, this._start, end);
			}
			var txt = reader.readAsText(input, this._config.encoding);
			if (!usingAsyncReader)
				this._chunkLoaded({ target: { result: txt } });	// mimic the async signature
		};

		this._chunkLoaded = function(event)
		{
			// Very important to increment start each time before handling results
			this._start += this._config.chunkSize;
			this._finished = !this._config.chunkSize || this._start >= this._input.size;
			this.parseChunk(event.target.result);
		};

		this._chunkError = function()
		{
			this._sendError(reader.error);
		};

	}
	FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
	FileStreamer.prototype.constructor = FileStreamer;


	function StringStreamer(config)
	{
		config = config || {};
		ChunkStreamer.call(this, config);

		var remaining;
		this.stream = function(s)
		{
			remaining = s;
			return this._nextChunk();
		};
		this._nextChunk = function()
		{
			if (this._finished) return;
			var size = this._config.chunkSize;
			var chunk = size ? remaining.substr(0, size) : remaining;
			remaining = size ? remaining.substr(size) : '';
			this._finished = !remaining;
			return this.parseChunk(chunk);
		};
	}
	StringStreamer.prototype = Object.create(StringStreamer.prototype);
	StringStreamer.prototype.constructor = StringStreamer;


	function ReadableStreamStreamer(config)
	{
		config = config || {};

		ChunkStreamer.call(this, config);

		var queue = [];
		var parseOnData = true;
		var streamHasEnded = false;

		this.pause = function()
		{
			ChunkStreamer.prototype.pause.apply(this, arguments);
			this._input.pause();
		};

		this.resume = function()
		{
			ChunkStreamer.prototype.resume.apply(this, arguments);
			this._input.resume();
		};

		this.stream = function(stream)
		{
			this._input = stream;

			this._input.on('data', this._streamData);
			this._input.on('end', this._streamEnd);
			this._input.on('error', this._streamError);
		};

		this._checkIsFinished = function()
		{
			if (streamHasEnded && queue.length === 1) {
				this._finished = true;
			}
		};

		this._nextChunk = function()
		{
			this._checkIsFinished();
			if (queue.length)
			{
				this.parseChunk(queue.shift());
			}
			else
			{
				parseOnData = true;
			}
		};

		this._streamData = bindFunction(function(chunk)
		{
			try
			{
				queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));

				if (parseOnData)
				{
					parseOnData = false;
					this._checkIsFinished();
					this.parseChunk(queue.shift());
				}
			}
			catch (error)
			{
				this._streamError(error);
			}
		}, this);

		this._streamError = bindFunction(function(error)
		{
			this._streamCleanUp();
			this._sendError(error);
		}, this);

		this._streamEnd = bindFunction(function()
		{
			this._streamCleanUp();
			streamHasEnded = true;
			this._streamData('');
		}, this);

		this._streamCleanUp = bindFunction(function()
		{
			this._input.removeListener('data', this._streamData);
			this._input.removeListener('end', this._streamEnd);
			this._input.removeListener('error', this._streamError);
		}, this);
	}
	ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
	ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;


	// Use one ParserHandle per entire CSV file or string
	function ParserHandle(_config)
	{
		// One goal is to minimize the use of regular expressions...
		var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

		var self = this;
		var _stepCounter = 0;	// Number of times step was called (number of rows parsed)
		var _input;				// The input being parsed
		var _parser;			// The core parser being used
		var _paused = false;	// Whether we are paused or not
		var _aborted = false;	// Whether the parser has aborted or not
		var _delimiterError;	// Temporary state between delimiter detection and processing results
		var _fields = [];		// Fields are from the header row of the input, if there is one
		var _results = {		// The last results returned from the parser
			data: [],
			errors: [],
			meta: {}
		};

		if (isFunction(_config.step))
		{
			var userStep = _config.step;
			_config.step = function(results)
			{
				_results = results;

				if (needsHeaderRow())
					processResults();
				else	// only call user's step function after header row
				{
					processResults();

					// It's possbile that this line was empty and there's no row here after all
					if (_results.data.length === 0)
						return;

					_stepCounter += results.data.length;
					if (_config.preview && _stepCounter > _config.preview)
						_parser.abort();
					else
						userStep(_results, self);
				}
			};
		}

		/**
		 * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
		 * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
		 * when an input comes in multiple chunks, like from a file.
		 */
		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			if (!_config.newline)
				_config.newline = guessLineEndings(input);

			_delimiterError = false;
			if (!_config.delimiter)
			{
				var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines);
				if (delimGuess.successful)
					_config.delimiter = delimGuess.bestDelimiter;
				else
				{
					_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
					_config.delimiter = Papa.DefaultDelimiter;
				}
				_results.meta.delimiter = _config.delimiter;
			}
			else if(isFunction(_config.delimiter))
			{
				_config.delimiter = _config.delimiter(input);
				_results.meta.delimiter = _config.delimiter;
			}

			var parserConfig = copy(_config);
			if (_config.preview && _config.header)
				parserConfig.preview++;	// to compensate for header row

			_input = input;
			_parser = new Parser(parserConfig);
			_results = _parser.parse(_input, baseIndex, ignoreLastRow);
			processResults();
			return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });
		};

		this.paused = function()
		{
			return _paused;
		};

		this.pause = function()
		{
			_paused = true;
			_parser.abort();
			_input = _input.substr(_parser.getCharIndex());
		};

		this.resume = function()
		{
			_paused = false;
			self.streamer.parseChunk(_input, true);
		};

		this.aborted = function()
		{
			return _aborted;
		};

		this.abort = function()
		{
			_aborted = true;
			_parser.abort();
			_results.meta.aborted = true;
			if (isFunction(_config.complete))
				_config.complete(_results);
			_input = '';
		};

		function processResults()
		{
			if (_results && _delimiterError)
			{
				addError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \'' + Papa.DefaultDelimiter + '\'');
				_delimiterError = false;
			}

			if (_config.skipEmptyLines)
			{
				for (var i = 0; i < _results.data.length; i++)
					if (_results.data[i].length === 1 && _results.data[i][0] === '')
						_results.data.splice(i--, 1);
			}

			if (needsHeaderRow())
				fillHeaderFields();

			return applyHeaderAndDynamicTyping();
		}

		function needsHeaderRow()
		{
			return _config.header && _fields.length === 0;
		}

		function fillHeaderFields()
		{
			if (!_results)
				return;
			for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
				for (var j = 0; j < _results.data[i].length; j++)
				{
					var header = _results.data[i][j];

					if (_config.trimHeaders) {
						header = header.trim();
					}

					_fields.push(header);
				}
			_results.data.splice(0, 1);
		}

		function shouldApplyDynamicTyping(field) {
			// Cache function values to avoid calling it for each row
			if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
				_config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
			}
			return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
		}

		function parseDynamic(field, value)
		{
			if (shouldApplyDynamicTyping(field))
			{
				if (value === 'true' || value === 'TRUE')
					return true;
				else if (value === 'false' || value === 'FALSE')
					return false;
				else if(FLOAT.test(value)) {
					return parseFloat(value);
				}
				else {
					return (value === '' ? null : value);
				}
			}
			return value;
		}

		function applyHeaderAndDynamicTyping()
		{
			if (!_results || (!_config.header && !_config.dynamicTyping))
				return _results;

			for (var i = 0; i < _results.data.length; i++)
			{
				var row = _config.header ? {} : [];

				var j;
				for (j = 0; j < _results.data[i].length; j++)
				{
					var field = j;
					var value = _results.data[i][j];

					if (_config.header)
						field = j >= _fields.length ? '__parsed_extra' : _fields[j];

					value = parseDynamic(field, value);

					if (field === '__parsed_extra')
					{
						row[field] = row[field] || [];
						row[field].push(value);
					}
					else
						row[field] = value;
				}

				_results.data[i] = row;

				if (_config.header)
				{
					if (j > _fields.length)
						addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
					else if (j < _fields.length)
						addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
				}
			}

			if (_config.header && _results.meta)
				_results.meta.fields = _fields;
			return _results;
		}

		function guessDelimiter(input, newline, skipEmptyLines)
		{
			var delimChoices = [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];
			var bestDelim, bestDelta, fieldCountPrevRow;

			for (var i = 0; i < delimChoices.length; i++)
			{
				var delim = delimChoices[i];
				var delta = 0, avgFieldCount = 0, emptyLinesCount = 0;
				fieldCountPrevRow = undefined;

				var preview = new Parser({
					delimiter: delim,
					newline: newline,
					preview: 10
				}).parse(input);

				for (var j = 0; j < preview.data.length; j++)
				{
					if (skipEmptyLines && preview.data[j].length === 1 && preview.data[j][0].length === 0) {
						emptyLinesCount++;
						continue;
					}
					var fieldCount = preview.data[j].length;
					avgFieldCount += fieldCount;

					if (typeof fieldCountPrevRow === 'undefined')
					{
						fieldCountPrevRow = fieldCount;
						continue;
					}
					else if (fieldCount > 1)
					{
						delta += Math.abs(fieldCount - fieldCountPrevRow);
						fieldCountPrevRow = fieldCount;
					}
				}

				if (preview.data.length > 0)
					avgFieldCount /= (preview.data.length - emptyLinesCount);

				if ((typeof bestDelta === 'undefined' || delta < bestDelta)
					&& avgFieldCount > 1.99)
				{
					bestDelta = delta;
					bestDelim = delim;
				}
			}

			_config.delimiter = bestDelim;

			return {
				successful: !!bestDelim,
				bestDelimiter: bestDelim
			};
		}

		function guessLineEndings(input)
		{
			input = input.substr(0, 1024 * 1024);	// max length 1 MB

			var r = input.split('\r');

			var n = input.split('\n');

			var nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);

			if (r.length === 1 || nAppearsFirst)
				return '\n';

			var numWithN = 0;
			for (var i = 0; i < r.length; i++)
			{
				if (r[i][0] === '\n')
					numWithN++;
			}

			return numWithN >= r.length / 2 ? '\r\n' : '\r';
		}

		function addError(type, code, msg, row)
		{
			_results.errors.push({
				type: type,
				code: code,
				message: msg,
				row: row
			});
		}
	}





	/** The core parser implements speedy and correct CSV parsing */
	function Parser(config)
	{
		// Unpack the config object
		config = config || {};
		var delim = config.delimiter;
		var newline = config.newline;
		var comments = config.comments;
		var step = config.step;
		var preview = config.preview;
		var fastMode = config.fastMode;
		var quoteChar;
		/** Allows for no quoteChar by setting quoteChar to undefined in config */
		if (config.quoteChar === undefined) {
			quoteChar = '"';
		} else {
			quoteChar = config.quoteChar;
		}
		var escapeChar = quoteChar;
		if (config.escapeChar !== undefined) {
			escapeChar = config.escapeChar;
		}

		// Delimiter must be valid
		if (typeof delim !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)
			delim = ',';

		// Comment character must be valid
		if (comments === delim)
			throw 'Comment character same as delimiter';
		else if (comments === true)
			comments = '#';
		else if (typeof comments !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)
			comments = false;

		// Newline must be valid: \r, \n, or \r\n
		if (newline !== '\n' && newline !== '\r' && newline !== '\r\n')
			newline = '\n';

		// We're gonna need these at the Parser scope
		var cursor = 0;
		var aborted = false;

		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			// For some reason, in Chrome, this speeds things up (!?)
			if (typeof input !== 'string')
				throw 'Input must be a string';

			// We don't need to compute some of these every time parse() is called,
			// but having them in a more local scope seems to perform better
			var inputLen = input.length,
				delimLen = delim.length,
				newlineLen = newline.length,
				commentsLen = comments.length;
			var stepIsFunction = isFunction(step);

			// Establish starting state
			cursor = 0;
			var data = [], errors = [], row = [], lastCursor = 0;

			if (!input)
				return returnable();

			if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))
			{
				var rows = input.split(newline);
				for (var i = 0; i < rows.length; i++)
				{
					row = rows[i];
					cursor += row.length;
					if (i !== rows.length - 1)
						cursor += newline.length;
					else if (ignoreLastRow)
						return returnable();
					if (comments && row.substr(0, commentsLen) === comments)
						continue;
					if (stepIsFunction)
					{
						data = [];
						pushRow(row.split(delim));
						doStep();
						if (aborted)
							return returnable();
					}
					else
						pushRow(row.split(delim));
					if (preview && i >= preview)
					{
						data = data.slice(0, preview);
						return returnable(true);
					}
				}
				return returnable();
			}

			var nextDelim = input.indexOf(delim, cursor);
			var nextNewline = input.indexOf(newline, cursor);
			var quoteCharRegex = new RegExp(escapeChar.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&') + quoteChar, 'g');
			var quoteSearch;

			// Parser loop
			for (;;)
			{
				// Field has opening quote
				if (input[cursor] === quoteChar)
				{
					// Start our search for the closing quote where the cursor is
					quoteSearch = cursor;

					// Skip the opening quote
					cursor++;

					for (;;)
					{
						// Find closing quote
						quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

						//No other quotes are found - no other delimiters
						if (quoteSearch === -1)
						{
							if (!ignoreLastRow) {
								// No closing quote... what a pity
								errors.push({
									type: 'Quotes',
									code: 'MissingQuotes',
									message: 'Quoted field unterminated',
									row: data.length,	// row has yet to be inserted
									index: cursor
								});
							}
							return finish();
						}

						// Closing quote at EOF
						if (quoteSearch === inputLen - 1)
						{
							var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
							return finish(value);
						}

						// If this quote is escaped, it's part of the data; skip it
						// If the quote character is the escape character, then check if the next character is the escape character
						if (quoteChar === escapeChar &&  input[quoteSearch + 1] === escapeChar)
						{
							quoteSearch++;
							continue;
						}

						// If the quote character is not the escape character, then check if the previous character was the escape character
						if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar)
						{
							continue;
						}

						var spacesBetweenQuoteAndDelimiter = extraSpaces(nextDelim);

						// Closing quote followed by delimiter or 'unnecessary steps + delimiter'
						if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim)
						{
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
							nextDelim = input.indexOf(delim, cursor);
							nextNewline = input.indexOf(newline, cursor);
							break;
						}

						var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);

						// Closing quote followed by newline or 'unnecessary spaces + newLine'
						if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline)
						{
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
							nextDelim = input.indexOf(delim, cursor);	// because we may have skipped the nextDelim in the quoted field

							if (stepIsFunction)
							{
								doStep();
								if (aborted)
									return returnable();
							}

							if (preview && data.length >= preview)
								return returnable(true);

							break;
						}


						// Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string
						errors.push({
							type: 'Quotes',
							code: 'InvalidQuotes',
							message: 'Trailing quote on quoted field is malformed',
							row: data.length,	// row has yet to be inserted
							index: cursor
						});

						quoteSearch++;
						continue;

					}

					continue;
				}

				// Comment found at start of new line
				if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)
				{
					if (nextNewline === -1)	// Comment ends at EOF
						return returnable();
					cursor = nextNewline + newlineLen;
					nextNewline = input.indexOf(newline, cursor);
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}

				// Next delimiter comes before next newline, so we've reached end of field
				if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))
				{
					row.push(input.substring(cursor, nextDelim));
					cursor = nextDelim + delimLen;
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}

				// End of row
				if (nextNewline !== -1)
				{
					row.push(input.substring(cursor, nextNewline));
					saveRow(nextNewline + newlineLen);

					if (stepIsFunction)
					{
						doStep();
						if (aborted)
							return returnable();
					}

					if (preview && data.length >= preview)
						return returnable(true);

					continue;
				}

				break;
			}


			return finish();


			function pushRow(row)
			{
				data.push(row);
				lastCursor = cursor;
			}

			/**
             * checks if there are extra spaces after closing quote and given index without any text
             * if Yes, returns the number of spaces
             */
			function extraSpaces(index) {
				var spaceLength = 0;
				if (index !== -1) {
					var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
					if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {
						spaceLength = textBetweenClosingQuoteAndIndex.length;
					}
				}
				return spaceLength;
			}

			/**
			 * Appends the remaining input from cursor to the end into
			 * row, saves the row, calls step, and returns the results.
			 */
			function finish(value)
			{
				if (ignoreLastRow)
					return returnable();
				if (typeof value === 'undefined')
					value = input.substr(cursor);
				row.push(value);
				cursor = inputLen;	// important in case parsing is paused
				pushRow(row);
				if (stepIsFunction)
					doStep();
				return returnable();
			}

			/**
			 * Appends the current row to the results. It sets the cursor
			 * to newCursor and finds the nextNewline. The caller should
			 * take care to execute user's step function and check for
			 * preview and end parsing if necessary.
			 */
			function saveRow(newCursor)
			{
				cursor = newCursor;
				pushRow(row);
				row = [];
				nextNewline = input.indexOf(newline, cursor);
			}

			/** Returns an object with the results, errors, and meta. */
			function returnable(stopped)
			{
				return {
					data: data,
					errors: errors,
					meta: {
						delimiter: delim,
						linebreak: newline,
						aborted: aborted,
						truncated: !!stopped,
						cursor: lastCursor + (baseIndex || 0)
					}
				};
			}

			/** Executes the user's step function and resets data & errors. */
			function doStep()
			{
				step(returnable());
				data = [];
				errors = [];
			}
		};

		/** Sets the abort flag */
		this.abort = function()
		{
			aborted = true;
		};

		/** Gets the cursor position */
		this.getCharIndex = function()
		{
			return cursor;
		};
	}


	// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code
	// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358
	function getScriptPath()
	{
		var scripts = document.getElementsByTagName('script');
		return scripts.length ? scripts[scripts.length - 1].src : '';
	}

	function newWorker()
	{
		if (!Papa.WORKERS_SUPPORTED)
			return false;
		if (!LOADED_SYNC && Papa.SCRIPT_PATH === null)
			throw new Error(
				'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +
				'You need to set Papa.SCRIPT_PATH manually.'
			);
		var workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;
		// Append 'papaworker' to the search string to tell papaparse that this is our worker.
		workerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';
		var w = new global.Worker(workerUrl);
		w.onmessage = mainThreadReceivedMessage;
		w.id = workerIdCounter++;
		workers[w.id] = w;
		return w;
	}

	/** Callback when main thread receives a message */
	function mainThreadReceivedMessage(e)
	{
		var msg = e.data;
		var worker = workers[msg.workerId];
		var aborted = false;

		if (msg.error)
			worker.userError(msg.error, msg.file);
		else if (msg.results && msg.results.data)
		{
			var abort = function() {
				aborted = true;
				completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
			};

			var handle = {
				abort: abort,
				pause: notImplemented,
				resume: notImplemented
			};

			if (isFunction(worker.userStep))
			{
				for (var i = 0; i < msg.results.data.length; i++)
				{
					worker.userStep({
						data: [msg.results.data[i]],
						errors: msg.results.errors,
						meta: msg.results.meta
					}, handle);
					if (aborted)
						break;
				}
				delete msg.results;	// free memory ASAP
			}
			else if (isFunction(worker.userChunk))
			{
				worker.userChunk(msg.results, handle, msg.file);
				delete msg.results;
			}
		}

		if (msg.finished && !aborted)
			completeWorker(msg.workerId, msg.results);
	}

	function completeWorker(workerId, results) {
		var worker = workers[workerId];
		if (isFunction(worker.userComplete))
			worker.userComplete(results);
		worker.terminate();
		delete workers[workerId];
	}

	function notImplemented() {
		throw 'Not implemented.';
	}

	/** Callback when worker thread receives a message */
	function workerThreadReceivedMessage(e)
	{
		var msg = e.data;

		if (typeof Papa.WORKER_ID === 'undefined' && msg)
			Papa.WORKER_ID = msg.workerId;

		if (typeof msg.input === 'string')
		{
			global.postMessage({
				workerId: Papa.WORKER_ID,
				results: Papa.parse(msg.input, msg.config),
				finished: true
			});
		}
		else if ((global.File && msg.input instanceof File) || msg.input instanceof Object)	// thank you, Safari (see issue #106)
		{
			var results = Papa.parse(msg.input, msg.config);
			if (results)
				global.postMessage({
					workerId: Papa.WORKER_ID,
					results: results,
					finished: true
				});
		}
	}

	/** Makes a deep copy of an array or object (mostly) */
	function copy(obj)
	{
		if (typeof obj !== 'object')
			return obj;
		var cpy = obj instanceof Array ? [] : {};
		for (var key in obj)
			cpy[key] = copy(obj[key]);
		return cpy;
	}

	function bindFunction(f, self)
	{
		return function() { f.apply(self, arguments); };
	}

	function isFunction(func)
	{
		return typeof func === 'function';
	}

	return Papa;
}));
});

/**
 * BioMap data model
 */

var BioMapModel = function () {

  /**
   * create a BioMapModel
   * @param {Object} params having the following properties:
   * @param {String} name - the map name
   * @param {Object} source - the DataSourceModel where bioMap was loaded from
   * @param {Object} coordinates - object w/ start and stop props
   * @param {Array} features - an array of Feature instances.
   */

  function BioMapModel(_ref) {
    var name = _ref.name,
        source = _ref.source,
        features = _ref.features,
        tags = _ref.tags,
        _ref$coordinates = _ref.coordinates,
        coordinates = _ref$coordinates === undefined ? { start: 0, stop: 0 } : _ref$coordinates,
        config = _ref.config;
    classCallCheck(this, BioMapModel);

    this.name = name;
    this.source = source;
    this.features = features;
    this.tags = tags;
    this.coordinates = coordinates;
    this.config = config;
  }

  /**
   * getter for length (coordinates.stop - coordinates.start)
   * @returns {number}
   */

  createClass(BioMapModel, [{
    key: "length",
    get: function get$$1() {
      return this.coordinates.stop - this.coordinates.start;
    }

    /**
     *
     * getter for unique name (prefix map name the id of data source)
     * @returns {string}
     */

  }, {
    key: "uniqueName",
    get: function get$$1() {
      return this.source.id + "/" + this.name;
    }
  }]);
  return BioMapModel;
}();

/**
 * BioMapConfiguration data model
 */
var BioMapConfigModel = function () {

  /**
   * create a BioMapConfigModel
   * @param url
   * @param method
   */

  function BioMapConfigModel(_ref) {
    var url = _ref.url,
        method = _ref.method;
    classCallCheck(this, BioMapConfigModel);

    this.url = url;
    this.method = method;
  }

  /**
   *
   */


  createClass(BioMapConfigModel, [{
    key: 'load',
    value: function load() {
      return mithril.request(this);
    }
  }]);
  return BioMapConfigModel;
}();

/**
 * Constant that defines the default configuration of cmap maps
 * when no other configuration information is present.
 *
 * @type {{backboneWidth: number, backboneColor: string, invert: boolean, markerColor: string, markerWeight: number, markerLabelSize: number, markerLabelFace: string, markerLabelColor: string, rulerWidth: number, rulerSpacing: number, rulerColor: string, rulerLabelFace: string, rulerLabelSize: number, rulerLabelColor: string, rulerPrecision: number, rulerSteps: number, trackWidth: number, trackSpacing: number, fillColor: string, trackLabelSize: number, trackLabelFace: string, trackLabelColor: string}}
 */

var defaultConfig = {
  'backbone': {
    'width': 20,
    'fillColor': '#fff6e8',
    'lineWeight': 0,
    'lineColor': 'black'
  },
  'ruler': {
    'width': 10,
    'padding': 5,
    'fillColor': 'aqua',
    'lineWeight': 0,
    'lineColor': 'black',
    'labelFace': 'Nunito',
    'labelSize': 12,
    'labelColor': 'black',
    'innerLineWeight': 1.0,
    'innerLineColor': 'black',
    'precision': 2,
    'steps': 100
  },
  'track': {
    'width': 5,
    'padding': 5,
    'fillColor': '#636081',
    'lineWeight': 0,
    'lineColor': 'black',
    'labelFace': 'Nunito',
    'labelSize': 12,
    'labelColor': 'black',
    'internalPadding': '5'
  },
  'marker': {
    'lineWeight': 1,
    'lineColor': 'black',
    'labelFace': 'Nunito',
    'labelSize': 12,
    'labelColor': 'black'
  },

  'manhattan': {
    'width': 2,
    'fillColor': 'green',
    'lineWeight': 1,
    'lineColor': 'black',
    'labelFace': 'Nunito',
    'labelSize': 10,
    'labelColor': 'black',
    'displayWidth': 50,
    'featureLineWeight': 3,
    'featureLineColor': 'red',
    'rulerWeight': 2,
    'rulerColor': 'black',
    'rulerMajorMark': 10,
    'rulerMinorMark': 2,
    'type': 'manhattan'
  },
  'qtl': {
    'padding': 20,
    'width': 5,
    'fillColor': ['green'],
    'labelSize': 12,
    'labelFace': 'Nunito',
    'labelColor': 'black',
    'trackMinWidth': 50,
    'internalPadding': 5,
    'position': 1,
    'type': 'qtl'
  },
  'invert': false
};

/**
 * Data source model
 */

// TODO: implement filtering at data loading time

var DataSourceModel = function () {

  /**
   * create a DataSourceModel
   * @param {Object} params having the following properties:
   * @param {String} id - uniqueId string for the data source (required)
   * @param {String} method - HTTP method, get or post (required)
   * @param {String} url - HTTP URL (required)
   * @param {Object} data - query string parameters for the request (optional)
   */

  function DataSourceModel(_ref) {
    var _this = this;

    var id = _ref.id,
        method = _ref.method,
        data = _ref.data,
        url = _ref.url,
        filters = _ref.filters,
        linkouts = _ref.linkouts,
        config = _ref.config;
    classCallCheck(this, DataSourceModel);

    this.id = id;
    this.method = method;
    this.data = data;
    this.url = url;
    this.config = config || {};
    this.bioConfig = { 'default': defaultConfig };
    // request bioconfig urlpage as a promise, if it is gettable, fill in all
    // default values that aren't defined using the base config, otherwise
    // set the default values to the base config (found in BioMapConfigModel).
    (function () {
      // promise generator
      var cfg = new BioMapConfigModel(_this.config);
      return cfg.load();
    })().then( // promise resolution
    function (item) {
      // success
      _this.bioConfig = item;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(_this.bioConfig)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var configGroup = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = Object.keys(defaultConfig)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var key = _step2.value;

              if (_this.bioConfig[configGroup][key] === undefined) {
                _this.bioConfig[configGroup][key] = _this.bioConfig.default[key] || defaultConfig[key];
              }
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = Object.keys(defaultConfig[key])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var subkey = _step3.value;

                  if (_this.bioConfig[configGroup][key][subkey] === undefined) {
                    _this.bioConfig[configGroup][key][subkey] = _this.bioConfig.default[key][subkey] || defaultConfig[key][subkey];
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }, function () {
      // failure
      _this.bioConfig.default = defaultConfig;
    });

    this.filters = filters || [];
    this.linkouts = linkouts || [];
    this.linkouts.forEach(function (l) {
      l.featuretypePattern !== undefined ? l.featuretypePattern = new RegExp(l.featuretypePattern) : undefined;
    });
    this.background = true; // mithril not to redraw upon completion
  }

  /**
   *Load the data source with mithril request
   * @returns {*}
   */

  createClass(DataSourceModel, [{
    key: 'load',
    value: function load() {
      return mithril.request(this);
    }

    /**
     * Callback from mithril request(); instead of the default deserialization
     * which is JSON, use the papaparse library to parse csv or tab delimited
     * content.
     * @param {String} data - delimited text, csv or tsv
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      var _this2 = this;

      var res = papaparse.parse(data, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true
      });
      if (res.errors.length) {
        console.error(res.errors);
        alert('There were parsing errors in ' + this.url + ', please see console.');
      }
      // apply filters from config file
      res.data = res.data.filter(function (d) {
        return _this2.includeRecord(d);
      });
      this.parseResult = res;
    }

    /**
     * Check record against filters and return true for inclusion. All filters are
     * processed sequentially and the result is all or nothing, effectively like
     * SQL AND.
     *
     * @param {Object} d - key/value properties of 1 record
     * @return {Boolean} true for include, false for exclude
     */

  }, {
    key: 'includeRecord',
    value: function includeRecord(d) {
      var hits = 0;
      this.filters.forEach(function (f) {
        var col = f.column;
        if (d.hasOwnProperty(col)) {
          var testVal = d[col];
          var match = void 0;
          if (f.operator === 'equals') {
            match = testVal === f.value;
          } else if (f.operator === 'regex') {
            match = testVal.match(f.value);
          }
          if (f.not) {
            if (!match) ++hits;
          } else {
            if (match) ++hits;
          }
        }
      });
      return hits === this.filters.length;
    }

    /**
     * bioMaps getter; return a mapping of the uniquified map name to
     * an instance of BioMapModel.
     *
     * @return {Object} key: prefix + map_name -> val: BioMapModel instance
     */

  }, {
    key: 'bioMaps',
    get: function get$$1() {
      var _this3 = this;

      var res = {};
      try {
        var typeField = this.parseResult.meta.fields.includes('feature_type') ? 'feature_type' : 'feature_type_acc';
        this.parseResult.data.forEach(function (d) {
          if (!d.map_name) return;
          var uniqueMapName = _this3.id + '/' + d.map_name;
          if (!res[uniqueMapName]) {
            var model = new BioMapModel({
              source: _this3,
              name: d.map_name,
              features: [],
              tags: [],
              coordinates: { start: d.map_start, stop: d.map_stop },
              config: _this3.bioConfig[d.map_name] || _this3.bioConfig.default
            });
            res[uniqueMapName] = model;
          } else {
            if (d.map_stop > res[uniqueMapName].coordinates.stop) {
              res[uniqueMapName].coordinates.stop = d.map_stop;
            }
          }
          res[uniqueMapName].features.push(new Feature({
            source: _this3,
            name: d.feature_name,
            tags: [d[typeField] !== '' ? d[typeField] : null],
            aliases: d.feature_aliases !== '' ? d.feature_aliases.split(',') : [],
            coordinates: { start: d.feature_start, stop: d.feature_stop }
          }));
          if (d[typeField] !== '' && res[uniqueMapName].tags.indexOf(d[typeField]) === -1) {
            res[uniqueMapName].tags.push(d[typeField]);
          }
        });
      } catch (e) {
        console.trace();
        console.error(e);
      }
      return res;
    }
  }]);
  return DataSourceModel;
}();

/**
 * App state - a global app state (or model), which can be referenced, viewed or
 * lensed, by various UI components. UI components should have only state needed
 * for their specific function, and should not cache, synchronize or duplicate
 * data from the app state.
 */
var AppModel = function () {

  /**
   *
   */

  function AppModel() {
    var _this = this;

    classCallCheck(this, AppModel);

    // sources and bioMaps arrays will be populated in load()
    this.sources = [];
    this.bioMaps = [];
    this.tools = {
      zoomFactor: 1,
      layout: HorizontalLayout // the default layout
    };
    this.selection = {
      // biomaps can be multi-selected by click or tap
      bioMaps: []
    };
    pubsub.subscribe(reset, function () {
      return _this._onReset();
    });
    // the status and busy properties are be displayed in the UI,
    // and can be freely changed via these properties
    this.status = '';
    this.busy = false;
  }

  /**
   * load the app model
   * @param header
   * @param attribution
   * @param sources
   * @param initialView
   */

  createClass(AppModel, [{
    key: 'load',
    value: function load(_ref) {
      var _this2 = this;

      var header = _ref.header,
          attribution = _ref.attribution,
          sources = _ref.sources,
          initialView = _ref.initialView;

      var sourceConfigs = sources;
      this.header = header;
      this.attribution = attribution;
      this.initialView = initialView || [];
      this.biomaps = [];
      var promises = sourceConfigs.map(function (config) {
        var dsm = new DataSourceModel(config);
        _this2.sources.push(dsm);
        return dsm.load();
      });
      // wait for all data sources are loaded, then set this.bioMaps with
      // only the maps named in initialView
      //
      Promise.all(promises).then(function () {
        _this2.allMaps = _this2.sources.map(function (src) {
          return Object.values(src.bioMaps);
        }).concatAll();
        if (!_this2.initialView.length) {
          _this2.defaultInitialView();
        } else {
          _this2.setupInitialView();
        }
        pubsub.publish(dataLoaded);
      }).catch(function (err) {
        // TODO: make a nice mithril component to display errors in the UI
        var msg = 'While fetching data source(s), ' + err;
        console.error(msg);
        console.trace();
        alert(msg);
      });
      return promises;
    }

    /**
     * create this.bioMaps based on initialView of config file.
     */

  }, {
    key: 'setupInitialView',
    value: function setupInitialView() {
      var _this3 = this;

      this.bioMaps = this.initialView.map(function (viewConf) {
        var res = _this3.allMaps.filter(function (map) {
          return viewConf.source === map.source.id && viewConf.map === map.name;
        });
        if (res.length === 0) {
          // TODO: make a nice mithril component to display errors in the UI
          var info = JSON.stringify(viewConf);
          var msg = 'failed to resolve initialView entry: ' + info;
          console.error(msg);
          console.trace();
          alert(msg);
        }
        if (viewConf.tracks) {
          res[0].tracks = viewConf.tracks;
        }
        if (viewConf.qtl) {
          res[0].qtlGroups = viewConf.qtl;
        }
        return res;
      }).concatAll();
    }

    /**
     * create this.bioMaps based on first map from each datasource (e.g if
     * initialView was not defined in config file).
     */

  }, {
    key: 'defaultInitialView',
    value: function defaultInitialView() {
      this.bioMaps = this.sources.map(function (src) {
        return Object.values(src.bioMaps)[0];
      });
    }

    /**
     * Add map at the given index (note, this is called by MapAdditionDialog)
     * @param {Object} bioMap - a bioMap from one of the already loaded data sources.
     * @param {Number} index - zero based index into the bioMaps array.
     */

  }, {
    key: 'addMap',
    value: function addMap(bioMap) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      this.bioMaps.splice(index, 0, bioMap);
      pubsub.publish(mapAdded, bioMap);
    }

    /**
     * PubSub event handler
     * @private
     */

  }, {
    key: '_onReset',
    value: function _onReset() {
      this.tools.zoomFactor = 1;
      this.tools.layout = HorizontalLayout;
    }
  }]);
  return AppModel;
}();

var hamster = createCommonjsModule(function (module, exports) {
/*
 * Hamster.js v1.1.2
 * (c) 2013 Monospaced http://monospaced.com
 * License: MIT
 */

(function(window, document){
'use strict';

/**
 * Hamster
 * use this to create instances
 * @returns {Hamster.Instance}
 * @constructor
 */
var Hamster = function(element) {
  return new Hamster.Instance(element);
};

// default event name
Hamster.SUPPORT = 'wheel';

// default DOM methods
Hamster.ADD_EVENT = 'addEventListener';
Hamster.REMOVE_EVENT = 'removeEventListener';
Hamster.PREFIX = '';

// until browser inconsistencies have been fixed...
Hamster.READY = false;

Hamster.Instance = function(element){
  if (!Hamster.READY) {
    // fix browser inconsistencies
    Hamster.normalise.browser();

    // Hamster is ready...!
    Hamster.READY = true;
  }

  this.element = element;

  // store attached event handlers
  this.handlers = [];

  // return instance
  return this;
};

/**
 * create new hamster instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @returns {Hamster.Instance}
 * @constructor
 */
Hamster.Instance.prototype = {
  /**
   * bind events to the instance
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   * @returns {Hamster.Instance}
   */
  wheel: function onEvent(handler, useCapture){
    Hamster.event.add(this, Hamster.SUPPORT, handler, useCapture);

    // handle MozMousePixelScroll in older Firefox
    if (Hamster.SUPPORT === 'DOMMouseScroll') {
      Hamster.event.add(this, 'MozMousePixelScroll', handler, useCapture);
    }

    return this;
  },

  /**
   * unbind events to the instance
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   * @returns {Hamster.Instance}
   */
  unwheel: function offEvent(handler, useCapture){
    // if no handler argument,
    // unbind the last bound handler (if exists)
    if (handler === undefined && (handler = this.handlers.slice(-1)[0])) {
      handler = handler.original;
    }

    Hamster.event.remove(this, Hamster.SUPPORT, handler, useCapture);

    // handle MozMousePixelScroll in older Firefox
    if (Hamster.SUPPORT === 'DOMMouseScroll') {
      Hamster.event.remove(this, 'MozMousePixelScroll', handler, useCapture);
    }

    return this;
  }
};

Hamster.event = {
  /**
   * cross-browser 'addWheelListener'
   * @param   {Instance}    hamster
   * @param   {String}      eventName
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   */
  add: function add(hamster, eventName, handler, useCapture){
    // store the original handler
    var originalHandler = handler;

    // redefine the handler
    handler = function(originalEvent){

      if (!originalEvent) {
        originalEvent = window.event;
      }

      // create a normalised event object,
      // and normalise "deltas" of the mouse wheel
      var event = Hamster.normalise.event(originalEvent),
          delta = Hamster.normalise.delta(originalEvent);

      // fire the original handler with normalised arguments
      return originalHandler(event, delta[0], delta[1], delta[2]);

    };

    // cross-browser addEventListener
    hamster.element[Hamster.ADD_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);

    // store original and normalised handlers on the instance
    hamster.handlers.push({
      original: originalHandler,
      normalised: handler
    });
  },

  /**
   * removeWheelListener
   * @param   {Instance}    hamster
   * @param   {String}      eventName
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   */
  remove: function remove(hamster, eventName, handler, useCapture){
    // find the normalised handler on the instance
    var originalHandler = handler,
        lookup = {},
        handlers;
    for (var i = 0, len = hamster.handlers.length; i < len; ++i) {
      lookup[hamster.handlers[i].original] = hamster.handlers[i];
    }
    handlers = lookup[originalHandler];
    handler = handlers.normalised;

    // cross-browser removeEventListener
    hamster.element[Hamster.REMOVE_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);

    // remove original and normalised handlers from the instance
    for (var h in hamster.handlers) {
      if (hamster.handlers[h] == handlers) {
        hamster.handlers.splice(h, 1);
        break;
      }
    }
  }
};

/**
 * these hold the lowest deltas,
 * used to normalise the delta values
 * @type {Number}
 */
var lowestDelta,
    lowestDeltaXY;

Hamster.normalise = {
  /**
   * fix browser inconsistencies
   */
  browser: function normaliseBrowser(){
    // detect deprecated wheel events
    if (!('onwheel' in document || document.documentMode >= 9)) {
      Hamster.SUPPORT = document.onmousewheel !== undefined ?
                        'mousewheel' : // webkit and IE < 9 support at least "mousewheel"
                        'DOMMouseScroll'; // assume remaining browsers are older Firefox
    }

    // detect deprecated event model
    if (!window.addEventListener) {
      // assume IE < 9
      Hamster.ADD_EVENT = 'attachEvent';
      Hamster.REMOVE_EVENT = 'detachEvent';
      Hamster.PREFIX = 'on';
    }

  },

  /**
   * create a normalised event object
   * @param   {Function}    originalEvent
   * @returns {Object}      event
   */
   event: function normaliseEvent(originalEvent){
    var event = {
          // keep a reference to the original event object
          originalEvent: originalEvent,
          target: originalEvent.target || originalEvent.srcElement,
          type: 'wheel',
          deltaMode: originalEvent.type === 'MozMousePixelScroll' ? 0 : 1,
          deltaX: 0,
          deltaZ: 0,
          preventDefault: function(){
            if (originalEvent.preventDefault) {
              originalEvent.preventDefault();
            } else {
              originalEvent.returnValue = false;
            }
          },
          stopPropagation: function(){
            if (originalEvent.stopPropagation) {
              originalEvent.stopPropagation();
            } else {
              originalEvent.cancelBubble = false;
            }
          }
        };

    // calculate deltaY (and deltaX) according to the event

    // 'mousewheel'
    if (originalEvent.wheelDelta) {
      event.deltaY = - 1/40 * originalEvent.wheelDelta;
    }
    // webkit
    if (originalEvent.wheelDeltaX) {
      event.deltaX = - 1/40 * originalEvent.wheelDeltaX;
    }

    // 'DomMouseScroll'
    if (originalEvent.detail) {
      event.deltaY = originalEvent.detail;
    }

    return event;
  },

  /**
   * normalise 'deltas' of the mouse wheel
   * @param   {Function}    originalEvent
   * @returns {Array}       deltas
   */
  delta: function normaliseDelta(originalEvent){
    var delta = 0,
      deltaX = 0,
      deltaY = 0,
      absDelta = 0,
      absDeltaXY = 0,
      fn;

    // normalise deltas according to the event

    // 'wheel' event
    if (originalEvent.deltaY) {
      deltaY = originalEvent.deltaY * -1;
      delta  = deltaY;
    }
    if (originalEvent.deltaX) {
      deltaX = originalEvent.deltaX;
      delta  = deltaX * -1;
    }

    // 'mousewheel' event
    if (originalEvent.wheelDelta) {
      delta = originalEvent.wheelDelta;
    }
    // webkit
    if (originalEvent.wheelDeltaY) {
      deltaY = originalEvent.wheelDeltaY;
    }
    if (originalEvent.wheelDeltaX) {
      deltaX = originalEvent.wheelDeltaX * -1;
    }

    // 'DomMouseScroll' event
    if (originalEvent.detail) {
      delta = originalEvent.detail * -1;
    }

    // Don't return NaN
    if (delta === 0) {
      return [0, 0, 0];
    }

    // look for lowest delta to normalize the delta values
    absDelta = Math.abs(delta);
    if (!lowestDelta || absDelta < lowestDelta) {
      lowestDelta = absDelta;
    }
    absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
    if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
      lowestDeltaXY = absDeltaXY;
    }

    // convert deltas to whole numbers
    fn = delta > 0 ? 'floor' : 'ceil';
    delta  = Math[fn](delta / lowestDelta);
    deltaX = Math[fn](deltaX / lowestDeltaXY);
    deltaY = Math[fn](deltaY / lowestDeltaXY);

    return [delta, deltaX, deltaY];
  }
};

if (typeof window.define === 'function' && window.define.amd) {
  // AMD
  window.define('hamster', [], function(){
    return Hamster;
  });
} else {
  // CommonJS
  module.exports = Hamster;
}

})(window, window.document);
});

/**
 * Reset
 * A mithril component of a Reset button.
 */
var ResetButton = function () {
  function ResetButton() {
    classCallCheck(this, ResetButton);
  }

  createClass(ResetButton, [{
    key: 'view',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril render callback
     * @returns {*}
     */

    value: function view() {
      var _this = this;

      return mithril('button', {
        onclick: function onclick(evt) {
          return _this._onClick(evt);
        }
      }, [mithril('i.material-icons', 'restore'), 'Reset View']);
    }

    /**
     * reset button event handler
     * @param evt
     * @private
     */

  }, {
    key: '_onClick',
    value: function _onClick(evt) {
      pubsub.publish(reset, null);
      // subscribers to the reset topic may m.redraw if they need to; suppress
      // redraw for the current event.
      evt.redraw = false;
    }
  }]);
  return ResetButton;
}();

/**
 * A mithril component of Remove Map button
 */
var RemoveMapButton = function () {
  function RemoveMapButton() {
    classCallCheck(this, RemoveMapButton);
  }

  createClass(RemoveMapButton, [{
    key: 'view',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril render callback
     * @param vnode
     * @returns {*}
     */

    value: function view(vnode) {
      var attrs = {
        onclick: vnode.attrs.onclick
      };
      return mithril('button', attrs, [mithril('i.material-icons', 'remove_circle_outline'), 'Remove Map']);
    }
  }]);
  return RemoveMapButton;
}();

/**
 * A mithril component of Add Map button
 */
var AddMapButton = function () {
  function AddMapButton() {
    classCallCheck(this, AddMapButton);
  }

  createClass(AddMapButton, [{
    key: 'view',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril render callback
     * @param vnode
     * @return {*}
     */

    value: function view(vnode) {
      var attrs = {
        onclick: vnode.attrs.onclick
      };
      return mithril('button', attrs, [mithril('i.material-icons', 'add_circle_outline'), 'Add Map']);
    }
  }]);
  return AddMapButton;
}();

/**
 * A mithril component of Add Map button
 */
var ConfigurationButton = function () {
  function ConfigurationButton() {
    classCallCheck(this, ConfigurationButton);
  }

  createClass(ConfigurationButton, [{
    key: 'view',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril render callback
     * @param vnode
     * @returns {*}
     */
    value: function view(vnode) {
      var attrs = {
        onclick: vnode.attrs.onclick
      };
      return mithril('button', attrs, [mithril('i.material-icons', 'mode_edit'), 'Configuration']);
    }
  }]);
  return ConfigurationButton;
}();

/**
 * A mithril component of Add Map button
 */
var UploadButton = function () {
  function UploadButton() {
    classCallCheck(this, UploadButton);
  }

  createClass(UploadButton, [{
    key: 'view',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril render callback
     * @param vnode
     * @returns {*}
     */

    value: function view(vnode) {
      var attrs = {
        onclick: vnode.attrs.onclick
      };
      return mithril('button', attrs, [mithril('i.material-icons', 'input'), 'Add Data']);
    }
  }]);
  return UploadButton;
}();

/**
 * A mithril component for map removal dialog
 */
var MapRemovalDialog = function () {
  function MapRemovalDialog() {
    classCallCheck(this, MapRemovalDialog);
  }

  createClass(MapRemovalDialog, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril lifecycle method
     * @param vnode
     */

    value: function oninit(vnode) {
      this.model = vnode.attrs.model;
      this.onDismiss = vnode.attrs.onDismiss;
      this.selection = [];
    }

    /**
     * event handler for cancel button
     * @param evt
     * @private
     */

  }, {
    key: '_onCancel',
    value: function _onCancel(evt) {
      evt.preventDefault();
      this.onDismiss(evt);
    }

    /**
     * event handler for remove button
     * @param evt
     * @private
     */

  }, {
    key: '_onRemove',
    value: function _onRemove(evt) {
      var _this = this;

      this.model.bioMaps = this.model.bioMaps.filter(function (bioMap) {
        return _this.selection.indexOf(bioMap) === -1;
      });
      pubsub.publish(mapRemoved, this.selection);
      evt.preventDefault();
      this.onDismiss(evt);
    }

    /**
     * event handler for checkbox
     * @param bioMap
     * @private
     */

  }, {
    key: '_onToggleSelection',
    value: function _onToggleSelection(bioMap) {
      var i = this.selection.indexOf(bioMap);
      if (i === -1) {
        this.selection.push(bioMap);
      } else {
        this.selection.splice(i, 1);
      }
    }

    /**
     * mithril render callback
     * @returns {*}
     */

  }, {
    key: 'view',
    value: function view() {
      var _this2 = this;

      var haveSelection = this.selection.length > 0;
      var plural = this.selection.length > 1;
      return mithril('div.cmap-map-removal-dialog', [mithril('h5', plural ? 'Remove Maps' : 'Remove Map'), mithril('form', [this.model.bioMaps.map(function (bioMap) {
        return mithril('label.cmap-map-name', [mithril('input[type="checkbox"]', {
          checked: _this2.selection.indexOf(bioMap) !== -1,
          onclick: function onclick() {
            return _this2._onToggleSelection(bioMap);
          }
        }), mithril('span.label-body', bioMap.uniqueName)]);
      }), mithril('button', {
        class: haveSelection ? 'button-primary' : 'button',
        disabled: !haveSelection,
        autocomplete: 'off', // firefox workaround for disabled state
        onclick: function onclick(evt) {
          return _this2._onRemove(evt);
        }
      }, [mithril('i.material-icons', 'remove_circle_outline'), 'Remove Selected']), mithril('button.button', { onclick: function onclick(evt) {
          return _this2._onCancel(evt);
        } }, [mithril('i.material-icons', 'cancel'), 'Cancel'])])]);
    }
  }]);
  return MapRemovalDialog;
}();

/**
 * A mithril component for map removal dialog
 */
var MapAdditionDialog = function () {
  function MapAdditionDialog() {
    classCallCheck(this, MapAdditionDialog);
  }

  createClass(MapAdditionDialog, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril lifecycle method
     * @param vnode
     */

    value: function oninit(vnode) {
      this.model = vnode.attrs.model;
      this.onDismiss = vnode.attrs.onDismiss;
      this.selection = null;
    }

    /**
     * event handler for cancel button.
     * @param evt
     * @private
     */

  }, {
    key: '_onCancel',
    value: function _onCancel(evt) {
      evt.preventDefault();
      this.onDismiss(evt);
    }

    /**
     * event handler for add-on-right button
     * @param evt
     * @private
     */

  }, {
    key: '_onAddRight',
    value: function _onAddRight(evt) {
      var i = this.model.bioMaps.length;
      this.model.addMap(this.selection, i);
      evt.preventDefault();
      this.onDismiss(evt);
    }

    /**
     * event handler for add-on-left button
     * @param evt
     * @private
     */

  }, {
    key: '_onAddLeft',
    value: function _onAddLeft(evt) {
      this.model.addMap(this.selection, 0);
      evt.preventDefault();
      this.onDismiss(evt);
    }

    /**
     * event handler for radio button change.
     * @param evt
     * @param map
     * @private
     */

  }, {
    key: '_onSelection',
    value: function _onSelection(evt, map) {
      evt.preventDefault();
      this.selection = map;
    }

    /**
     * mithril component render callback.
     * @returns {*}
     */

  }, {
    key: 'view',
    value: function view() {
      var _this = this;

      var allMaps = this.model.allMaps || [];
      return mithril('div.cmap-map-addition-dialog', [mithril('h5', 'Add Map'), mithril('form', [mithril('table.u-full-width', [mithril('thead', mithril('tr', [mithril('th', 'Data Source'), mithril('th', 'Available Maps')])), mithril('tbody', this.model.sources.map(function (source) {
        return mithril('tr', [mithril('td', source.id), mithril('td', allMaps.filter(function (map) {
          return map.source === source && _this.model.bioMaps.indexOf(map) === -1;
        }).map(function (map) {
          return mithril('label', [mithril('input[type="radio"]', {
            name: 'maps4' + source.id,
            checked: _this.selection === map,
            value: map.uniqueName,
            onchange: function onchange(evt) {
              return _this._onSelection(evt, map);
            }
          }), mithril('span[class="label-body"]', map.name)]);
        }))]);
      }))])]), mithril('button', {
        disabled: !this.selection,
        class: this.selection ? 'button-primary' : 'button',
        onclick: function onclick(evt) {
          return _this._onAddLeft(evt);
        }
      }, [mithril('i.material-icons', 'keyboard_arrow_left'), 'Add Map On Left']), mithril('button.button', {
        disabled: !this.selection,
        class: this.selection ? 'button-primary' : 'button',
        onclick: function onclick(evt) {
          return _this._onAddRight(evt);
        }
      }, [mithril('i.material-icons', 'keyboard_arrow_right'), 'Add Map On Right']), mithril('button.button', { onclick: function onclick(evt) {
          return _this._onCancel(evt);
        } }, [mithril('i.material-icons', 'cancel'), 'Cancel'])]);
    }
  }]);
  return MapAdditionDialog;
}();

/**
 * A mithril component for configuration import/export
 */
var ConfigurationDialog = function () {
  function ConfigurationDialog() {
    classCallCheck(this, ConfigurationDialog);
  }

  createClass(ConfigurationDialog, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril lifecycle method
     */
    /**
     *
     * @param vnode
     */

    value: function oninit(vnode) {
      this.model = vnode.attrs.model;
      var cd = {};
      this.model.bioMaps.forEach(function (bioMap) {
        cd[bioMap.name] = {
          config: bioMap.config,
          name: bioMap.name,
          qtlGroups: bioMap.qtlGroups,
          source: bioMap.source.id
        };
      });

      ConfigData.base = JSON.stringify(cd, null, 2);
      ConfigData.updated = JSON.stringify(cd, null, 2);

      this.onDismiss = vnode.attrs.onDismiss;
      this.selection = null;
    }

    /**
     * event handler for cancel button.
     * @param evt
     * @private
     */

  }, {
    key: '_onCancel',
    value: function _onCancel(evt) {
      evt.preventDefault();
      this.onDismiss(evt);
    }

    /**
     * event handler for use  new configuration button
     * @param evt
     * @private
     */

  }, {
    key: '_onUpdated',
    value: function _onUpdated(evt) {
      var newConfig = JSON.parse(ConfigData.updated);
      var finalConfig = [];
      this.model.allMaps.forEach(function (map) {
        for (var name in newConfig) {
          if (newConfig.hasOwnProperty(name) && name === map.name && newConfig[name].source === map.source.id) {
            console.log();
            var item = map;
            item.config = newConfig[name].config;
            if (newConfig[name].config.tracks) {
              var tracks = JSON.parse(JSON.stringify(newConfig[name].config.tracks));
              delete newConfig[name].config.tracks;
              item.tracks = tracks;
            }
            finalConfig.push(item);
          }
        }
      });
      this.model.bioMaps = finalConfig;
      for (var i = 0; i < finalConfig.length; i++) {
        pubsub.publish(featureUpdate, { mapIndex: i });
      }
      this.onDismiss(evt);
    }

    /**
     * mithril component render callback.
     * @returns {*}
     */

  }, {
    key: 'view',
    value: function view() {
      var _this = this;

      //const allMaps = this.model.allMaps || [];
      return mithril('div.cmap-map-addition-dialog', [mithril('h5', 'Configuration Details'), mithril('form', [mithril('textarea', {
        style: 'width:50%;height:600%',
        value: ConfigData.updated,
        onchange: function onchange(e) {
          e.preventDefault();
          ConfigData.updated = String(e.currentTarget.value);
        }
      })]), mithril('button', {
        class: 'button',
        onclick: function onclick(evt) {
          return _this._onUpdated(evt);
        }
      }, [mithril('i.material-icons', 'mode_edit'), 'Use new configuration']), mithril('button.button', { onclick: function onclick(evt) {
          return _this._onCancel(evt);
        } }, [mithril('i.material-icons', 'cancel'), 'Cancel'])]);
    }
  }]);
  return ConfigurationDialog;
}();

/**
 *
 * @type {{base: string, updated: string, setBase: ConfigData.setBase, setUpdated: ConfigData.setUpdated}}
 */

var ConfigData = {
  base: '',
  updated: '',
  setBase: function setBase(value) {
    ConfigData.base = value;
  },
  setUpdated: function setUpdated(value) {
    ConfigData.updated = value;
  }
};

/**
 * A mithril component for map removal dialog
 */
var UploadDialog = function () {
  function UploadDialog() {
    classCallCheck(this, UploadDialog);
  }

  createClass(UploadDialog, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril lifecycle method
     * @param vnode
     */

    value: function oninit(vnode) {
      this.model = vnode.attrs.model;
      this.onDismiss = vnode.attrs.onDismiss;
      UploadData.new = false;
      UploadData.setName('');
      UploadData.file = '';
      this.selection = null;
    }

    /**
     * event handler for cancel button.
     * @param evt
     * @private
     */

  }, {
    key: '_onCancel',
    value: function _onCancel(evt) {
      evt.preventDefault();
      this.onDismiss(evt);
    }

    /**
     * event handler for add-on-right button
     * @param evt
     * @private
     */

  }, {
    key: '_onAddData',
    value: function _onAddData(evt) {
      var _this = this;

      var sources = [];
      if (!this.selection) {
        this.selection = {
          id: UploadData.newName,
          filters: [],
          linkouts: [],
          method: 'GET',
          url: UploadData.file !== '' ? UploadData.file : UploadData.loc,
          config: {},
          parseResult: { data: [] }
        };
      }

      var oURL = this.selection.url;
      this.selection.url = UploadData.file !== '' ? UploadData.file : UploadData.loc;
      var cfg = [this.selection];

      var promises = cfg.map(function (cfg) {
        var dsm = new DataSourceModel(cfg);
        sources.push(dsm);
        return dsm.load();
      });

      Promise.all(promises).then(function () {
        sources.forEach(function (src) {
          // change names to indicate uploaded data
          if (UploadData.new) {
            _this.model.sources.push(src);
          }
          src.parseResult.data.forEach(function (data) {
            return data.feature_type_acc = 'Uploaded_' + data.feature_type_acc;
          });
          // update parseResults and all maps to reflect new data
          _this.selection.parseResult.data = _this.selection.parseResult.data.concat(src.parseResult.data);
          _this.model.allMaps = _this.model.sources.map(function (src) {
            return Object.values(src.bioMaps);
          }).concatAll();
          // update active view models to show new data
          _this.model.bioMaps.forEach(function (activeMap) {
            _this.model.allMaps.filter(function (map) {
              return map.name === activeMap.name && activeMap.source.id === map.source.id;
            }).forEach(function (match) {
              activeMap.features = match.features;
              activeMap.tags = match.tags;
            });
          });
        });
        _this.selection.url = oURL;
      }).catch(function (err) {
        var msg = 'While loading data source, ' + err;
        console.error(msg);
        console.trace();
        alert(msg);
      });

      evt.preventDefault();
      this.onDismiss(evt);
    }

    /**
     * event handler for radio button change.
     * @param evt
     * @param map
     * @private
     */

  }, {
    key: '_onSelection',
    value: function _onSelection(evt, map) {
      evt.preventDefault();
      this.selection = map;
      UploadData.toggleNew(this.selection);
    }

    /**
     * mithril component render callback.
     * @returns {*}
     */

  }, {
    key: 'view',
    value: function view() {
      var _this2 = this;

      //const allMaps = this.model.allMaps || [];
      return mithril('div.cmap-map-addition-dialog', [mithril('h5', 'Add Map'), mithril('p', 'Currently only one file may be added at a time. If both a URL and a local file are provided, preference will be given to the local file.'), mithril('form', [mithril('table.u-full-width', [mithril('thead', [mithril('tr', [mithril('th', 'URL'), mithril('th', mithril('input[type=text]', {
        oninput: mithril.withAttr('value', UploadData.setLoc),
        value: UploadData.loc,
        style: 'width:60%;'
      }))]), mithril('tr', [mithril('th', 'Local File'), mithril('th', mithril('input[type=file]', {
        onchange: mithril.withAttr('files', UploadData.setFile),
        file: UploadData.files
      }))])]), mithril('tbody', mithril('tr', [mithril('td', 'Target Map Set'), mithril('td', [mithril('label', [mithril('input[type="radio"]', {
        name: 'maps4new',
        checked: UploadData.new,
        value: 'newMap',
        onchange: function onchange(evt) {
          return _this2._onSelection(evt, null);
        }
      }), mithril('input[type=text]', {
        oninput: mithril.withAttr('value', UploadData.setName),
        value: UploadData.newName
      })])].concat(this.model.sources.map(function (map) {
        return mithril('label', [mithril('input[type="radio"]', {
          name: 'maps4' + map.id,
          checked: _this2.selection === map,
          value: map.id,
          onchange: function onchange(evt) {
            return _this2._onSelection(evt, map);
          }
        }), mithril('span[class="label-body"]', map.id)]);
      })))]))])]), mithril('button', {
        //disabled unless a selection is made, or a new set is selected *and* there is a location or file state)
        disabled: !((this.selection || UploadData.new) && (UploadData.loc !== '' || UploadData.file !== '')),
        class: this.selection || UploadData.new ? 'button-primary' : 'button',
        onclick: function onclick(evt) {
          return _this2._onAddData(evt);
        }
      }, [mithril('i.material-icons', 'input'), 'Add Data to Map']), mithril('button.button', { onclick: function onclick(evt) {
          return _this2._onCancel(evt);
        } }, [mithril('i.material-icons', 'cancel'), 'Cancel'])]);
    }
  }]);
  return UploadDialog;
}();

/**
 *
 * @type {{loc: string, file: string, newName: string, new: boolean, setLoc: UploadData.setLoc, setName: UploadData.setName, setFile: UploadData.setFile, toggleNew: UploadData.toggleNew}}
 */

var UploadData = {
  loc: '',
  file: '',
  newName: '',
  new: false,
  setLoc: function setLoc(value) {
    UploadData.loc = value;
  },
  setName: function setName(value) {
    UploadData.newName = value;
  },
  setFile: function setFile(files) {
    var reader = new FileReader();
    reader.onload = function (e) {
      UploadData.file = e.target.result;
    };
    reader.readAsDataURL(files[0]);
  },
  toggleNew: function toggleNew(selection) {
    UploadData.new = !selection;
  }
};

/**
 * A mithril component of the UI tools in a div (toolbar).
 */
//import {FilterButton} from './FilterButton';
var Tools = function () {
  function Tools() {
    classCallCheck(this, Tools);
  }

  createClass(Tools, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril lifecycle method
     * @param vnode
     */

    value: function oninit(vnode) {
      this.appState = vnode.attrs.appState;
      this.currentDialog = vnode.attrs.dialog;
    }

    /**
     * mithril component render method
     * @returns {*}
     */

  }, {
    key: 'view',
    value: function view() {
      var _this = this;

      return mithril('div.cmap-tools', [mithril('div.cmap-toolbar.cmap-hbox', [mithril(ResetButton),
      //m(FilterButton),
      mithril(AddMapButton, {
        onclick: function onclick() {
          return _this.currentDialog = MapAdditionDialog;
        }
      }), mithril(RemoveMapButton, {
        onclick: function onclick() {
          return _this.currentDialog = MapRemovalDialog;
        }
      }), mithril(ConfigurationButton, {
        onclick: function onclick() {
          return _this.currentDialog = ConfigurationDialog;
        }
      }), mithril(UploadButton, {
        onclick: function onclick() {
          return _this.currentDialog = UploadDialog;
        }
      })]), this.currentDialog && mithril(this.currentDialog, {
        model: this.appState,
        onDismiss: function onDismiss() {
          return _this.currentDialog = null;
        }
      })]);
    }
  }]);
  return Tools;
}();

/**
 * Header
 */
var Header = function () {
  function Header() {
    classCallCheck(this, Header);
  }

  createClass(Header, [{
    key: 'oninit',

    // constructor() - prefer do not use in mithril components
    /**
     * mithril lifecycle method
     * @param vnode
     */

    value: function oninit(vnode) {
      this.appState = vnode.attrs.appState;
    }

    /**
     * Mithril lifecycle component
     * @returns {*} cmap-header
     */

  }, {
    key: 'view',
    value: function view() {
      return mithril('div.cmap-hbox', mithril('h4.cmap-header', ['cmap-js ', mithril('span.cmap-header', this.appState.header)]));
    }
  }]);
  return Header;
}();

/**
 * StatusBar
 * A mithril component of a status bar and/or footer.
 */
var StatusBar = function () {
  function StatusBar() {
    classCallCheck(this, StatusBar);
  }

  createClass(StatusBar, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components
    /**
     *
     * @param vnode
     */

    value: function oninit(vnode) {
      this.appState = vnode.attrs.appState;
    }

    /**
     *
     * @returns {*}
     */

  }, {
    key: 'view',
    value: function view() {
      return mithril('div', [mithril('div.cmap-attribution', this.appState.attribution), mithril('div', { id: 'cmap-disclaimer' }, 'cmap-js is still in alpha. As the software is still in development, the current state of the project may not reflect the final release.'), mithril('div.cmap-footer', [this.appState.busy ? mithril('img[src=images/ajax-loader.gif]') : '', this.appState.status])]);
    }
  }]);
  return StatusBar;
}();

/**
 * CircosLayout
 * A mithril component for circos-style layout of BioMaps.
 */
var radians = function radians(degrees) {
  return degrees * Math.PI / 180;
};

//const degrees = radians => radians * 180 / Math.PI; // TODO: remove if unused

var CircosLayout = function (_mix$with) {
  inherits(CircosLayout, _mix$with);

  function CircosLayout() {
    classCallCheck(this, CircosLayout);
    return possibleConstructorReturn(this, (CircosLayout.__proto__ || Object.getPrototypeOf(CircosLayout)).apply(this, arguments));
  }

  createClass(CircosLayout, [{
    key: '_layout',


    // constructor() - prefer do not use in mithril components
    /**
     *
     * @private
     */

    value: function _layout() {
      var domRect = this.el.getBoundingClientRect();
      if (!domRect.width || !domRect.height) {
        // may occur when component is created but dom element has not yet filled
        // available space; expect onupdate() will occur.
        console.warn('deferring layout');
        return;
      }
      var newBounds = new Bounds(domRect);
      var dirty = !Bounds.equals(this.domBounds, newBounds);
      this.domBounds = newBounds;
      /* update child elements with their bounds */
      var radius = this.domBounds.width > this.domBounds.height ? this.domBounds.height * 0.4 : this.domBounds.width * 0.4;
      var n = this.bioMaps.length;
      var center = {
        x: Math.floor(this.domBounds.width * 0.5),
        y: Math.floor(this.domBounds.height * 0.5)
      };
      var degreesPerChild = 360 / n;
      var childWidth = Math.floor(1.1 * this.domBounds.width / n);
      var childHeight = Math.floor(childWidth * 0.6);
      var startDegrees = -180;
      var degrees = startDegrees;
      this.bioMaps.forEach(function (child) {
        var rad = radians(degrees);
        var x = center.x - Math.floor(childWidth * 0.5) + Math.floor(radius * Math.cos(rad));
        var y = center.y - Math.floor(childHeight * 0.5) + Math.floor(radius * Math.sin(rad));
        // noinspection JSSuspiciousNameCombination
        // noinspection JSSuspiciousNameCombination
        child.domBounds = new Bounds({
          left: x,
          top: y,
          width: childHeight, // swap the width and height
          height: childWidth
        });
        child.rotation = Math.floor(degrees) + startDegrees;
        degrees += degreesPerChild;
      });
      if (dirty) mithril.redraw();
    }

    /* mithril render callback */
    /**
     *
     * @returns {*}
     */

  }, {
    key: 'view',
    value: function view() {
      return mithril('div.cmap-layout-circos', this.children.map(mithril));
    }
  }]);
  return CircosLayout;
}(mix(LayoutBase).with(RegisterComponentMixin));

/**
 * LayoutContainer
 * A mithril component to wrap the current layout component inside of a
 * scrollable div.
 */
// define allowed min/max range for scale (zoom operation)
var SCALE = Object.freeze({ min: 0.05, max: 2 });

var LayoutContainer = function (_mix$with) {
  inherits(LayoutContainer, _mix$with);

  function LayoutContainer() {
    classCallCheck(this, LayoutContainer);
    return possibleConstructorReturn(this, (LayoutContainer.__proto__ || Object.getPrototypeOf(LayoutContainer)).apply(this, arguments));
  }

  createClass(LayoutContainer, [{
    key: 'oninit',


    // constructor() - prefer do not use in mithril components

    /**
     * mithril lifecycle method
     * @param vnode
     */

    value: function oninit(vnode) {
      var _this2 = this;

      get(LayoutContainer.prototype.__proto__ || Object.getPrototypeOf(LayoutContainer.prototype), 'oninit', this).call(this, vnode);
      this.appState = vnode.attrs.appState;
      this.vnode = vnode;
      pubsub.subscribe(reset, function () {
        return _this2._onReset();
      });

      // create some regular expressions for faster dispatching of events
      this._gestureRegex = {
        pan: new RegExp('^pan'),
        pinch: new RegExp('^pinch'),
        tap: new RegExp('^tap'),
        wheel: new RegExp('^wheel')
      };
    }

    /**
     * mithril lifecycle method
     * @param vnode
     */

  }, {
    key: 'oncreate',
    value: function oncreate(vnode) {
      get(LayoutContainer.prototype.__proto__ || Object.getPrototypeOf(LayoutContainer.prototype), 'oncreate', this).call(this, vnode);
      this.el = vnode.dom; // this is the outer m('div') from view()
      //this._setupEventHandlers(this.el);
      vnode.state.bounds = this.bounds = new Bounds(this.el.getBoundingClientRect());
      vnode.state.contentBounds = this.contentBounds = new Bounds({
        left: 0,
        top: 0,
        width: this.bounds.width,
        height: this.bounds.height
      });
      // save these dimensions for 'reset' event
      this.originalContentBounds = new Bounds(this.contentBounds);
    }

    /**
     * mithril lifecycle method
     * @param vnode
     */

  }, {
    key: 'onupdate',
    value: function onupdate(vnode) {
      this.bounds = new Bounds(vnode.dom.getBoundingClientRect());
    }

    /**
     * mithril component render method
     * @param vnode
     * @returns {*}
     */

  }, {
    key: 'view',
    value: function view(vnode) {
      var b = this.contentBounds || {}; // relative bounds of the layout-container
      var scale = this.appState.tools.zoomFactor;
      return mithril('div.cmap-layout-container', {
        style: 'left: ' + b.left + 'px; top: ' + b.top + 'px;\n              width: ' + b.width + 'px; height: ' + b.height + 'px;\n              transform: scale(' + scale + ')'
      }, [this.appState.tools.layout === HorizontalLayout ? mithril(HorizontalLayout, {
        appState: this.appState,
        layoutBounds: this.bounds,
        contentBounds: vnode.state.contentBounds
      }) : mithril(CircosLayout, { appState: this.appState, layoutBounds: this.bounds })]);
    }

    /**
     * handle the event from _dispatchGestureEvt. Returns true or false
     * to stop or continue event propagation.
     * @param evt
     * @returns {boolean}
     */

  }, {
    key: 'handleGesture',
    value: function handleGesture(evt) {
      if (evt.type.match(this._gestureRegex.pan)) {
        return this._onPan(evt);
      } else if (evt.type.match(this._gestureRegex.pinch)) {
        return this._onZoom(evt);
      } else if (evt.type.match(this._gestureRegex.wheel)) {
        return this._onZoom(evt);
      }
      return false; // do not stop event propagation
    }

    /**
     *
     * @param evt
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_onZoom',
    value: function _onZoom(evt) {
      // TODO: utilize the distance of touch event for better interaction
      var normalized = evt.deltaY / this.bounds.height;
      var z = this.appState.tools.zoomFactor + normalized;
      // noinspection Annotator
      this.appState.tools.zoomFactor = Math.clamp(z, SCALE.min, SCALE.max);
      mithril.redraw();
      return true; // stop evt propagation
    }

    /**
     *
     * @param evt
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_onPan',
    value: function _onPan(evt) {
      console.log('LayoutContainer -> onPan', evt);
      // hammer provides the delta x,y in a distance since the start of the
      // gesture so need to convert it to delta x,y for this event.
      if (evt.type === 'panend') {
        this.lastPanEvent = null;
        return true;
      }
      var delta = {};
      if (this.lastPanEvent) {
        delta.x = -1 * (this.lastPanEvent.deltaX - evt.deltaX);
        delta.y = -1 * (this.lastPanEvent.deltaY - evt.deltaY);
      } else {
        delta.x = evt.deltaX;
        delta.y = evt.deltaY;
      }
      this.contentBounds.left += delta.x;
      //this.contentBounds.top += delta.y;
      mithril.redraw();
      this.lastPanEvent = evt;
      return true; // stop event propagation
    }

    /**
     *
     * @private
     */

  }, {
    key: '_onReset',
    value: function _onReset() {
      this.contentBounds = new Bounds(this.originalContentBounds);
      mithril.redraw();
    }
  }]);
  return LayoutContainer;
}(mix().with(RegisterComponentMixin));

/**
 * UI
 * A mithril component presenting all DOM aspects of user-interface.
 */
var UI = function (_mix$with) {
  inherits(UI, _mix$with);

  /**
   * Create a UI instance
   * @param {Object} appState - instance of model/AppModel.
   */

  function UI(appState) {
    classCallCheck(this, UI);

    var _this = possibleConstructorReturn(this, (UI.__proto__ || Object.getPrototypeOf(UI)).call(this));

    _this.appState = appState;
    return _this;
  }

  /**
   * Mithril lifecycle method
   * @param vnode
   */

  createClass(UI, [{
    key: 'oncreate',
    value: function oncreate(vnode) {
      get(UI.prototype.__proto__ || Object.getPrototypeOf(UI.prototype), 'oncreate', this).call(this, vnode);
      this.el = vnode.dom;
      this._setupEventHandlers(this.el);
    }

    /**
     * mithril component render callback
     * @returns {*} mithril vnode component
     */

  }, {
    key: 'view',
    value: function view() {
      var _this2 = this;

      var childAttrs = {
        appState: this.appState
      };
      this._logRenders();
      return mithril('div.cmap-layout.cmap-vbox', [mithril(Header, childAttrs), mithril(Tools, childAttrs), mithril('div#cmap-layout-titles', { style: 'display:inline-flex;' }), [mithril('div.cmap-menu-viewport#cmap-menu-viewport', { style: 'display:none;' }), mithril('div.cmap-layout-viewport.cmap-hbox', { id: 'cmap-layout-viewport', style: 'position:relative;' }, mithril(LayoutContainer, {
        appState: this.appState,
        registerComponentCallback: function registerComponentCallback(comp) {
          return _this2._layoutContainer = comp;
        }
      }))], mithril(StatusBar, childAttrs)]);
    }

    /**
     *
     * @private
     */

  }, {
    key: '_logRenders',
    value: function _logRenders() {
      if (!this.count) this.count = 0;
      this.count += 1;
      console.log('*** mithril render #' + this.count + ' ***');
    }

    /**
     *
     * @private
     */

  }, {
    key: '_setupEventHandlers',
    value: function _setupEventHandlers() {
      this._setupMousewheel();
      this._setupGestures();
      this._setupPubSub();
    }

    /**
     * Setup pubsub subscriptions
     * @private
     */

  }, {
    key: '_setupPubSub',
    value: function _setupPubSub() {
      pubsub.subscribe(reset, function () {
        // if the viewport were refactored into it's own mithril component, then
        // doing a lookup by ID would be unnecessary.
        var viewport = document.getElementById('cmap-layout-viewport');
        viewport.scrollTop = 0;
        viewport.scrollLeft = 0;
      });
    }

    /**
     * setup mouse wheel (hamsterjs) handlers.
     * @private
     */

  }, {
    key: '_setupMousewheel',
    value: function _setupMousewheel() {
      var _this3 = this;

      var hamster$$1 = hamster(this.el);
      var hamsterHandler = function hamsterHandler(evt, delta, deltaX, deltaY) {
        // hamsterjs claims to normalizing the event object, across browsers,
        // but at least in firefox it is not because deltaY is not on the evt.
        evt.deltaY = deltaY; // workaround
        // add an additional property to make it similar enough to the pinch
        // gesture so event consumers can just implement one 'zoom', if they want.
        evt.center = { x: evt.originalEvent.x, y: evt.originalEvent.y };
        _this3._dispatchGestureEvt(evt);
      };
      hamster$$1.wheel(hamsterHandler);
    }

    /**
     * setup gesture (hammerjs) handlers.
     * @private
     */

  }, {
    key: '_setupGestures',
    value: function _setupGestures() {
      var _this4 = this;

      var hammer$$1 = hammer(this.el);
      var hammerHandler = function hammerHandler(evt) {
        return _this4._dispatchGestureEvt(evt);
      };
      var hammerEvents = 'panmove panend panstart pinchmove pinchend tap';
      hammer$$1.get('pan').set({ direction: hammer.DIRECTION_ALL });
      hammer$$1.get('pinch').set({ enable: true });
      hammer$$1.on(hammerEvents, hammerHandler);
    }

    /**
     * Custom dispatch of ui events. Layout elements like BioMap and
     * CorrespondenceMap are visually overlapping, and so do not fit cleanly into
     * the js event capture or bubbling phases. Query the dom at the events
     * coordinates, and dispatch the event to child who
     * a) intersects with this point
     * b) wants to handle this event (it can decide whether to based on it's
     *    canvas own scenegraph contents, etc.)
     *
     * @param evt
     * @private
     */

  }, {
    key: '_dispatchGestureEvt',
    value: function _dispatchGestureEvt(evt) {
      var hitElements = document.elementsFromPoint(evt.center.x, evt.center.y);
      var filtered = hitElements.filter(function (el) {
        return el.mithrilComponent && el.mithrilComponent.handleGesture;
      });
      // dispatch event to all the mithril components, until one returns true;
      // effectively the same as 'stopPropagation' on a normal event bubbling.
      filtered.some(function (el) {
        return el.mithrilComponent.handleGesture(evt);
      });
    }

    /**
     * Gesture event recapture and force upon the LayoutContainer. This is to
     * prevent the the layout container from missing events after it has partially
     * moved out of the viewport.
     *
     * @param evt
     */

  }, {
    key: 'handleGesture',
    value: function handleGesture(evt) {
      this._layoutContainer.handleGesture(evt);
    }
  }]);
  return UI;
}(mix().with(RegisterComponentMixin));

/**
 * CMAP
 */

/* istanbul ignore next: mithril-query does not work with m.mount, and dom id is hardcoded as well */
var CMAP = function () {
  function CMAP() {
    classCallCheck(this, CMAP);
  }

  createClass(CMAP, [{
    key: 'load',


    /**
     *
     * @param configURL
     */

    value: function load(configURL) {
      var _this = this;

      this.rootElement = document.getElementById('cmap-ui');
      this.appState = new AppModel({});
      this.UI = new UI(this.appState);
      mithril.mount(this.rootElement, this.UI);

      if (configURL === null) {
        configURL = 'cmap.json';
      }

      this.appState.status = 'loading configuration file...';
      this.appState.busy = true;

      mithril.request(configURL).then(function (config) {
        var numSources = config.sources.length;
        var plural = numSources > 1 ? 's' : '';
        _this.appState.status = 'loading ' + numSources + ' data file' + plural + '...';
        var promises = _this.appState.load(config);
        Promise.all(promises).then(function () {
          _this.appState.status = '';
          _this.appState.busy = false;
        });
      }).catch(function (err) {
        // TODO: make a nice mithril component to display errors in the UI
        console.error(err);
        console.trace();
        alert('While fetching cmap.json config file, ' + err);
      });
    }
  }]);
  return CMAP;
}();

/**
 * @file
 * Instantiate the CMAP class, and initialize it.
 * Also the entry point for bundling of javascript and css.
 */
/* istanbul ignore next: unable to test this module because of css imports */
/**
 * @description Initializes CMAP window with CSS and makes sure that the initial
 * DOM events are properly handled.
 *
 */

var main = function main() {
  // FIXME: this way of exposing the cmap object seems kind of clunky. For
  // implementing a js api, maybe using this rollup plugin would be
  // useful: https://github.com/rollup/rollup-plugin-multi-entry
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    // support commonjs loading, if it exists.
    module.exports = CMAP;
  } else {
    // otherwise put cmap constructor in window global
    window.cmap = CMAP;
  }
  var evtName = 'DOMContentLoaded';
  var loadedHandler = function loadedHandler() {
    var _cmap = new CMAP();
    _cmap.load(new URLSearchParams(window.location.search).get('config'));
    document.removeEventListener(evtName, loadedHandler);
  };
  document.addEventListener(evtName, loadedHandler);
};

main();

}());
//# sourceMappingURL=cmap.min.js.map
